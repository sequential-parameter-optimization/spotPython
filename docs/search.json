[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hyperparameter-tuning Cookbook",
    "section": "",
    "text": "Preface\nThe goal of hyperparameter tuning (or hyperparameter optimization) is to optimize the hyperparameters to improve the performance of the machine or deep learning model.\nspotPython (“Sequential Parameter Optimization Toolbox in Python”) is the Python version of the well-known hyperparameter tuner SPOT, which has been developed in the R programming environment for statistical analysis for over a decade. The related open-access book is available here: Hyperparameter Tuning for Machine and Deep Learning with R—A Practical Guide.\nscikit-learn is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license. The project was started in 2007 by David Cournapeau as a Google Summer of Code project, and since then many volunteers have contributed.\nPyTorch is an optimized tensor library for deep learning using GPUs and CPUs.\nRiver is a Python library for online machine learning. It is designed to be used in real-world environments, where not all data is available at once, but streaming in."
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Hyperparameter-tuning Cookbook",
    "section": "Citation",
    "text": "Citation\nIf this paper has been useful to you and you wish to cite it in a scientific publication, please refer to the following paper:\n@ARTICLE{bart23earxiv,\n       author = {{Bartz-Beielstein}, Thomas},\n        title = \"{PyTorch Hyperparameter Tuning -- A Tutorial for spotPython}\",\n      journal = {arXiv e-prints},\n     keywords = {Computer Science - Machine Learning, Computer Science - Artificial Intelligence, Mathematics - Numerical Analysis, 68T07, A.1, B.8.0, G.1.6, G.4, I.2.8},\n         year = 2023,\n        month = may,\n          eid = {arXiv:2305.11930},\n        pages = {arXiv:2305.11930},\n          doi = {10.48550/arXiv.2305.11930},\narchivePrefix = {arXiv},\n       eprint = {2305.11930},\n primaryClass = {cs.LG},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230511930B},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction: Hyperparameter Tuning",
    "section": "",
    "text": "2 The Hyperparameter Tuning Software SPOT\nSurrogate model based optimization methods are common approaches in simulation and optimization. SPOT was developed because there is a great need for sound statistical analysis of simulation and optimization algorithms. SPOT includes methods for tuning based on classical regression and analysis of variance techniques. It presents tree-based models such as classification and regression trees and random forests as well as Bayesian optimization (Gaussian process models, also known as Kriging). Combinations of different meta-modeling approaches are possible. SPOT comes with a sophisticated surrogate model based optimization method, that can handle discrete and continuous inputs. Furthermore, any model implemented in scikit-learn can be used out-of-the-box as a surrogate in spotPython.\nSPOT implements key techniques such as exploratory fitness landscape analysis and sensitivity analysis. It can be used to understand the performance of various algorithms, while simultaneously giving insights into their algorithmic behavior. In addition, SPOT can be used as an optimizer and for automatic and interactive tuning. Details on SPOT and its use in practice are given by Bartz et al. (2022).\nA typical hyperparameter tuning process with spotPython consists of the following steps:"
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introduction: Hyperparameter Tuning",
    "section": "",
    "text": "https://github.com/sequential-parameter-optimization↩︎"
  },
  {
    "objectID": "01_spot_intro.html#spot-as-an-optimizer",
    "href": "01_spot_intro.html#spot-as-an-optimizer",
    "title": "2  Introduction to Sequential Parameter Optimization",
    "section": "2.1 spot as an Optimizer",
    "text": "2.1 spot as an Optimizer\nThe spot loop consists of the following steps:\n\nInit: Build initial design \\(X\\)\nEvaluate initial design on real objective \\(f\\): \\(y = f(X)\\)\nBuild surrogate: \\(S = S(X,y)\\)\nOptimize on surrogate: \\(X_0 = \\text{optimize}(S)\\)\nEvaluate on real objective: \\(y_0 = f(X_0)\\)\nImpute (Infill) new points: \\(X = X \\cup X_0\\), \\(y = y \\cup y_0\\).\nGot 3.\n\n\nCentral Idea:\n\nEvaluation of the surrogate model S is much cheaper (or / and much faster) than running the real-world experiment \\(f\\).\n\n\nWe start with a small example."
  },
  {
    "objectID": "01_spot_intro.html#example-spot-and-the-sphere-function",
    "href": "01_spot_intro.html#example-spot-and-the-sphere-function",
    "title": "2  Introduction to Sequential Parameter Optimization",
    "section": "2.2 1 Example: Spot and the Sphere Function",
    "text": "2.2 1 Example: Spot and the Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n2.2.1 The Objective Function: Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2\\]\n\n\nfun = analytical().fun_sphere\n\n\nWe can apply the function fun to input values and plot the result:\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x)\nplt.figure()\nplt.plot(x, y, \"k\")\nplt.show()\n\n\n\n\n\nspot_0 = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]))\n\n\nspot_0.run()\n\n&lt;spotPython.spot.spot.Spot at 0x16e0859f0&gt;\n\n\n\nspot_0.print_results()\n\nmin y: 3.696886711914087e-10\nx0: 1.922728975158508e-05\n\n\n[['x0', 1.922728975158508e-05]]\n\n\n\nspot_0.plot_progress(log_y=True)\n\n\n\n\n\nspot_0.plot_model()"
  },
  {
    "objectID": "01_spot_intro.html#spot-parameters-fun_evals-init_size-and-show_models",
    "href": "01_spot_intro.html#spot-parameters-fun_evals-init_size-and-show_models",
    "title": "2  Introduction to Sequential Parameter Optimization",
    "section": "2.3 Spot Parameters: fun_evals, init_size and show_models",
    "text": "2.3 Spot Parameters: fun_evals, init_size and show_models\n\nWe will modify three parameters:\n\nThe number of function evaluations (fun_evals)\nThe size of the initial design (init_size)\nThe parameter show_models, which visualizes the search process for 1-dim functions.\n\nThe full list of the Spot parameters is shown in the Help System and in the notebook spot_doc.ipynb.\n\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([2]),\n                   fun_evals= 10,\n                   seed=123,\n                   show_models=True,\n                   design_control={\"init_size\": 9})\nspot_1.run()\n\n\n\n\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16e022b90&gt;"
  },
  {
    "objectID": "01_spot_intro.html#print-the-results",
    "href": "01_spot_intro.html#print-the-results",
    "title": "2  Introduction to Sequential Parameter Optimization",
    "section": "2.4 Print the Results",
    "text": "2.4 Print the Results\n\nspot_1.print_results()\n\nmin y: 3.6779240309761575e-07\nx0: -0.0006064589047063418\n\n\n[['x0', -0.0006064589047063418]]"
  },
  {
    "objectID": "01_spot_intro.html#show-the-progress",
    "href": "01_spot_intro.html#show-the-progress",
    "title": "2  Introduction to Sequential Parameter Optimization",
    "section": "2.5 Show the Progress",
    "text": "2.5 Show the Progress\n\nspot_1.plot_progress()"
  },
  {
    "objectID": "02_spot_multidim.html",
    "href": "02_spot_multidim.html",
    "title": "3  Introduction to Sequential Parameter Optimization",
    "section": "",
    "text": "4 Exercises"
  },
  {
    "objectID": "02_spot_multidim.html#multi-dimensional-functions",
    "href": "02_spot_multidim.html#multi-dimensional-functions",
    "title": "3  Introduction to Sequential Parameter Optimization",
    "section": "3.1 Multi-dimensional Functions",
    "text": "3.1 Multi-dimensional Functions\n\nThis notebook illustrates how high-dimensional functions can be analyzed."
  },
  {
    "objectID": "02_spot_multidim.html#example-spot-and-the-3-dim-sphere-function",
    "href": "02_spot_multidim.html#example-spot-and-the-3-dim-sphere-function",
    "title": "3  Introduction to Sequential Parameter Optimization",
    "section": "3.2 1 Example: Spot and the 3-dim Sphere Function",
    "text": "3.2 1 Example: Spot and the 3-dim Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\nimport pylab\nfrom numpy import append, ndarray, multiply, isinf, linspace, meshgrid, ravel\nfrom numpy import array\n\n\n3.2.1 The Objective Function: 3-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = \\sum_i^n x_i^2 \\]\nHere we will use \\(n=3\\).\n\n\nfun = analytical().fun_sphere\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use np.array([-1, -1, -1]), i.e., a three-dim function.\nWe will use three different theta values (one for each dimension), i.e., we set\nsurrogate_control={\"n_theta\": 3}.\n\n\nspot_3 = spot.Spot(fun=fun,\n                   lower = -1.0*np.ones(3),\n                   upper = np.ones(3),\n                   var_name=[\"Pressure\", \"Temp\", \"Lambda\"],\n                   show_progress=True,\n                   surrogate_control={\"n_theta\": 3})\n\nspot_3.run()\n\nspotPython tuning: 0.03443344056467332 [#######---] 73.33% \n\n\nspotPython tuning: 0.03134865993507926 [########--] 80.00% \n\n\nspotPython tuning: 0.0009629342967936851 [#########-] 86.67% \n\n\nspotPython tuning: 8.541951463966474e-05 [#########-] 93.33% \n\n\nspotPython tuning: 6.285135731399678e-05 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x1073a10c0&gt;\n\n\n\n\n3.2.2 Results\n\nspot_3.print_results()\n\nmin y: 6.285135731399678e-05\nPressure: 0.005236109709736696\nTemp: 0.0019572552655686714\nLambda: 0.005621713639718905\n\n\n[['Pressure', 0.005236109709736696],\n ['Temp', 0.0019572552655686714],\n ['Lambda', 0.005621713639718905]]\n\n\n\nspot_3.plot_progress()\n\n\n\n\n\n\n3.2.3 A Contour Plot\n\nWe can select two dimensions, say \\(i=0\\) and \\(j=1\\), and generate a contour plot as follows.\n\nNote: We have specified identical min_z and max_z values to generate comparable plots!\n\n\n\nspot_3.plot_contour(i=0, j=1, min_z=0, max_z=2.25)\n\n\n\n\n\nIn a similar manner, we can plot dimension \\(i=0\\) and \\(j=2\\):\n\n\nspot_3.plot_contour(i=0, j=2, min_z=0, max_z=2.25)\n\n\n\n\n\nThe final combination is \\(i=1\\) and \\(j=2\\):\n\n\nspot_3.plot_contour(i=1, j=2, min_z=0, max_z=2.25)\n\n\n\n\n\nThe three plots look very similar, because the fun_sphere is symmetric.\nThis can also be seen from the variable importance:\n\n\nspot_3.print_importance()\n\nPressure:  99.35185545837122\nTemp:  99.99999999999999\nLambda:  94.31627052007231\n\n\n[['Pressure', 99.35185545837122],\n ['Temp', 99.99999999999999],\n ['Lambda', 94.31627052007231]]"
  },
  {
    "objectID": "02_spot_multidim.html#conclusion",
    "href": "02_spot_multidim.html#conclusion",
    "title": "3  Introduction to Sequential Parameter Optimization",
    "section": "3.3 Conclusion:",
    "text": "3.3 Conclusion:\n\nBased on this quick analysis, we can conclude that all three dimensions are equally important (as expected, because the analytical function is known)."
  },
  {
    "objectID": "02_spot_multidim.html#exercise-1",
    "href": "02_spot_multidim.html#exercise-1",
    "title": "3  Introduction to Sequential Parameter Optimization",
    "section": "4.1 Exercise 1",
    "text": "4.1 Exercise 1\n\nEach team member should choose one of the following objective functions.\nPlease add your name to the section title!\n\n\n4.1.1 1. The Three Dimensional fun_cubed\n\nThe input dimension is 3. The search range is \\(-1 \\leq x \\leq 1\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\n\n\n\n\n4.1.2 2. The Ten Dimensional fun_wing_wt\n\nThe input dimension is 10. The search range is \\(0 \\leq x \\leq 1\\) for all dimensions.\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\nGenerate contour plots for the three most important variables. Do they confirm your selection?\n\n\n\n\n4.1.3 3. The Three Dimensional fun_runge\n\nThe input dimension is 3. The search range is \\(-5 \\leq x \\leq 5\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\n\n\n\n\n4.1.4 4. The Three Dimensional fun_linear\n\nThe input dimension is 3. The search range is \\(-5 \\leq x \\leq 5\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?"
  },
  {
    "objectID": "03_spot_anisotropic.html",
    "href": "03_spot_anisotropic.html",
    "title": "4  Introduction to Sequential Parameter Optimization",
    "section": "",
    "text": "5 Exercises"
  },
  {
    "objectID": "03_spot_anisotropic.html#isotropic-and-anisotropic-kriging",
    "href": "03_spot_anisotropic.html#isotropic-and-anisotropic-kriging",
    "title": "4  Introduction to Sequential Parameter Optimization",
    "section": "4.1 Isotropic and Anisotropic Kriging",
    "text": "4.1 Isotropic and Anisotropic Kriging"
  },
  {
    "objectID": "03_spot_anisotropic.html#example-isotropic-spot-surrogate-and-the-2-dim-sphere-function",
    "href": "03_spot_anisotropic.html#example-isotropic-spot-surrogate-and-the-2-dim-sphere-function",
    "title": "4  Introduction to Sequential Parameter Optimization",
    "section": "4.2 1 Example: Isotropic Spot Surrogate and the 2-dim Sphere Function",
    "text": "4.2 1 Example: Isotropic Spot Surrogate and the 2-dim Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n4.2.1 The Objective Function: 2-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x, y) = x^2 + y^2\\]\n\n\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use np.array([-1, -1]), i.e., a two-dim function.\n\n\nspot_2 = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]))\n\nspot_2.run()\n\n&lt;spotPython.spot.spot.Spot at 0x28c49b940&gt;\n\n\n\n\n4.2.2 Results\n\nspot_2.print_results()\n\nmin y: 2.093282610941807e-05\nx0: 0.0016055267473267492\nx1: 0.00428428640184529\n\n\n[['x0', 0.0016055267473267492], ['x1', 0.00428428640184529]]\n\n\n\nspot_2.plot_progress(log_y=True)"
  },
  {
    "objectID": "03_spot_anisotropic.html#same-but-with-anisotropic-kriging",
    "href": "03_spot_anisotropic.html#same-but-with-anisotropic-kriging",
    "title": "4  Introduction to Sequential Parameter Optimization",
    "section": "4.3 2 Same, but with anisotropic Kriging",
    "text": "4.3 2 Same, but with anisotropic Kriging\n\nThe default parameter setting of spotPython’s Kriging surrogate uses the same theta value for every dimension.\nThis is referred to as “using an isotropic kernel”.\nIf different theta values are used for each dimension, then an anisotropic kernel is used\nTo enable anisotropic models in spotPython, the number of theta values should be larger than one.\nWe can use surrogate_control={\"n_theta\": 2} to enable this behavior (2 is the problem dimension).\n\n\nspot_2_anisotropic = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]),\n                   surrogate_control={\"n_theta\": 2})\nspot_2_anisotropic.run()\n\n&lt;spotPython.spot.spot.Spot at 0x28e79fb80&gt;\n\n\n\n4.3.1 Taking a Look at the theta Values\n\nWe can check, whether one or several theta values were used.\nThe theta values from the surrogate can be printed as follows:\n\n\nspot_2_anisotropic.surrogate.theta\n\narray([0.19447342, 0.30813872])\n\n\n\nSince the surrogate from the isotropic setting was stored as spot_2, we can also take a look at the theta value from this model:\n\n\nspot_2.surrogate.theta\n\narray([0.26287447])\n\n\n\nNext, the search progress of the optimization with the anisotropic model can be visualized:\n\n\nspot_2_anisotropic.plot_progress(log_y=True)\n\n\n\n\n\nspot_2_anisotropic.print_results()\n\nmin y: 7.77061191821505e-06\nx0: -0.0024488252797500764\nx1: -0.0013318658594137815\n\n\n[['x0', -0.0024488252797500764], ['x1', -0.0013318658594137815]]\n\n\n\nspot_2_anisotropic.surrogate.plot()"
  },
  {
    "objectID": "03_spot_anisotropic.html#exercise-1",
    "href": "03_spot_anisotropic.html#exercise-1",
    "title": "4  Introduction to Sequential Parameter Optimization",
    "section": "5.1 Exercise 1",
    "text": "5.1 Exercise 1\n\nEach team member should choose one of the following objective functions.\nPlease add your name to the section title!\n\n\n5.1.1 1. fun_branin\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-5 \\leq x_1 \\leq 10\\) and \\(0 \\leq x_2 \\leq 15\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion: instead of the number of evaluations (which is specified via fun_evals), the time should be used as the termination criterion. This can be done as follows (max_time=1 specifies a run time of one minute):\n\n\nfun_evals=inf,\nmax_time=1,\n\n\n\n5.1.2 2. fun_sin_cos\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-2\\pi \\leq x_1 \\leq 2\\pi\\) and \\(-2\\pi \\leq x_2 \\leq 2\\pi\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin.\n\n\n\n5.1.3 3. fun_runge\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-5 \\leq x_1 \\leq 5\\) and \\(-5 \\leq x_2 \\leq 5\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin.\n\n\n\n5.1.4 4. fun_wingwt\n\nDescribe the function.\n\nThe input dimension is 10. The search ranges are between 0 and 1 (values are mapped internally to their natural bounds).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin."
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html",
    "href": "04_spot_sklearn_surrogate.html",
    "title": "5  Sequential Parameter Optimization",
    "section": "",
    "text": "6 3 Example: One-dimensional Sphere Function With spotPython’s Kriging\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-1])\nupper = np.array([1])\nfun = analytical(seed=123).fun_sphere\nspot_1 = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 10,\n                   max_time = inf,\n                   seed=123,\n                   show_models= True,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   design_control={\"init_size\": 3},)\nspot_1.run()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x28dfc5150&gt;"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#using-sklearn-surrogates",
    "href": "04_spot_sklearn_surrogate.html#using-sklearn-surrogates",
    "title": "5  Sequential Parameter Optimization",
    "section": "5.1 Using sklearn Surrogates",
    "text": "5.1 Using sklearn Surrogates\n\nThis notebook explains how different surrogate models from scikit-learn can be used as surrogates in spotPython optimization runs.\n\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-branin-function-with-spotpythons-internal-kriging-surrogate",
    "href": "04_spot_sklearn_surrogate.html#example-branin-function-with-spotpythons-internal-kriging-surrogate",
    "title": "5  Sequential Parameter Optimization",
    "section": "5.2 1 Example: Branin Function with spotPython’s Internal Kriging Surrogate",
    "text": "5.2 1 Example: Branin Function with spotPython’s Internal Kriging Surrogate\n\n5.2.1 The Objective Function Branin\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula.\nHere we will use the Branin function:\n  y = a * (x2 - b * x1**2 + c * x1 - r) ** 2 + s * (1 - t) * np.cos(x1) + s,\n  where values of a, b, c, r, s and t are: a = 1, b = 5.1 / (4*pi**2),\n  c = 5 / pi, r = 6, s = 10 and t = 1 / (8*pi).\nIt has three global minima:\n  f(x) = 0.397887 at (-pi, 12.275), (pi, 2.275), and (9.42478, 2.475).\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-5,-0])\nupper = np.array([10,15])\n\n\nfun = analytical().fun_branin\n\n\n\n5.2.2 Running the surrogate model based optimizer Spot:\n\nspot_2 = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   max_time = inf,\n                   seed=123,\n                   design_control={\"init_size\": 10})\n\n\nspot_2.run()\n\n&lt;spotPython.spot.spot.Spot at 0x10605d000&gt;\n\n\n\n\n5.2.3 Print the Results\n\nspot_2.print_results()\n\nmin y: 0.3982295132785083\nx0: 3.135528626303215\nx1: 2.2926027772585886\n\n\n[['x0', 3.135528626303215], ['x1', 2.2926027772585886]]\n\n\n\n\n5.2.4 Show the Progress and the Surrogate\n\nspot_2.plot_progress(log_y=True)\n\n\n\n\n\nspot_2.surrogate.plot()"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-using-surrogates-from-scikit-learn",
    "href": "04_spot_sklearn_surrogate.html#example-using-surrogates-from-scikit-learn",
    "title": "5  Sequential Parameter Optimization",
    "section": "5.3 2 Example: Using Surrogates From scikit-learn",
    "text": "5.3 2 Example: Using Surrogates From scikit-learn\n\nDefault is the spotPython (i.e., the internal) kriging surrogate.\nIt can be called explicitely and passed to Spot.\n\n\nfrom spotPython.build.kriging import Kriging\nS_0 = Kriging(name='kriging', seed=123)\n\n\nAlternatively, models from scikit-learn can be selected, e.g., Gaussian Process, RBFs, Regression Trees, etc.\n\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nHere are some additional models that might be useful later:\n\n\nS_Tree = DecisionTreeRegressor(random_state=0)\nS_LM = linear_model.LinearRegression()\nS_Ridge = linear_model.Ridge()\nS_RF = RandomForestRegressor(max_depth=2, random_state=0)\n\n\n5.3.1 GaussianProcessRegressor as a Surrogate\n\nTo use a Gaussian Process model from sklearn, that is similar to spotPython’s Kriging, we can proceed as follows:\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nThe scikit-learn GP model S_GP is selected for Spot as follows:\nsurrogate = S_GP\nWe can check the kind of surogate model with the command isinstance:\n\n\nisinstance(S_GP, GaussianProcessRegressor)\n\nTrue\n\n\n\nisinstance(S_0, Kriging)\n\nTrue\n\n\n\nSimilar to the Spot run with the internal Kriging model, we can call the run with the scikit-learn surrogate:\n\n\nfun = analytical(seed=123).fun_branin\nspot_2_GP = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   seed=123,\n                   design_control={\"init_size\": 10},\n                   surrogate = S_GP)\nspot_2_GP.run()\n\n&lt;spotPython.spot.spot.Spot at 0x28df9cac0&gt;\n\n\n\nspot_2_GP.plot_progress()\n\n\n\n\n\nspot_2_GP.print_results()\n\nmin y: 0.39818416017212854\nx0: 3.1492489685308644\nx1: 2.2729571758527487\n\n\n[['x0', 3.1492489685308644], ['x1', 2.2729571758527487]]"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-sklearn-model-gaussianprocess",
    "href": "04_spot_sklearn_surrogate.html#example-sklearn-model-gaussianprocess",
    "title": "5  Sequential Parameter Optimization",
    "section": "6.1 4 Example: Sklearn Model GaussianProcess",
    "text": "6.1 4 Example: Sklearn Model GaussianProcess\n\nThis example visualizes the search process on the GaussianProcessRegression surrogate from sklearn.\nTherefore surrogate = S_GP is added to the argument list.\n\n\nfun = analytical(seed=123).fun_sphere\nspot_1_GP = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 10,\n                   max_time = inf,\n                   seed=123,\n                   show_models= True,\n                   design_control={\"init_size\": 3},\n                   surrogate = S_GP)\nspot_1_GP.run()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x17ff44250&gt;\n\n\n\nspot_1_GP.print_results()\n\nmin y: 3.4820096247785327e-09\nx0: -5.900855552187778e-05\n\n\n[['x0', -5.900855552187778e-05]]\n\n\n\nspot_1_GP.plot_progress(log_y=True)\n\n\n\n\n\nspot_1_GP.plot_model()"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#exercise-1",
    "href": "04_spot_sklearn_surrogate.html#exercise-1",
    "title": "5  Sequential Parameter Optimization",
    "section": "7.1 Exercise 1",
    "text": "7.1 Exercise 1\n\nEach team member should choose one of the following surrogates and repeat the experiments from Example 2 and Example 4.\nPlease add your name to the section title!\n\n\n7.1.1 1. DecisionTreeRegressor\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n7.1.2 2. RandomForestRegressor\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n7.1.3 3.linear_model.LinearRegression\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n7.1.4 4. linear_model.Ridge\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization."
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#exercise-2",
    "href": "04_spot_sklearn_surrogate.html#exercise-2",
    "title": "5  Sequential Parameter Optimization",
    "section": "7.2 Exercise 2",
    "text": "7.2 Exercise 2\n\n(All group members): Compare the performance of the 5 different surrogates on both objective functions:\n\nspotPython’s internal Kriging\nDecisionTreeRegressor\nRandomForestRegressor\nlinear_model.LinearRegression\nlinear_model.Ridge"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#solutions",
    "href": "04_spot_sklearn_surrogate.html#solutions",
    "title": "5  Sequential Parameter Optimization",
    "section": "7.3 Solutions",
    "text": "7.3 Solutions\n\n7.3.1 1. DecisionTreeRegressor\n\n7.3.1.1 1.1. Branin\n\n\n7.3.1.2 1.2. Sphere\n\n\n\n7.3.2 2. RandomForestRegressor\n\n7.3.2.1 2.1 Branin\n\n\n7.3.2.2 2.2 Sphere\n\n\n\n7.3.3 3. linear_model.LinearRegression\n\n7.3.3.1 3.1 Branin\n\n\n7.3.3.2 3.2 Sphere\n\n\n\n7.3.4 4. linear_model.Ridge\n\n7.3.4.1 4.1 Branin\n\n\n7.3.4.2 4.2 Sphere"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html",
    "href": "05_spot_sklearn_optimization.html",
    "title": "6  Sequential Parameter Optimization",
    "section": "",
    "text": "7 Exercises"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#using-scipy-optimizers",
    "href": "05_spot_sklearn_optimization.html#using-scipy-optimizers",
    "title": "6  Sequential Parameter Optimization",
    "section": "6.1 Using scipy Optimizers",
    "text": "6.1 Using scipy Optimizers\n\nThis notebook describes how different optimizers form the scipy optimize package can be used on the surrogate.\nThe optimization algorithms are available from https://docs.scipy.org/doc/scipy/reference/optimize.html\n\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nimport matplotlib.pyplot as plt\n\n\n6.1.1 The Objective Function Branin\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula.\nHere we will use the Branin function. The 2-dim Branin function is\n\\[y = a * (x2 - b * x1**2 + c * x1 - r) ** 2 + s * (1 - t) * cos(x1) + s,\\] where values of a, b, c, r, s and t are: \\(a = 1, b = 5.1 / (4*pi**2), c = 5 / pi, r = 6, s = 10\\) and \\(t = 1 / (8*pi)\\).\nIt has three global minima:\n\\(f(x) = 0.397887\\) at \\((-\\pi, 12.275)\\), \\((\\pi, 2.275)\\), and \\((9.42478, 2.475)\\).\nInput Domain: This function is usually evaluated on the square x1 in [-5, 10] x x2 in [0, 15].\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-5,-0])\nupper = np.array([10,15])\n\n\nfun = analytical(seed=123).fun_branin"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#the-optimizer",
    "href": "05_spot_sklearn_optimization.html#the-optimizer",
    "title": "6  Sequential Parameter Optimization",
    "section": "6.2 The Optimizer",
    "text": "6.2 The Optimizer\n\nDifferential Evalution from the scikit.optimize package, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution is the default optimizer for the search on the surrogate.\nOther optimiers that are available in spotPython:\n\ndual_annealing\ndirect\nshgo\nbasinhopping, see https://docs.scipy.org/doc/scipy/reference/optimize.html#global-optimization.\n\nThese can be selected as follows:\nsurrogate_control = \"model_optimizer\": differential_evolution\nWe will use differential_evolution.\nThe optimizer can use 1000 evaluations. This value will be passed to the differential_evolution method, which has the argument maxiter (int). It defines the maximum number of generations over which the entire differential evolution population is evolved, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution\n\n\nspot_de = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   max_time = inf,\n                   seed=125,\n                   noise=False,\n                   show_models= False,\n                   design_control={\"init_size\": 10},\n                   surrogate_control={\"n_theta\": 2,\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      })\nspot_de.run()\n\n&lt;spotPython.spot.spot.Spot at 0x14fbf7d60&gt;"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#print-the-results",
    "href": "05_spot_sklearn_optimization.html#print-the-results",
    "title": "6  Sequential Parameter Optimization",
    "section": "6.3 Print the Results",
    "text": "6.3 Print the Results\n\nspot_de.print_results()\n\nmin y: 0.39951958110619046\nx0: -3.1570201165683587\nx1: 12.289980569430284\n\n\n[['x0', -3.1570201165683587], ['x1', 12.289980569430284]]"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#show-the-progress",
    "href": "05_spot_sklearn_optimization.html#show-the-progress",
    "title": "6  Sequential Parameter Optimization",
    "section": "6.4 Show the Progress",
    "text": "6.4 Show the Progress\n\nspot_de.plot_progress(log_y=True)\n\n\n\n\n\nspot_de.surrogate.plot()"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#exercise-1",
    "href": "05_spot_sklearn_optimization.html#exercise-1",
    "title": "6  Sequential Parameter Optimization",
    "section": "7.1 Exercise 1",
    "text": "7.1 Exercise 1\n\nEach team member should choose one of the following optimization algorithms.\nPlease add your name to the section title!\n\n\n7.1.1 1. dual_annealing\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n7.1.2 2. direct\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n7.1.3 3. shgo\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n7.1.4 4. basinhopping\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#exercise-2",
    "href": "05_spot_sklearn_optimization.html#exercise-2",
    "title": "6  Sequential Parameter Optimization",
    "section": "7.2 Exercise 2",
    "text": "7.2 Exercise 2\n(All group members): * Compare the performance and run time of the 5 different optimizers: * differential_evolution * dual_annealing * direct * shgo * basinhopping. * The Branin function has three global minima: * \\(f(x) = 0.397887\\) at * \\((-\\pi, 12.275)\\), * \\((\\pi, 2.275)\\), and * \\((9.42478, 2.475)\\). * Which optima are found by the optimizers? Does the seed change this behavior?"
  },
  {
    "objectID": "06_spot_gaussian.html",
    "href": "06_spot_gaussian.html",
    "title": "7  Sequential Parameter Optimization",
    "section": "",
    "text": "8 Exercises"
  },
  {
    "objectID": "06_spot_gaussian.html#gaussian-process-models",
    "href": "06_spot_gaussian.html#gaussian-process-models",
    "title": "7  Sequential Parameter Optimization",
    "section": "7.1 Gaussian Process Models",
    "text": "7.1 Gaussian Process Models\n\nThis notebook analyzes differences between\n\nthe Kriging implementation in spotPython and\nthe GaussianProcessRegressor in scikit-learn.\n\n\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.spot import spot\nfrom spotPython.build.kriging import Kriging\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\nimport math as m\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF"
  },
  {
    "objectID": "06_spot_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "href": "06_spot_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "title": "7  Sequential Parameter Optimization",
    "section": "7.2 1 Gaussian Processes Regression: Basic Introductory scikit-learn Example",
    "text": "7.2 1 Gaussian Processes Regression: Basic Introductory scikit-learn Example\n\nThis is the example from scikit-learn: https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html\nAfter fitting our model, we see that the hyperparameters of the kernel have been optimized.\nNow, we will use our kernel to compute the mean prediction of the full dataset and plot the 95% confidence interval.\n\n\n7.2.1 Train and Test Data\n\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\nrng = np.random.RandomState(1)\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\n\n\n7.2.2 Building the Surrogate With Sklearn\n\nThe model building with sklearn consisits of three steps:\n\nInstantiating the model, then\nfitting the model (using fit), and\nmaking predictions (using predict)\n\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\ngaussian_process = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\ngaussian_process.fit(X_train, y_train)\nmean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)\n\n\n\n7.2.3 Plotting the SklearnModel\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"sk-learn Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n7.2.4 The spotPython Version\n\nThe spotPython version is very similar:\n\nInstantiating the model, then\nfitting the model and\nmaking predictions (using predict).\n\n\n\nS = Kriging(name='kriging',  seed=123, log_level=50, cod_type=\"norm\")\nS.fit(X_train, y_train)\nS_mean_prediction, S_std_prediction, S_ei = S.predict(X, return_val=\"all\")\n\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    S_mean_prediction - 1.96 * S_std_prediction,\n    S_mean_prediction + 1.96 * S_std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"spotPython Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n7.2.5 Visualizing the Differences Between the spotPython and the sklearn Model Fits\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"spotPython Mean prediction\")\nplt.plot(X, mean_prediction, label=\"Sklearn Mean Prediction\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Comparing Mean Predictions\")"
  },
  {
    "objectID": "06_spot_gaussian.html#exercise-1",
    "href": "06_spot_gaussian.html#exercise-1",
    "title": "7  Sequential Parameter Optimization",
    "section": "8.1 Exercise 1",
    "text": "8.1 Exercise 1\n\nEach team member should choose one of the following functions and repeat the experiments from above.\nPlease add your name to the section title!\n\n\n8.1.1 1. Schonlau Example Function\n\nThe Schonlau Example Function is based on sample points only (there is no analytical function description available):\n\n\nX = np.linspace(start=0, stop=13, num=1_000).reshape(-1, 1)\nX_train = np.array([1., 2., 3., 4., 12.]).reshape(-1,1)\ny_train = np.array([0., -1.75, -2, -0.5, 5.])\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Since there is no analytical function available, you might be interested in adding some points and describe the effects.\n\n\n\n8.1.2 2. Forrester Example Function\n\nThe Forrester Example Function is defined as follows:\nf(x) = (6x- 2)^2 sin(12x-4) for x in [0,1].\nData points are generated as follows:\n\n\nX = np.linspace(start=-0.5, stop=1.5, num=1_000).reshape(-1, 1)\nX_train = np.array([0.0, 0.175, 0.225, 0.3, 0.35, 0.375, 0.5,1]).reshape(-1,1)\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 0.1,\n               \"seed\": 123}\ny = fun(X, fun_control=fun_control)\ny_train = fun(X_train, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.2, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.2}\n\n\n\n8.1.3 3.fun_runge Function (1-dim)\n\nThe Runge function is defined as follows:\nf(x) = 1/ (1 + sum(x_i))^2\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.5}\n\n\n\n8.1.4 4. fun_cubed (1-dim)\n\nThe Cubed function is defined as follows:\nnp.sum(X[i]** 3)\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.05}"
  },
  {
    "objectID": "06_spot_gaussian.html#exercise-2",
    "href": "06_spot_gaussian.html#exercise-2",
    "title": "7  Sequential Parameter Optimization",
    "section": "8.2 Exercise 2",
    "text": "8.2 Exercise 2\n\nHow does the behavior of the spotPython fit changes when the argument noise is set to True, i.e.,\nS = Kriging(name='kriging',  seed=123, n_theta=1, noise=True)\n\nis used?"
  },
  {
    "objectID": "07_spot_ei.html",
    "href": "07_spot_ei.html",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "",
    "text": "9 Non-isotropic Kriging\nspot_2_ei_noniso = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]),\n                   fun_evals = 20,\n                   fun_repeats = 1,\n                   max_time = inf,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type=[\"num\"],\n                   infill_criterion = \"ei\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models=True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": 10,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": 2,\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      })\nspot_2_ei_noniso.run()\n\n&lt;spotPython.spot.spot.Spot at 0x1527aa380&gt;\nspot_2_ei_noniso.plot_progress(log_y=True)\nspot_2_ei_noniso.print_results()\n\nmin y: 1.8779971830281702e-07\nx0: -0.0002783721390529846\nx1: 0.0003321274913371111\n\n\n[['x0', -0.0002783721390529846], ['x1', 0.0003321274913371111]]\nspot_2_ei_noniso.surrogate.plot()\nThe spot loop consists of the following steps:\nThe spot loop is implemented in R as follows:\nimport numpy as np\nfrom spotPython.spot import spot\nfrom spotPython.fun.objectivefunctions import analytical\n\nfun_sphere = analytical().fun_sphere\nspot_1 = spot.Spot(\n    fun=fun_sphere,\n    lower=np.array([-1, -1]),\n    upper=np.array([1, 1]),\n    n_points = 2\n)\n\n# (S-2) Initial Design:\nspot_1.X = spot_1.design.scipy_lhd(\n    spot_1.design_control[\"init_size\"], lower=spot_1.lower, upper=spot_1.upper\n)\nprint(spot_1.X)\n\n# (S-3): Eval initial design:\nspot_1.y = spot_1.fun(spot_1.X)\nprint(spot_1.y)\n\nspot_1.surrogate.fit(spot_1.X, spot_1.y)\nX0 = spot_1.suggest_new_X()\nprint(X0)\nassert X0.size == spot_1.n_points * spot_1.k\n\n[[ 0.86352963  0.7892358 ]\n [-0.24407197 -0.83687436]\n [ 0.36481882  0.8375811 ]\n [ 0.415331    0.54468512]\n [-0.56395091 -0.77797854]\n [-0.90259409 -0.04899292]\n [-0.16484832  0.35724741]\n [ 0.05170659  0.07401196]\n [-0.78548145 -0.44638164]\n [ 0.64017497 -0.30363301]]\n[1.36857656 0.75992983 0.83463487 0.46918172 0.92329124 0.8170764\n 0.15480068 0.00815134 0.81623768 0.502017  ]\n[[0.00160553 0.00428429]\n [0.00160553 0.00428429]]\nX_train0 = np.array([1, 2, 3, 4, 12]).reshape(-1,1)\nX_train = np.linspace(start=0, stop=10, num=5).reshape(-1, 1)\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nX_train = np.array([1., 2., 3., 4., 12.]).reshape(-1,1)\ny_train = np.array([0., -1.75, -2, -0.5, 5.])\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nX = np.linspace(start=0, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nif True:\n    plt.fill_between(\n        X.ravel(),\n        mean_prediction - 2 * std_prediction,\n        mean_prediction + 2 * std_prediction,\n        alpha=0.5,\n        label=r\"95% confidence interval\",\n    )\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\n# plt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, -ei, label=\"Expected Improvement\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\nS.log\n\n{'negLnLike': array([1.20788205]),\n 'theta': array([1.09276]),\n 'p': array([2.]),\n 'Lambda': array([None], dtype=object)}\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\n# exact x locations are unknown:\nX_train = np.array([0.0, 0.175, 0.225, 0.3, 0.35, 0.375, 0.5,1]).reshape(-1,1)\n\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 1.0,\n               \"seed\": 123}\ny_train = fun(X_train, fun_control=fun_control)\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nX = np.linspace(start=0, stop=1, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nif True:\n    plt.fill_between(\n        X.ravel(),\n        mean_prediction - 2 * std_prediction,\n        mean_prediction + 2 * std_prediction,\n        alpha=0.5,\n        label=r\"95% confidence interval\",\n    )\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\n# plt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, -ei, label=\"Expected Improvement\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 2,\n               \"seed\": 125}\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[-4.61635371 11.44873209 -0.19988024 91.92791676 68.05926244 12.02926818\n 16.2470957   9.12729929 38.4987029  58.38469104]\nS.log\n\n{'negLnLike': array([24.69806131]),\n 'theta': array([1.31023943]),\n 'p': array([2.]),\n 'Lambda': array([None], dtype=object)}\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\nS.log\n\n{'negLnLike': array([22.14095646]),\n 'theta': array([-0.32527397]),\n 'p': array([2.]),\n 'Lambda': array([9.08815007e-05])}\n[\"num\"] * 3\n\n['num', 'num', 'num']\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\nimport numpy as np\ngen = spacefilling(2)\nn = 30\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin_factor\n#fun = analytical(sigma=0).fun_sphere\n\nX0 = gen.scipy_lhd(n, lower=lower, upper = upper)\nX1 = np.random.randint(low=1, high=3, size=(n,))\nX = np.c_[X0, X1]\ny = fun(X)\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=3, noise=False, var_type=[\"num\", \"num\", \"num\"])\nS.fit(X, y)\nSf = Kriging(name='kriging',  seed=123, log_level=50, n_theta=3, noise=False, var_type=[\"num\", \"num\", \"factor\"])\nSf.fit(X, y)\nn = 50\nX0 = gen.scipy_lhd(n, lower=lower, upper = upper)\nX1 = np.random.randint(low=1, high=3, size=(n,))\nX = np.c_[X0, X1]\ny = fun(X)\ns=np.sum(np.abs(S.predict(X)[0] - y))\nsf=np.sum(np.abs(Sf.predict(X)[0] - y))\nsf - s\n\n-21.199244545556667\nvars(S)\n\n{'name': 'kriging',\n 'seed': 123,\n 'rng': Generator(PCG64) at 0x16A99A340,\n 'log': {'negLnLike': array([74.55637633]),\n  'theta': array([ 0.75249175, -0.62794888, -3.        ]),\n  'p': array([2.]),\n  'Lambda': array([None], dtype=object)},\n 'verbosity': 50,\n 'noise': False,\n 'var_type': ['num', 'num', 'num'],\n 'cod_type': 'norm',\n 'use_cod_y': False,\n 'log_level': 50,\n 'sigma': 0,\n 'eps': 1.4901161193847656e-08,\n 'min_theta': -3,\n 'max_theta': 2,\n 'min_p': 1,\n 'max_p': 2,\n 'min_Lambda': 1e-09,\n 'max_Lambda': 1.0,\n 'n_theta': 3,\n 'n_p': 1,\n 'optim_p': False,\n 'cnd_Psi': 45719436.226327546,\n 'inf_Psi': False,\n 'model_optimizer': &lt;function scipy.optimize._differentialevolution.differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=(), x0=None, *, integrality=None, vectorized=False)&gt;,\n 'model_fun_evals': 100,\n 'nat_X': array([[-2.84117593,  5.97308949,  1.        ],\n        [-3.61017994,  6.90781409,  1.        ],\n        [ 9.91204705,  5.09395275,  1.        ],\n        [-4.4616725 ,  1.3617128 ,  1.        ],\n        [-2.40987728,  8.05505365,  2.        ],\n        [ 5.24351477, 10.3775177 ,  2.        ],\n        [ 2.5878792 , 11.89311852,  2.        ],\n        [ 8.12926647,  3.6850299 ,  1.        ],\n        [-1.96370363,  0.38404591,  1.        ],\n        [ 0.10043744,  1.74091748,  2.        ],\n        [ 1.38422219,  7.917048  ,  2.        ],\n        [ 9.25110552, 13.20863768,  1.        ],\n        [-1.09216899,  4.49255254,  1.        ],\n        [ 3.26443339, 14.63587834,  2.        ],\n        [ 4.54069975,  9.187233  ,  1.        ],\n        [ 7.04143871,  8.56765487,  1.        ],\n        [-0.10907144, 14.06693628,  1.        ],\n        [ 1.63462403,  7.36106735,  2.        ],\n        [ 4.10147822, 12.56738914,  1.        ],\n        [ 0.85028105,  2.73647896,  2.        ],\n        [ 5.9642566 , 10.70838079,  1.        ],\n        [ 6.3810468 ,  4.61751818,  2.        ],\n        [ 2.41318418, 12.34362887,  1.        ],\n        [-3.00723724,  0.98372404,  1.        ],\n        [ 8.75164908,  6.26584373,  2.        ],\n        [ 6.93615484, 11.37121875,  2.        ],\n        [-0.50159055,  2.30946613,  1.        ],\n        [-4.78793654,  9.78635061,  2.        ],\n        [ 7.58244883, 13.69175437,  1.        ],\n        [ 3.86695804,  3.09448894,  2.        ]]),\n 'nat_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'n': 30,\n 'k': 3,\n 'cod_X': array([[0.13243284, 0.39216316, 0.        ],\n        [0.08011959, 0.45774943, 0.        ],\n        [1.        , 0.33047728, 0.        ],\n        [0.02219486, 0.06859938, 0.        ],\n        [0.16177292, 0.53824712, 1.        ],\n        [0.68241242, 0.7012061 , 1.        ],\n        [0.50175673, 0.80755037, 1.        ],\n        [0.87872227, 0.23161822, 0.        ],\n        [0.1921249 , 0.        , 0.        ],\n        [0.33254282, 0.09520682, 1.        ],\n        [0.41987521, 0.52856376, 1.        ],\n        [0.95503794, 0.89985564, 0.        ],\n        [0.25141304, 0.28827918, 0.        ],\n        [0.54778088, 1.        , 1.        ],\n        [0.63460182, 0.61768809, 0.        ],\n        [0.8047203 , 0.57421451, 0.        ],\n        [0.3182905 , 0.96007938, 0.        ],\n        [0.43690937, 0.48955259, 1.        ],\n        [0.60472277, 0.85486153, 0.        ],\n        [0.38355265, 0.1650618 , 1.        ],\n        [0.73144253, 0.72442157, 0.        ],\n        [0.75979563, 0.29704758, 1.        ],\n        [0.4898727 , 0.83916107, 0.        ],\n        [0.12113614, 0.04207727, 0.        ],\n        [0.92106127, 0.41270467, 1.        ],\n        [0.79755813, 0.77093054, 1.        ],\n        [0.29158849, 0.13509984, 0.        ],\n        [0.        , 0.65972602, 1.        ],\n        [0.84152375, 0.93375421, 0.        ],\n        [0.588769  , 0.19018207, 1.        ]]),\n 'cod_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'num_mask': array([ True,  True,  True]),\n 'factor_mask': array([False, False, False]),\n 'int_mask': array([False, False, False]),\n 'ordered_mask': array([ True,  True,  True]),\n 'nat_range_X': [[-4.787936542018484, 9.912047049457485],\n  [0.3840459056967906, 14.63587833590837],\n  [1.0, 2.0]],\n 'nat_range_y': [-5.449830806521344, 222.4188410638947],\n 'nat_mean_X': array([2.50508374, 7.5128501 , 1.43333333]),\n 'nat_std_X': array([4.3289971 , 4.28784459, 0.49553562]),\n 'nat_mean_y': 71.56762485893886,\n 'nat_std_y': 56.27119875010559,\n 'mean_cod_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'theta': array([ 0.75249175, -0.62794888, -3.        ]),\n 'x0_theta': array([0.1, 0.1, 0.1]),\n 'p': array([2.]),\n 'pen_val': 10241.8109702054,\n 'negLnLike': 74.55637632889969,\n 'gen': &lt;spotPython.design.spacefilling.spacefilling at 0x15218ee90&gt;,\n 'LnDetPsi': -191.3489538910863,\n 'Psi': array([[1.00000001, 0.98364406, 0.01415283, 0.91083821, 0.98916403,\n         0.17653457, 0.44348639, 0.04259407, 0.94518431, 0.78016514,\n         0.62332984, 0.02048934, 0.92071333, 0.34516915, 0.23735084,\n         0.07699252, 0.76236203, 0.59004437, 0.26928402, 0.69086765,\n         0.1280463 , 0.10761966, 0.46317019, 0.97084478, 0.02964032,\n         0.07911474, 0.85314312, 0.88953605, 0.05431994, 0.304714  ],\n        [0.98364406, 1.00000001, 0.00831566, 0.94682102, 0.96056392,\n         0.12661193, 0.3551231 , 0.0268067 , 0.88665002, 0.6754817 ,\n         0.5194168 , 0.01258276, 0.84137904, 0.27057336, 0.17466339,\n         0.05116317, 0.68368435, 0.48616275, 0.2031808 , 0.58163447,\n         0.08927361, 0.072816  , 0.37386728, 0.95102859, 0.01829474,\n         0.05311857, 0.75772063, 0.95416976, 0.03571365, 0.22737673],\n        [0.01415283, 0.00831566, 1.00000001, 0.00441101, 0.0185915 ,\n         0.54671745, 0.23255437, 0.91806363, 0.02430603, 0.0793666 ,\n         0.14753915, 0.91595196, 0.04201143, 0.28274861, 0.46090471,\n         0.79479542, 0.065759  , 0.16525903, 0.38734204, 0.11570877,\n         0.64116748, 0.72065798, 0.21594177, 0.01242411, 0.96287137,\n         0.75693196, 0.05799947, 0.00340571, 0.79631252, 0.38209404],\n        [0.91083821, 0.94682102, 0.00441101, 1.00000001, 0.84947471,\n         0.07726331, 0.2392314 , 0.0156771 , 0.84838083, 0.57931605,\n         0.3885672 , 0.00619273, 0.73452864, 0.17072863, 0.11167464,\n         0.02949597, 0.50507788, 0.36223501, 0.12683982, 0.47629447,\n         0.05253172, 0.04548641, 0.25236074, 0.94598161, 0.01006662,\n         0.02967758, 0.66265725, 0.91751308, 0.01881667, 0.16202262],\n        [0.98916403, 0.96056392, 0.0185915 , 0.84947471, 1.00000001,\n         0.2145229 , 0.51128577, 0.05338083, 0.92825714, 0.8096388 ,\n         0.6860592 , 0.02757622, 0.94066979, 0.40944973, 0.28169484,\n         0.09639562, 0.83404751, 0.65135488, 0.32164757, 0.7327226 ,\n         0.15808951, 0.13049997, 0.53197012, 0.93395769, 0.038221  ,\n         0.10036482, 0.87407238, 0.85942649, 0.07056964, 0.34655055],\n        [0.17653457, 0.12661193, 0.54671745, 0.07726331, 0.2145229 ,\n         1.00000001, 0.829238  , 0.76269464, 0.22846928, 0.45895114,\n         0.67243587, 0.65008134, 0.33561895, 0.88378421, 0.98454944,\n         0.91447577, 0.46456523, 0.70367805, 0.96011967, 0.56390958,\n         0.98538471, 0.93021407, 0.80641993, 0.15181834, 0.71054802,\n         0.92669363, 0.39048572, 0.07177477, 0.85477148, 0.89484545],\n        [0.44348639, 0.3551231 , 0.23255437, 0.2392314 , 0.51128577,\n         0.829238  , 1.00000001, 0.41361169, 0.49816249, 0.75468053,\n         0.94530096, 0.31190297, 0.65772534, 0.97950928, 0.89645929,\n         0.58687145, 0.82131208, 0.95351397, 0.94036263, 0.83840879,\n         0.74007706, 0.64534701, 0.99796795, 0.38351633, 0.35661559,\n         0.60945689, 0.6995453 , 0.23953816, 0.51806076, 0.87582204],\n        [0.04259407, 0.0268067 , 0.91806363, 0.0156771 , 0.05338083,\n         0.76269464, 0.41361169, 1.00000001, 0.06864164, 0.18404649,\n         0.29744145, 0.87099878, 0.10791654, 0.46790341, 0.68924354,\n         0.94306729, 0.1493635 , 0.32606169, 0.59684398, 0.24937478,\n         0.83536923, 0.92127107, 0.38980368, 0.0385995 , 0.98131464,\n         0.89873724, 0.14200604, 0.01213955, 0.88343067, 0.62070372],\n        [0.94518431, 0.88665002, 0.02430603, 0.84838083, 0.92825714,\n         0.22846928, 0.49816249, 0.06864164, 1.00000001, 0.89167742,\n         0.69755844, 0.03072791, 0.96131377, 0.38599238, 0.30204345,\n         0.11078998, 0.735555  , 0.67277877, 0.32143954, 0.80680723,\n         0.17056114, 0.15812728, 0.51310986, 0.97149542, 0.04753445,\n         0.10925135, 0.94152771, 0.73177768, 0.07498215, 0.4068455 ],\n        [0.78016514, 0.6754817 , 0.0793666 , 0.57931605, 0.8096388 ,\n         0.45895114, 0.75468053, 0.18404649, 0.89167742, 1.00000001,\n         0.91633902, 0.09583668, 0.95408125, 0.63455188, 0.55915548,\n         0.26820452, 0.83666767, 0.90643847, 0.57354986, 0.98425954,\n         0.37001872, 0.35273864, 0.76234558, 0.77535293, 0.13770504,\n         0.26433336, 0.98919775, 0.49633618, 0.19557519, 0.68836478],\n        [0.62332984, 0.5194168 , 0.14753915, 0.3885672 , 0.6860592 ,\n         0.67243587, 0.94530096, 0.29744145, 0.69755844, 0.91633902,\n         1.00000001, 0.19142145, 0.83936735, 0.86513022, 0.7682467 ,\n         0.4320807 , 0.90192673, 0.99800245, 0.80305902, 0.96215125,\n         0.57174373, 0.51369504, 0.94986702, 0.57035706, 0.24079238,\n         0.44016773, 0.87761835, 0.36746137, 0.35162333, 0.82836577],\n        [0.02048934, 0.01258276, 0.91595196, 0.00619273, 0.02757622,\n         0.65008134, 0.31190297, 0.87099878, 0.03072791, 0.09583668,\n         0.19142145, 1.00000001, 0.05567638, 0.39007407, 0.54909526,\n         0.85832649, 0.10086513, 0.2103497 , 0.49929558, 0.13871719,\n         0.74825704, 0.73920297, 0.29385882, 0.01646893, 0.93854471,\n         0.86486882, 0.07227878, 0.00566644, 0.92946334, 0.41546328],\n        [0.92071333, 0.84137904, 0.04201143, 0.73452864, 0.94066979,\n         0.33561895, 0.65772534, 0.10791654, 0.96131377, 0.95408125,\n         0.83936735, 0.05567638, 1.00000001, 0.53951938, 0.42485174,\n         0.17364108, 0.87669555, 0.81452478, 0.45767004, 0.90182871,\n         0.25974559, 0.23159431, 0.67497379, 0.89559495, 0.07879889,\n         0.17502269, 0.98545156, 0.67638697, 0.12648338, 0.52364342],\n        [0.34516915, 0.27057336, 0.28274861, 0.17072863, 0.40944973,\n         0.88378421, 0.97950928, 0.46790341, 0.38599238, 0.63455188,\n         0.86513022, 0.39007407, 0.53951938, 1.00000001, 0.92491031,\n         0.65896664, 0.74138056, 0.87731157, 0.97599317, 0.72852289,\n         0.81085556, 0.69030972, 0.97427776, 0.28747361, 0.41924321,\n         0.69404737, 0.577871  , 0.17828643, 0.61260124, 0.84877143],\n        [0.23735084, 0.17466339, 0.46090471, 0.11167464, 0.28169484,\n         0.98454944, 0.89645929, 0.68924354, 0.30204345, 0.55915548,\n         0.7682467 , 0.54909526, 0.42485174, 0.92491031, 1.00000001,\n         0.84863608, 0.55239725, 0.79779176, 0.98186816, 0.66650176,\n         0.94580042, 0.89238212, 0.87807644, 0.2082189 , 0.62188281,\n         0.85494453, 0.48660579, 0.1023758 , 0.76667635, 0.94560811],\n        [0.07699252, 0.05116317, 0.79479542, 0.02949597, 0.09639562,\n         0.91447577, 0.58687145, 0.94306729, 0.11078998, 0.26820452,\n         0.4320807 , 0.85832649, 0.17364108, 0.65896664, 0.84863608,\n         1.00000001, 0.25326903, 0.46401963, 0.78287955, 0.35216252,\n         0.96494562, 0.96995209, 0.56147698, 0.06656573, 0.91971074,\n         0.98964936, 0.21554099, 0.02559761, 0.96260924, 0.74119374],\n        [0.76236203, 0.68368435, 0.065759  , 0.50507788, 0.83404751,\n         0.46456523, 0.82131208, 0.1493635 , 0.735555  , 0.83666767,\n         0.90192673, 0.10086513, 0.87669555, 0.74138056, 0.55239725,\n         0.25326903, 1.00000001, 0.87570587, 0.62711434, 0.8403323 ,\n         0.37587839, 0.29909206, 0.84370513, 0.65814579, 0.11925446,\n         0.27021354, 0.84845858, 0.55143714, 0.2125537 , 0.57442922],\n        [0.59004437, 0.48616275, 0.16525903, 0.36223501, 0.65135488,\n         0.70367805, 0.95351397, 0.32606169, 0.67277877, 0.90643847,\n         0.99800245, 0.2103497 , 0.81452478, 0.87731157, 0.79779176,\n         0.46401963, 0.87570587, 1.00000001, 0.82554952, 0.95992331,\n         0.60372915, 0.54970485, 0.95537311, 0.54220345, 0.26523983,\n         0.47034915, 0.86068129, 0.33741232, 0.37779782, 0.85938458],\n        [0.26928402, 0.2031808 , 0.38734204, 0.12683982, 0.32164757,\n         0.96011967, 0.94036263, 0.59684398, 0.32143954, 0.57354986,\n         0.80305902, 0.49929558, 0.45767004, 0.97599317, 0.98186816,\n         0.78287955, 0.62711434, 0.82554952, 1.00000001, 0.67723908,\n         0.90953003, 0.81034503, 0.92805832, 0.22804026, 0.54171217,\n         0.80817901, 0.50835006, 0.12515215, 0.72715791, 0.89897724],\n        [0.69086765, 0.58163447, 0.11570877, 0.47629447, 0.7327226 ,\n         0.56390958, 0.83840879, 0.24937478, 0.80680723, 0.98425954,\n         0.96215125, 0.13871719, 0.90182871, 0.72852289, 0.66650176,\n         0.35216252, 0.8403323 , 0.95992331, 0.67723908, 1.00000001,\n         0.46804201, 0.44721   , 0.84201208, 0.67433214, 0.19234122,\n         0.34789288, 0.95213867, 0.41079197, 0.26543091, 0.78793922],\n        [0.1280463 , 0.08927361, 0.64116748, 0.05253172, 0.15808951,\n         0.98538471, 0.74007706, 0.83536923, 0.17056114, 0.37001872,\n         0.57174373, 0.74825704, 0.25974559, 0.81085556, 0.94580042,\n         0.96494562, 0.37587839, 0.60372915, 0.90953003, 0.46804201,\n         1.00000001, 0.95259412, 0.71666353, 0.10901288, 0.79672887,\n         0.97410869, 0.30850067, 0.04841871, 0.92417207, 0.83247576],\n        [0.10761966, 0.072816  , 0.72065798, 0.04548641, 0.13049997,\n         0.93021407, 0.64534701, 0.92127107, 0.15812728, 0.35273864,\n         0.51369504, 0.73920297, 0.23159431, 0.69030972, 0.89238212,\n         0.96995209, 0.29909206, 0.54970485, 0.81034503, 0.44721   ,\n         0.95259412, 1.00000001, 0.61736782, 0.09795755, 0.86050314,\n         0.94086316, 0.28735883, 0.0370311 , 0.87436141, 0.84525093],\n        [0.46317019, 0.37386728, 0.21594177, 0.25236074, 0.53197012,\n         0.80641993, 0.99796795, 0.38980368, 0.51310986, 0.76234558,\n         0.94986702, 0.29385882, 0.67497379, 0.97427776, 0.87807644,\n         0.56147698, 0.84370513, 0.95537311, 0.92805832, 0.84201208,\n         0.71666353, 0.61736782, 1.00000001, 0.39906137, 0.33441378,\n         0.58418938, 0.71239704, 0.25516921, 0.49584528, 0.85597313],\n        [0.97084478, 0.95102859, 0.01242411, 0.94598161, 0.93395769,\n         0.15181834, 0.38351633, 0.0385995 , 0.97149542, 0.77535293,\n         0.57035706, 0.01646893, 0.89559495, 0.28747361, 0.2082189 ,\n         0.06656573, 0.65814579, 0.54220345, 0.22804026, 0.67433214,\n         0.10901288, 0.09795755, 0.39906137, 1.00000001, 0.02592962,\n         0.0662778 , 0.84674062, 0.84042638, 0.04405229, 0.28852516],\n        [0.02964032, 0.01829474, 0.96287137, 0.01006662, 0.038221  ,\n         0.71054802, 0.35661559, 0.98131464, 0.04753445, 0.13770504,\n         0.24079238, 0.93854471, 0.07879889, 0.41924321, 0.62188281,\n         0.91971074, 0.11925446, 0.26523983, 0.54171217, 0.19234122,\n         0.79672887, 0.86050314, 0.33441378, 0.02592962, 1.00000001,\n         0.89003675, 0.10433266, 0.00812779, 0.90418164, 0.52931983],\n        [0.07911474, 0.05311857, 0.75693196, 0.02967758, 0.10036482,\n         0.92669363, 0.60945689, 0.89873724, 0.10925135, 0.26433336,\n         0.44016773, 0.86486882, 0.17502269, 0.69404737, 0.85494453,\n         0.98964936, 0.27021354, 0.47034915, 0.80817901, 0.34789288,\n         0.97410869, 0.94086316, 0.58418938, 0.0662778 , 0.89003675,\n         1.00000001, 0.2134979 , 0.02730891, 0.9819874 , 0.72181296],\n        [0.85314312, 0.75772063, 0.05799947, 0.66265725, 0.87407238,\n         0.39048572, 0.6995453 , 0.14200604, 0.94152771, 0.98919775,\n         0.87761835, 0.07227878, 0.98545156, 0.577871  , 0.48660579,\n         0.21554099, 0.84845858, 0.86068129, 0.50835006, 0.95213867,\n         0.30850067, 0.28735883, 0.71239704, 0.84674062, 0.10433266,\n         0.2134979 , 1.00000001, 0.57885596, 0.15556339, 0.60579656],\n        [0.88953605, 0.95416976, 0.00340571, 0.91751308, 0.85942649,\n         0.07177477, 0.23953816, 0.01213955, 0.73177768, 0.49633618,\n         0.36746137, 0.00566644, 0.67638697, 0.17828643, 0.1023758 ,\n         0.02559761, 0.55143714, 0.33741232, 0.12515215, 0.41079197,\n         0.04841871, 0.0370311 , 0.25516921, 0.84042638, 0.00812779,\n         0.02730891, 0.57885596, 1.00000001, 0.01788328, 0.1336548 ],\n        [0.05431994, 0.03571365, 0.79631252, 0.01881667, 0.07056964,\n         0.85477148, 0.51806076, 0.88343067, 0.07498215, 0.19557519,\n         0.35162333, 0.92946334, 0.12648338, 0.61260124, 0.76667635,\n         0.96260924, 0.2125537 , 0.37779782, 0.72715791, 0.26543091,\n         0.92417207, 0.87436141, 0.49584528, 0.04405229, 0.90418164,\n         0.9819874 , 0.15556339, 0.01788328, 1.00000001, 0.6110695 ],\n        [0.304714  , 0.22737673, 0.38209404, 0.16202262, 0.34655055,\n         0.89484545, 0.87582204, 0.62070372, 0.4068455 , 0.68836478,\n         0.82836577, 0.41546328, 0.52364342, 0.84877143, 0.94560811,\n         0.74119374, 0.57442922, 0.85938458, 0.89897724, 0.78793922,\n         0.83247576, 0.84525093, 0.85597313, 0.28852516, 0.52931983,\n         0.72181296, 0.60579656, 0.1336548 , 0.6110695 , 1.00000001]]),\n 'psi': array([[0.35750447],\n        [0.27296819],\n        [0.33188178],\n        [0.19243722],\n        [0.4071715 ],\n        [0.89165608],\n        [0.93591034],\n        [0.55756626],\n        [0.45357131],\n        [0.73701622],\n        [0.89059683],\n        [0.38314447],\n        [0.58515766],\n        [0.90643461],\n        [0.9514836 ],\n        [0.70137589],\n        [0.66131807],\n        [0.91579362],\n        [0.930952  ],\n        [0.83362751],\n        [0.81723948],\n        [0.79475682],\n        [0.92068942],\n        [0.33063065],\n        [0.4753539 ],\n        [0.69533256],\n        [0.65979115],\n        [0.16752614],\n        [0.5873317 ],\n        [0.98842278]]),\n 'one': array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n 'mu': 366.4154389350868,\n 'U': array([[ 1.00000001e+00,  9.83644055e-01,  1.41528334e-02,\n          9.10838200e-01,  9.89164025e-01,  1.76534573e-01,\n          4.43486388e-01,  4.25940725e-02,  9.45184301e-01,\n          7.80165133e-01,  6.23329833e-01,  2.04893374e-02,\n          9.20713327e-01,  3.45169145e-01,  2.37350836e-01,\n          7.69925160e-02,  7.62362029e-01,  5.90044370e-01,\n          2.69284015e-01,  6.90867648e-01,  1.28046297e-01,\n          1.07619663e-01,  4.63170188e-01,  9.70844776e-01,\n          2.96403200e-02,  7.91147392e-02,  8.53143116e-01,\n          8.89536046e-01,  5.43199357e-02,  3.04714001e-01],\n        [ 0.00000000e+00,  1.80123256e-01, -3.11214068e-02,\n          2.82475701e-01, -6.89605231e-02, -2.61128149e-01,\n         -4.50300809e-01, -8.37798798e-02, -2.39141244e-01,\n         -5.10334382e-01, -5.20298648e-01, -4.20348558e-02,\n         -3.56839807e-01, -3.82794619e-01, -3.26472803e-01,\n         -1.36406950e-01, -3.67573471e-01, -5.23146676e-01,\n         -3.42536651e-01, -5.43702030e-01, -2.03629289e-01,\n         -1.83449057e-01, -4.53729979e-01, -2.18578018e-02,\n         -6.02964308e-02, -1.37140370e-01, -4.52293225e-01,\n          4.39604095e-01, -9.83650610e-02, -4.01688219e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  9.99415414e-01,\n          3.11294302e-04,  2.44730478e-03,  5.36405890e-01,\n          2.12387943e-01,  9.15388579e-01,  3.48861736e-03,\n          5.24734012e-02,  1.22596504e-01,  9.14888622e-01,\n          1.78858220e-02,  2.66105942e-01,  4.47646920e-01,\n          7.89922361e-01,  4.35554764e-02,  1.40709426e-01,\n          3.73088787e-01,  8.90623239e-02,  6.33388302e-01,\n          7.13842967e-01,  1.95380100e-01, -1.99751190e-03,\n          9.61137237e-01,  7.51983858e-01,  3.18677072e-02,\n          4.49997914e-03,  7.92946024e-01,  3.65494033e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          3.00967059e-01, -1.06372984e-01, -3.30127286e-02,\n         -1.24864224e-01,  8.69261431e-04,  1.82815252e-01,\n          4.27042536e-02, -1.07160752e-01, -2.92629582e-03,\n         -1.09620834e-02, -1.18342766e-01, -4.13078020e-02,\n         -7.79490052e-03, -2.84062863e-01, -9.12642017e-02,\n         -7.24072927e-02,  1.92947751e-03, -2.25093733e-02,\n         -3.12326871e-03, -1.37574801e-01,  2.25519771e-01,\n         -6.57318120e-04, -1.28864863e-02,  4.43032913e-02,\n         -5.61164471e-02, -1.03702458e-02, -7.20725318e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  7.40121022e-02,  2.30628558e-01,\n          3.74939397e-01,  4.48985209e-02, -5.05107335e-02,\n          9.65889815e-02,  2.95960342e-01,  2.51292543e-02,\n          5.56069810e-02,  3.83496683e-01,  2.55534359e-01,\n          1.09013921e-01,  3.27988892e-01,  2.91510965e-01,\n          3.11364776e-01,  1.59899221e-01,  1.81644008e-01,\n          1.25878088e-01,  3.70439196e-01, -5.24273355e-02,\n          3.13688745e-02,  1.27533035e-01,  4.88867376e-02,\n          5.22140472e-02,  9.47319272e-02,  2.13163286e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  7.47420229e-01,\n          5.73761728e-01,  3.10336816e-01,  2.00398605e-02,\n          1.85904669e-01,  3.86631123e-01,  1.85764306e-01,\n          7.64225965e-02,  6.52642992e-01,  7.45203173e-01,\n          5.56776704e-01,  1.68062734e-01,  4.24373712e-01,\n          7.34270695e-01,  2.88170499e-01,  7.05383865e-01,\n          6.03767443e-01,  5.50418732e-01, -6.24718442e-03,\n          2.23106680e-01,  5.93654232e-01,  1.26921698e-01,\n          1.76948483e-02,  4.97665271e-01,  6.56535835e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.64702164e-01, -1.21672282e-01,  3.12475654e-03,\n          1.14058169e-01,  2.35554815e-01, -1.01227725e-01,\n          7.12164167e-02,  2.43725550e-01,  7.77281971e-02,\n         -1.42695869e-01,  2.02387463e-01,  2.34962151e-01,\n          1.52527344e-01,  1.63279232e-01, -7.01413948e-02,\n         -1.15620656e-01,  2.82835992e-01, -1.91068587e-02,\n         -1.04527116e-01, -1.40302734e-01,  9.49412021e-02,\n          2.00327209e-02, -1.55232274e-01,  9.31616654e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  2.00251653e-01,  7.10986654e-03,\n          5.91136416e-02,  5.27181085e-02, -2.09566583e-01,\n          2.44308017e-02, -6.22199379e-02,  4.37811496e-02,\n          5.11135553e-02,  2.10512391e-02,  6.08077340e-02,\n         -4.03221369e-02,  8.05272371e-02, -1.25745064e-02,\n          2.03673501e-01,  1.49180947e-03, -4.91206375e-03,\n          5.90374304e-02, -5.74186198e-02,  4.26092883e-02,\n          8.04910713e-03, -1.52575107e-01,  1.87392980e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  1.13979324e-01,\n          2.16022686e-01,  8.09375220e-02, -1.74976486e-02,\n          7.50796829e-02, -4.49109654e-02,  2.66661167e-02,\n         -1.31799871e-02, -7.65367097e-02,  9.84324781e-02,\n         -1.96516383e-02,  2.13582086e-01, -1.67505135e-02,\n          3.32451187e-02, -1.68563242e-02,  4.37910457e-02,\n         -9.76529091e-03, -2.80614961e-02,  1.58835611e-01,\n          7.48893122e-02, -3.83587089e-02,  1.64973961e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          1.38797054e-01,  1.06090160e-01,  9.14821358e-03,\n          5.64170768e-02, -8.49444235e-02,  3.75668392e-02,\n         -3.80544817e-03, -4.72578679e-02,  1.21999605e-01,\n         -3.72952262e-02,  1.76546528e-01, -1.72143928e-02,\n          5.32939986e-02, -1.25884596e-02, -2.53020335e-02,\n         -4.04476738e-03, -2.52746555e-02,  9.54151681e-02,\n          1.14209006e-02, -3.47655008e-02,  1.92997985e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  3.29923868e-02,  1.15849927e-02,\n          9.04340394e-03, -5.49413704e-02,  1.88259631e-02,\n          9.00687837e-03,  2.14574347e-03,  3.55694386e-02,\n         -2.46378370e-02,  1.36643347e-02, -6.01386934e-03,\n          2.35696650e-02, -1.75610678e-03,  2.15551559e-03,\n          6.88371280e-03, -9.50624382e-03,  6.45662614e-03,\n          1.32291796e-02, -2.38380133e-02,  3.85987436e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  2.66372646e-01,\n          1.06771169e-02,  1.68674056e-02, -2.65210717e-02,\n          6.79477102e-02,  5.11284322e-02, -8.13759784e-03,\n          3.30367045e-03, -7.32457252e-03,  4.55271528e-02,\n         -3.12745909e-02,  1.26503345e-02, -5.13278208e-03,\n          5.78568639e-02,  1.11100603e-01,  8.73338020e-03,\n          6.78034631e-03,  2.10733103e-01, -7.51362546e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.99239862e-02,  1.69235510e-02, -1.37597203e-02,\n          1.87923766e-02,  5.20717506e-02, -1.00953945e-02,\n          1.67089687e-02, -1.33575384e-02,  2.35524886e-02,\n         -3.41305944e-02,  2.10333810e-02, -1.73162393e-02,\n          9.45437202e-03,  3.40617346e-02,  2.64095850e-02,\n          4.05624833e-02,  4.55293368e-02, -9.78170858e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  2.00276816e-02, -2.31260947e-02,\n         -2.92582925e-03, -1.18727933e-02, -2.49466937e-03,\n          1.15174129e-03, -1.50914153e-03,  3.75456110e-03,\n         -2.16716562e-02, -8.75425853e-03,  3.52821409e-03,\n          2.97282585e-03,  2.49905530e-02, -2.61049399e-03,\n         -4.41459628e-04,  4.32549163e-02, -3.56573410e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  4.99768636e-02,\n          6.06906302e-03,  1.66784883e-03,  4.84003450e-03,\n          4.03978140e-02,  8.22099722e-03,  2.44470443e-02,\n          2.21130043e-03,  2.72616911e-02,  1.28091614e-03,\n         -3.67049437e-02, -2.91030510e-02,  5.76339038e-03,\n          8.88261308e-04, -9.62310876e-04,  5.05348699e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          3.58248366e-02,  1.62816951e-02, -3.46241641e-03,\n          6.85389524e-03, -4.67777424e-03,  2.77114893e-02,\n         -2.62190392e-02,  7.16532095e-03,  7.97340908e-04,\n          8.87347182e-03,  2.51400871e-02, -8.02972444e-04,\n         -9.27538329e-03,  3.71145631e-02, -5.02611559e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  1.00246041e-01, -5.36918560e-04,\n         -8.67596267e-03,  6.16602842e-03, -3.18481875e-03,\n          2.54046854e-02,  1.06223302e-02, -3.16119236e-03,\n          1.20513302e-03,  2.39908211e-03,  3.25546906e-03,\n         -1.65179019e-02, -3.39308810e-03,  4.35582440e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  3.51097956e-03,\n         -4.89464167e-03,  7.00532442e-03, -7.35901995e-03,\n          4.08457901e-03,  5.93473618e-06, -2.20187708e-04,\n          1.23416897e-02,  2.33909472e-03,  5.15219765e-03,\n          7.30819660e-03, -4.37194398e-03,  2.30171172e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          1.64624235e-02, -6.92928272e-04,  8.57604787e-03,\n         -2.73411401e-02,  1.18916658e-02,  5.25632247e-04,\n          8.66826163e-03,  1.36202837e-02,  1.34385332e-03,\n         -5.14031536e-03,  2.69469724e-02, -3.31599347e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  3.91902152e-03,  1.48353254e-03,\n          3.61168312e-03,  9.46119550e-04, -6.24902173e-05,\n          1.40396808e-04,  4.15398386e-03,  4.24160184e-03,\n         -2.72512798e-03,  4.51199876e-03,  1.40309853e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  7.26171776e-03,\n         -1.59283613e-02, -7.50504765e-03, -1.66067148e-03,\n         -2.53029814e-02, -2.45590930e-03,  2.52288097e-04,\n          1.78236408e-03,  2.09618575e-02, -4.47213535e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.16587429e-02,  3.87684590e-03,  5.90801382e-04,\n          1.22566925e-03, -1.85205507e-04, -1.71611928e-03,\n          9.07801860e-03,  1.54079491e-03,  1.92802398e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  8.49043620e-03,  2.37869450e-03,\n          2.49539249e-03,  1.00574544e-02,  1.63722820e-03,\n          1.31840083e-03,  8.29629235e-03, -2.05413060e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  4.48978133e-03,\n         -2.51299732e-03, -3.40588305e-03, -1.24739214e-03,\n          9.07547923e-03, -4.92247951e-03, -1.63370491e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.47932015e-02,  1.03973599e-02,  6.75809431e-04,\n         -2.30679127e-04,  5.38200901e-03, -3.97738941e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  7.15568368e-03, -5.62444188e-04,\n          5.76366365e-04,  8.69219422e-03,  4.57320939e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  4.13084766e-03,\n         -1.72551595e-02, -2.25889240e-03, -1.06009355e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          1.67027605e-02, -1.16103070e-03, -1.37326090e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  8.92620793e-03,  5.35410809e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  7.97775436e-03]]),\n 'SigmaSqr': 84857.06668431876,\n 'Lambda': None,\n 'de_bounds': [[-3, 2], [-3, 2], [-3, 2]]}\nvars(Sf)\n\n{'name': 'kriging',\n 'seed': 123,\n 'rng': Generator(PCG64) at 0x157980580,\n 'log': {'negLnLike': array([98.35697995]),\n  'theta': array([ 0.80783164, -0.37384828,  0.08728075]),\n  'p': array([2.]),\n  'Lambda': array([None], dtype=object)},\n 'verbosity': 50,\n 'noise': False,\n 'var_type': ['num', 'num', 'factor'],\n 'cod_type': 'norm',\n 'use_cod_y': False,\n 'log_level': 50,\n 'sigma': 0,\n 'eps': 1.4901161193847656e-08,\n 'min_theta': -3,\n 'max_theta': 2,\n 'min_p': 1,\n 'max_p': 2,\n 'min_Lambda': 1e-09,\n 'max_Lambda': 1.0,\n 'n_theta': 3,\n 'n_p': 1,\n 'optim_p': False,\n 'cnd_Psi': 399407.35823828634,\n 'inf_Psi': False,\n 'model_optimizer': &lt;function scipy.optimize._differentialevolution.differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=(), x0=None, *, integrality=None, vectorized=False)&gt;,\n 'model_fun_evals': 100,\n 'nat_X': array([[-2.84117593,  5.97308949,  1.        ],\n        [-3.61017994,  6.90781409,  1.        ],\n        [ 9.91204705,  5.09395275,  1.        ],\n        [-4.4616725 ,  1.3617128 ,  1.        ],\n        [-2.40987728,  8.05505365,  2.        ],\n        [ 5.24351477, 10.3775177 ,  2.        ],\n        [ 2.5878792 , 11.89311852,  2.        ],\n        [ 8.12926647,  3.6850299 ,  1.        ],\n        [-1.96370363,  0.38404591,  1.        ],\n        [ 0.10043744,  1.74091748,  2.        ],\n        [ 1.38422219,  7.917048  ,  2.        ],\n        [ 9.25110552, 13.20863768,  1.        ],\n        [-1.09216899,  4.49255254,  1.        ],\n        [ 3.26443339, 14.63587834,  2.        ],\n        [ 4.54069975,  9.187233  ,  1.        ],\n        [ 7.04143871,  8.56765487,  1.        ],\n        [-0.10907144, 14.06693628,  1.        ],\n        [ 1.63462403,  7.36106735,  2.        ],\n        [ 4.10147822, 12.56738914,  1.        ],\n        [ 0.85028105,  2.73647896,  2.        ],\n        [ 5.9642566 , 10.70838079,  1.        ],\n        [ 6.3810468 ,  4.61751818,  2.        ],\n        [ 2.41318418, 12.34362887,  1.        ],\n        [-3.00723724,  0.98372404,  1.        ],\n        [ 8.75164908,  6.26584373,  2.        ],\n        [ 6.93615484, 11.37121875,  2.        ],\n        [-0.50159055,  2.30946613,  1.        ],\n        [-4.78793654,  9.78635061,  2.        ],\n        [ 7.58244883, 13.69175437,  1.        ],\n        [ 3.86695804,  3.09448894,  2.        ]]),\n 'nat_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'n': 30,\n 'k': 3,\n 'cod_X': array([[0.13243284, 0.39216316, 0.        ],\n        [0.08011959, 0.45774943, 0.        ],\n        [1.        , 0.33047728, 0.        ],\n        [0.02219486, 0.06859938, 0.        ],\n        [0.16177292, 0.53824712, 1.        ],\n        [0.68241242, 0.7012061 , 1.        ],\n        [0.50175673, 0.80755037, 1.        ],\n        [0.87872227, 0.23161822, 0.        ],\n        [0.1921249 , 0.        , 0.        ],\n        [0.33254282, 0.09520682, 1.        ],\n        [0.41987521, 0.52856376, 1.        ],\n        [0.95503794, 0.89985564, 0.        ],\n        [0.25141304, 0.28827918, 0.        ],\n        [0.54778088, 1.        , 1.        ],\n        [0.63460182, 0.61768809, 0.        ],\n        [0.8047203 , 0.57421451, 0.        ],\n        [0.3182905 , 0.96007938, 0.        ],\n        [0.43690937, 0.48955259, 1.        ],\n        [0.60472277, 0.85486153, 0.        ],\n        [0.38355265, 0.1650618 , 1.        ],\n        [0.73144253, 0.72442157, 0.        ],\n        [0.75979563, 0.29704758, 1.        ],\n        [0.4898727 , 0.83916107, 0.        ],\n        [0.12113614, 0.04207727, 0.        ],\n        [0.92106127, 0.41270467, 1.        ],\n        [0.79755813, 0.77093054, 1.        ],\n        [0.29158849, 0.13509984, 0.        ],\n        [0.        , 0.65972602, 1.        ],\n        [0.84152375, 0.93375421, 0.        ],\n        [0.588769  , 0.19018207, 1.        ]]),\n 'cod_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'num_mask': array([ True,  True, False]),\n 'factor_mask': array([False, False,  True]),\n 'int_mask': array([False, False, False]),\n 'ordered_mask': array([ True,  True, False]),\n 'nat_range_X': [[-4.787936542018484, 9.912047049457485],\n  [0.3840459056967906, 14.63587833590837],\n  [1.0, 2.0]],\n 'nat_range_y': [-5.449830806521344, 222.4188410638947],\n 'nat_mean_X': array([2.50508374, 7.5128501 , 1.43333333]),\n 'nat_std_X': array([4.3289971 , 4.28784459, 0.49553562]),\n 'nat_mean_y': 71.56762485893886,\n 'nat_std_y': 56.27119875010559,\n 'mean_cod_y': array([ 42.09388125,  53.965223  ,  16.25588575, 222.41884106,\n         -0.74018949,  88.97027586,  75.49463536,  21.74135821,\n        101.69079805,  26.3681054 ,  16.77800101, 128.83487789,\n         35.98089141, 145.59047908,  78.42915074,  81.277265  ,\n         91.82566843,  12.4736378 , 133.78079756,  10.34983517,\n        121.38146188,  21.89850532, 101.79776372, 130.84111259,\n         10.98328188, 111.57203528,  48.861847  ,  46.90159224,\n        174.66155808,  -5.44983081]),\n 'theta': array([ 0.80783164, -0.37384828,  0.08728075]),\n 'x0_theta': array([0.1, 0.1, 0.1]),\n 'p': array([2.]),\n 'pen_val': 10241.8109702054,\n 'negLnLike': 98.35697994648268,\n 'gen': &lt;spotPython.design.spacefilling.spacefilling at 0x157c2ee60&gt;,\n 'LnDetPsi': -111.8071188745676,\n 'Psi': array([[1.00000001e+00, 9.80786736e-01, 7.93025977e-03, 8.84849308e-01,\n         3.62564282e-01, 5.06095678e-02, 1.42381864e-01, 2.76274210e-02,\n         9.15837126e-01, 2.74022961e-01, 2.14666556e-01, 1.16060379e-02,\n         9.08910691e-01, 1.03880653e-01, 1.93676472e-01, 5.40608029e-02,\n         6.98871449e-01, 2.01979483e-01, 2.17941208e-01, 2.40043294e-01,\n         9.51950032e-02, 2.92357998e-02, 4.04427734e-01, 9.48721233e-01,\n         6.76679439e-03, 2.01862415e-02, 8.26402449e-01, 3.18879115e-01,\n         3.49350038e-02, 9.48858386e-02],\n        [9.80786736e-01, 1.00000001e+00, 4.32632920e-03, 9.17974257e-01,\n         3.51490395e-01, 3.48901873e-02, 1.11486710e-01, 1.62627576e-02,\n         8.44348655e-01, 2.31096589e-01, 1.74870051e-01, 6.73528179e-03,\n         8.18203544e-01, 7.97082758e-02, 1.37243735e-01, 3.40871531e-02,\n         6.24304355e-01, 1.62310311e-01, 1.59657724e-01, 1.96375888e-01,\n         6.35815843e-02, 1.87094655e-02, 3.19771602e-01, 9.19556552e-01,\n         3.91056213e-03, 1.29298271e-02, 7.17983212e-01, 3.46980157e-01,\n         2.19222781e-02, 6.77172235e-02],\n        [7.93025977e-03, 4.32632920e-03, 1.00000001e+00, 2.08837077e-03,\n         3.95733553e-03, 1.81574826e-01, 6.78088263e-02, 9.06083379e-01,\n         1.44201050e-02, 2.05383373e-02, 4.16404112e-02, 8.60655479e-01,\n         2.73000669e-02, 8.18118964e-02, 4.09574931e-01, 7.63297684e-01,\n         4.27154310e-02, 4.74686263e-02, 3.26267423e-01, 3.16542407e-02,\n         5.89214780e-01, 2.53815504e-01, 1.68431739e-01, 6.75566212e-03,\n         3.52434240e-01, 2.60457718e-01, 3.91561406e-02, 5.69802054e-04,\n         7.29622706e-01, 1.23100255e-01],\n        [8.84849308e-01, 9.17974257e-01, 2.08837077e-03, 1.00000001e+00,\n         2.95696914e-01, 1.88825838e-02, 6.66462855e-02, 8.87587739e-03,\n         8.29027699e-01, 1.98082909e-01, 1.21788591e-01, 2.78742468e-03,\n         6.99109219e-01, 4.32190945e-02, 7.91116662e-02, 1.75616231e-02,\n         4.06866397e-01, 1.13059406e-01, 8.70361448e-02, 1.58369062e-01,\n         3.29248378e-02, 1.09186273e-02, 1.90860608e-01, 9.38766816e-01,\n         1.94845701e-03, 6.27722425e-03, 6.26186928e-01, 3.16348848e-01,\n         9.76291319e-03, 4.64899841e-02],\n        [3.62564282e-01, 3.51490395e-01, 3.95733553e-03, 2.95696914e-01,\n         1.00000001e+00, 1.73312748e-01, 4.61509439e-01, 1.30105661e-02,\n         3.23546474e-01, 7.63117982e-01, 6.51803816e-01, 6.10921249e-03,\n         3.40261296e-01, 3.50849329e-01, 8.72524040e-02, 2.58287165e-02,\n         2.91527775e-01, 6.14264888e-01, 9.99706121e-02, 6.87374559e-01,\n         4.50708643e-02, 9.80616397e-02, 1.77307911e-01, 3.28013758e-01,\n         2.44666710e-02, 7.28192068e-02, 3.08206996e-01, 8.39987047e-01,\n         1.76927736e-02, 2.94477027e-01],\n        [5.06095678e-02, 3.48901873e-02, 1.81574826e-01, 1.88825838e-02,\n         1.73312748e-01, 1.00000001e+00, 8.06984354e-01, 2.61631940e-01,\n         6.37873512e-02, 3.89974474e-01, 6.34189132e-01, 2.24433584e-01,\n         1.03779088e-01, 8.57105478e-01, 3.61448952e-01, 3.31899687e-01,\n         1.52573174e-01, 6.66210254e-01, 3.50372559e-01, 4.98901401e-01,\n         3.62159051e-01, 8.98045252e-01, 2.87593069e-01, 4.04546347e-02,\n         6.69595049e-01, 9.16463105e-01, 1.20418171e-01, 5.01629407e-02,\n         3.05590970e-01, 8.46408972e-01],\n        [1.42381864e-01, 1.11486710e-01, 6.78088263e-02, 6.66462855e-02,\n         4.61509439e-01, 8.06984354e-01, 1.00000001e+00, 1.28327211e-01,\n         1.50822393e-01, 6.71324412e-01, 9.26832778e-01, 9.79222329e-02,\n         2.19448393e-01, 9.71156098e-01, 3.23480017e-01, 1.99349611e-01,\n         2.93440379e-01, 9.32606445e-01, 3.43331859e-01, 7.67744828e-01,\n         2.61363284e-01, 5.83942197e-01, 3.67390556e-01, 1.13215440e-01,\n         3.02573761e-01, 5.69674044e-01, 2.28787245e-01, 1.96588667e-01,\n         1.74056386e-01, 8.10751548e-01],\n        [2.76274210e-02, 1.62627576e-02, 9.06083379e-01, 8.87587739e-03,\n         1.30105661e-02, 2.61631940e-01, 1.28327211e-01, 1.00000001e+00,\n         4.73001895e-02, 5.37001604e-02, 9.16409704e-02, 7.97541772e-01,\n         7.97019005e-02, 1.41812690e-01, 6.40260122e-01, 9.18688011e-01,\n         1.06228234e-01, 1.02063358e-01, 5.23849441e-01, 7.59950356e-02,\n         7.85027476e-01, 3.35318759e-01, 3.23855505e-01, 2.46647212e-02,\n         3.58659640e-01, 3.11828844e-01, 1.08762097e-01, 2.38608756e-03,\n         8.04659626e-01, 2.14200506e-01],\n        [9.15837126e-01, 8.44348655e-01, 1.44201050e-02, 8.29027699e-01,\n         3.23546474e-01, 6.37873512e-02, 1.50822393e-01, 4.73001895e-02,\n         1.00000001e+00, 3.22870682e-01, 2.34251374e-01, 1.68804798e-02,\n         9.43913873e-01, 1.06944587e-01, 2.41925741e-01, 7.80573498e-02,\n         6.11406177e-01, 2.26212945e-01, 2.45942525e-01, 2.87383207e-01,\n         1.23624343e-01, 4.47096017e-02, 4.20088650e-01, 9.67418909e-01,\n         1.12700948e-02, 2.71562267e-02, 9.31206974e-01, 2.41433138e-01,\n         4.60541629e-02, 1.31859360e-01],\n        [2.74022961e-01, 2.31096589e-01, 2.05383373e-02, 1.98082909e-01,\n         7.63117982e-01, 3.89974474e-01, 6.71324412e-01, 5.37001604e-02,\n         3.22870682e-01, 1.00000001e+00, 8.79499213e-01, 2.32091813e-02,\n         3.47133144e-01, 5.25311363e-01, 1.82394766e-01, 7.97114885e-02,\n         2.67784295e-01, 8.73079725e-01, 1.79079089e-01, 9.81395743e-01,\n         1.11955665e-01, 3.04231977e-01, 2.48320227e-01, 2.75734398e-01,\n         1.03546587e-01, 2.05509425e-01, 3.63691885e-01, 4.29478795e-01,\n         5.17350401e-02, 6.53386267e-01],\n        [2.14666556e-01, 1.74870051e-01, 4.16404112e-02, 1.21788591e-01,\n         6.51803816e-01, 6.34189132e-01, 9.26832778e-01, 9.16409704e-02,\n         2.34251374e-01, 8.79499213e-01, 1.00000001e+00, 5.51208517e-02,\n         2.99173113e-01, 8.19489347e-01, 2.72648741e-01, 1.41937331e-01,\n         3.18215333e-01, 9.97495553e-01, 2.82372049e-01, 9.37682240e-01,\n         1.94006919e-01, 4.65345896e-01, 3.42231928e-01, 1.87605840e-01,\n         1.98017291e-01, 3.90143933e-01, 3.09998738e-01, 3.19863046e-01,\n         1.09526012e-01, 7.93208070e-01],\n        [1.16060379e-02, 6.73528179e-03, 8.60655479e-01, 2.78742468e-03,\n         6.10921249e-03, 2.24433584e-01, 9.79222329e-02, 7.97541772e-01,\n         1.68804798e-02, 2.32091813e-02, 5.51208517e-02, 1.00000001e+00,\n         3.54801910e-02, 1.26213766e-01, 4.99915820e-01, 8.26960892e-01,\n         7.38083359e-02, 6.10627429e-02, 4.54180181e-01, 3.59199263e-02,\n         7.15910821e-01, 2.46958067e-01, 2.48662703e-01, 8.40801802e-03,\n         3.30298826e-01, 3.11501227e-01, 4.61861261e-02, 1.02399160e-03,\n         9.20105350e-01, 1.25582037e-01],\n        [9.08910691e-01, 8.18203544e-01, 2.73000669e-02, 6.99109219e-01,\n         3.40261296e-01, 1.03779088e-01, 2.19448393e-01, 7.97019005e-02,\n         9.43913873e-01, 3.47133144e-01, 2.99173113e-01, 3.54801910e-02,\n         1.00000001e+00, 1.68898894e-01, 3.71875594e-01, 1.35147567e-01,\n         8.02874213e-01, 2.89910015e-01, 3.91538127e-01, 3.26738596e-01,\n         2.09970412e-01, 6.99179044e-02, 6.10411245e-01, 8.74009263e-01,\n         2.04980511e-02, 4.90592582e-02, 9.79914150e-01, 2.31213662e-01,\n         8.95167455e-02, 1.76361040e-01],\n        [1.03880653e-01, 7.97082758e-02, 8.18118964e-02, 4.32190945e-02,\n         3.50849329e-01, 8.57105478e-01, 9.71156098e-01, 1.41812690e-01,\n         1.06944587e-01, 5.25311363e-01, 8.19489347e-01, 1.26213766e-01,\n         1.68898894e-01, 1.00000001e+00, 3.29484467e-01, 2.22956624e-01,\n         2.62102538e-01, 8.27671226e-01, 3.57100868e-01, 6.26237227e-01,\n         2.86844515e-01, 6.07921725e-01, 3.56122267e-01, 7.75070336e-02,\n         3.53101833e-01, 6.55081711e-01, 1.75880526e-01, 1.38528015e-01,\n         2.10939713e-01, 7.49702955e-01],\n        [1.93676472e-01, 1.37243735e-01, 4.09574931e-01, 7.91116662e-02,\n         8.72524040e-02, 3.61448952e-01, 3.23480017e-01, 6.40260122e-01,\n         2.41925741e-01, 1.82394766e-01, 2.72648741e-01, 4.99915820e-01,\n         3.71875594e-01, 3.29484467e-01, 1.00000001e+00, 8.29673720e-01,\n         5.00400917e-01, 2.84215675e-01, 9.70912079e-01, 2.25029457e-01,\n         9.37006159e-01, 3.18490558e-01, 8.56151641e-01, 1.59795412e-01,\n         2.13323641e-01, 3.07116806e-01, 4.25559013e-01, 2.76543402e-02,\n         7.28105477e-01, 3.35957752e-01],\n        [5.40608029e-02, 3.40871531e-02, 7.63297684e-01, 1.75616231e-02,\n         2.58287165e-02, 3.31899687e-01, 1.99349611e-01, 9.18688011e-01,\n         7.80573498e-02, 7.97114885e-02, 1.41937331e-01, 8.26960892e-01,\n         1.35147567e-01, 2.22956624e-01, 8.29673720e-01, 1.00000001e+00,\n         2.05347159e-01, 1.53792201e-01, 7.48060598e-01, 1.09661854e-01,\n         9.56919275e-01, 3.51534561e-01, 5.13490705e-01, 4.40793858e-02,\n         3.33542550e-01, 3.61789997e-01, 1.69806382e-01, 5.72242766e-03,\n         9.38606693e-01, 2.56158631e-01],\n        [6.98871449e-01, 6.24304355e-01, 4.27154310e-02, 4.06866397e-01,\n         2.91527775e-01, 1.52573174e-01, 2.93440379e-01, 1.06228234e-01,\n         6.11406177e-01, 2.67784295e-01, 3.18215333e-01, 7.38083359e-02,\n         8.02874213e-01, 2.62102538e-01, 5.00400917e-01, 2.05347159e-01,\n         1.00000001e+00, 3.06050999e-01, 5.87570117e-01, 2.74006157e-01,\n         3.26250769e-01, 8.73213997e-02, 8.22572263e-01, 5.45510105e-01,\n         3.14023410e-02, 8.28442932e-02, 7.46510466e-01, 1.84705929e-01,\n         1.72196887e-01, 1.78955137e-01],\n        [2.01979483e-01, 1.62310311e-01, 4.74686263e-02, 1.13059406e-01,\n         6.14264888e-01, 6.66210254e-01, 9.32606445e-01, 1.02063358e-01,\n         2.26212945e-01, 8.73079725e-01, 9.97495553e-01, 6.10627429e-02,\n         2.89910015e-01, 8.27671226e-01, 2.84215675e-01, 1.53792201e-01,\n         3.06050999e-01, 1.00000001e+00, 2.90153728e-01, 9.39121910e-01,\n         2.05843708e-01, 5.03865127e-01, 3.43111324e-01, 1.78127558e-01,\n         2.21265306e-01, 4.19337208e-01, 3.04588840e-01, 2.89791341e-01,\n         1.18223038e-01, 8.30232967e-01],\n        [2.17941208e-01, 1.59657724e-01, 3.26267423e-01, 8.70361448e-02,\n         9.99706121e-02, 3.50372559e-01, 3.43331859e-01, 5.23849441e-01,\n         2.45942525e-01, 1.79079089e-01, 2.82372049e-01, 4.54180181e-01,\n         3.91538127e-01, 3.57100868e-01, 9.70912079e-01, 7.48060598e-01,\n         5.87570117e-01, 2.90153728e-01, 1.00000001e+00, 2.19710894e-01,\n         8.95515117e-01, 2.76359416e-01, 9.18654361e-01, 1.68351438e-01,\n         1.78075016e-01, 2.88842896e-01, 4.27853796e-01, 3.45471112e-02,\n         6.95671852e-01, 3.04697780e-01],\n        [2.40043294e-01, 1.96375888e-01, 3.16542407e-02, 1.58369062e-01,\n         6.87374559e-01, 4.98901401e-01, 7.67744828e-01, 7.59950356e-02,\n         2.87383207e-01, 9.81395743e-01, 9.37682240e-01, 3.59199263e-02,\n         3.26738596e-01, 6.26237227e-01, 2.25029457e-01, 1.09661854e-01,\n         2.74006157e-01, 9.39121910e-01, 2.19710894e-01, 1.00000001e+00,\n         1.48107228e-01, 3.99798791e-01, 2.82309058e-01, 2.34853358e-01,\n         1.52279903e-01, 2.84691434e-01, 3.48292298e-01, 3.50439069e-01,\n         7.44764711e-02, 7.62752399e-01],\n        [9.51950032e-02, 6.35815843e-02, 5.89214780e-01, 3.29248378e-02,\n         4.50708643e-02, 3.62159051e-01, 2.61363284e-01, 7.85027476e-01,\n         1.23624343e-01, 1.11955665e-01, 1.94006919e-01, 7.15910821e-01,\n         2.09970412e-01, 2.86844515e-01, 9.37006159e-01, 9.56919275e-01,\n         3.26250769e-01, 2.05843708e-01, 8.95515117e-01, 1.48107228e-01,\n         1.00000001e+00, 3.38784410e-01, 6.83541582e-01, 7.50367926e-02,\n         2.80249637e-01, 3.57365100e-01, 2.49130039e-01, 1.18092893e-02,\n         9.08120869e-01, 2.86089697e-01],\n        [2.92357998e-02, 1.87094655e-02, 2.53815504e-01, 1.09186273e-02,\n         9.80616397e-02, 8.98045252e-01, 5.83942197e-01, 3.35318759e-01,\n         4.47096017e-02, 3.04231977e-01, 4.65345896e-01, 2.46958067e-01,\n         6.99179044e-02, 6.07921725e-01, 3.18490558e-01, 3.51534561e-01,\n         8.73213997e-02, 5.03865127e-01, 2.76359416e-01, 3.99798791e-01,\n         3.38784410e-01, 1.00000001e+00, 2.03450885e-01, 2.60456611e-02,\n         8.41362803e-01, 9.01125283e-01, 8.89723267e-02, 2.31827798e-02,\n         2.96912039e-01, 8.24694166e-01],\n        [4.04427734e-01, 3.19771602e-01, 1.68431739e-01, 1.90860608e-01,\n         1.77307911e-01, 2.87593069e-01, 3.67390556e-01, 3.23855505e-01,\n         4.20088650e-01, 2.48320227e-01, 3.42231928e-01, 2.48662703e-01,\n         6.10411245e-01, 3.56122267e-01, 8.56151641e-01, 5.13490705e-01,\n         8.22572263e-01, 3.43111324e-01, 9.18654361e-01, 2.82309058e-01,\n         6.83541582e-01, 2.03450885e-01, 1.00000001e+00, 3.19136778e-01,\n         1.03173791e-01, 1.99854220e-01, 6.29911339e-01, 7.76683692e-02,\n         4.50132628e-01, 2.89120223e-01],\n        [9.48721233e-01, 9.19556552e-01, 6.75566212e-03, 9.38766816e-01,\n         3.28013758e-01, 4.04546347e-02, 1.13215440e-01, 2.46647212e-02,\n         9.67418909e-01, 2.75734398e-01, 1.87605840e-01, 8.40801802e-03,\n         8.74009263e-01, 7.75070336e-02, 1.59795412e-01, 4.40793858e-02,\n         5.45510105e-01, 1.78127558e-01, 1.68351438e-01, 2.34853358e-01,\n         7.50367926e-02, 2.60456611e-02, 3.19136778e-01, 1.00000001e+00,\n         5.69072463e-03, 1.55441921e-02, 8.26700464e-01, 2.84913001e-01,\n         2.54722744e-02, 8.94422246e-02],\n        [6.76679439e-03, 3.91056213e-03, 3.52434240e-01, 1.94845701e-03,\n         2.44666710e-02, 6.69595049e-01, 3.02573761e-01, 3.58659640e-01,\n         1.12700948e-02, 1.03546587e-01, 1.98017291e-01, 3.30298826e-01,\n         2.04980511e-02, 3.53101833e-01, 2.13323641e-01, 3.33542550e-01,\n         3.14023410e-02, 2.21265306e-01, 1.78075016e-01, 1.52279903e-01,\n         2.80249637e-01, 8.41362803e-01, 1.03173791e-01, 5.69072463e-03,\n         1.00000001e+00, 8.58773932e-01, 2.79271166e-02, 4.18623717e-03,\n         3.14920968e-01, 4.81761935e-01],\n        [2.01862415e-02, 1.29298271e-02, 2.60457718e-01, 6.27722425e-03,\n         7.28192068e-02, 9.16463105e-01, 5.69674044e-01, 3.11828844e-01,\n         2.71562267e-02, 2.05509425e-01, 3.90143933e-01, 3.11501227e-01,\n         4.90592582e-02, 6.55081711e-01, 3.07116806e-01, 3.61789997e-01,\n         8.28442932e-02, 4.19337208e-01, 2.88842896e-01, 2.84691434e-01,\n         3.57365100e-01, 9.01125283e-01, 1.99854220e-01, 1.55441921e-02,\n         8.58773932e-01, 1.00000001e+00, 5.98679944e-02, 1.67095615e-02,\n         3.59289180e-01, 6.55301154e-01],\n        [8.26402449e-01, 7.17983212e-01, 3.91561406e-02, 6.26186928e-01,\n         3.08206996e-01, 1.20418171e-01, 2.28787245e-01, 1.08762097e-01,\n         9.31206974e-01, 3.63691885e-01, 3.09998738e-01, 4.61861261e-02,\n         9.79914150e-01, 1.75880526e-01, 4.25559013e-01, 1.69806382e-01,\n         7.46510466e-01, 3.04588840e-01, 4.27853796e-01, 3.48292298e-01,\n         2.49130039e-01, 8.89723267e-02, 6.29911339e-01, 8.26700464e-01,\n         2.79271166e-02, 5.98679944e-02, 1.00000001e+00, 1.89645475e-01,\n         1.09414455e-01, 2.08324029e-01],\n        [3.18879115e-01, 3.46980157e-01, 5.69802054e-04, 3.16348848e-01,\n         8.39987047e-01, 5.01629407e-02, 1.96588667e-01, 2.38608756e-03,\n         2.41433138e-01, 4.29478795e-01, 3.19863046e-01, 1.02399160e-03,\n         2.31213662e-01, 1.38528015e-01, 2.76543402e-02, 5.72242766e-03,\n         1.84705929e-01, 2.89791341e-01, 3.45471112e-02, 3.50439069e-01,\n         1.18092893e-02, 2.31827798e-02, 7.76683692e-02, 2.84913001e-01,\n         4.18623717e-03, 1.67095615e-02, 1.89645475e-01, 1.00000001e+00,\n         3.76782427e-03, 9.82514199e-02],\n        [3.49350038e-02, 2.19222781e-02, 7.29622706e-01, 9.76291319e-03,\n         1.76927736e-02, 3.05590970e-01, 1.74056386e-01, 8.04659626e-01,\n         4.60541629e-02, 5.17350401e-02, 1.09526012e-01, 9.20105350e-01,\n         8.95167455e-02, 2.10939713e-01, 7.28105477e-01, 9.38606693e-01,\n         1.72196887e-01, 1.18223038e-01, 6.95671852e-01, 7.44764711e-02,\n         9.08120869e-01, 2.96912039e-01, 4.50132628e-01, 2.54722744e-02,\n         3.14920968e-01, 3.59289180e-01, 1.09414455e-01, 3.76782427e-03,\n         1.00000001e+00, 1.93167685e-01],\n        [9.48858386e-02, 6.77172235e-02, 1.23100255e-01, 4.64899841e-02,\n         2.94477027e-01, 8.46408972e-01, 8.10751548e-01, 2.14200506e-01,\n         1.31859360e-01, 6.53386267e-01, 7.93208070e-01, 1.25582037e-01,\n         1.76361040e-01, 7.49702955e-01, 3.35957752e-01, 2.56158631e-01,\n         1.78955137e-01, 8.30232967e-01, 3.04697780e-01, 7.62752399e-01,\n         2.86089697e-01, 8.24694166e-01, 2.89120223e-01, 8.94422246e-02,\n         4.81761935e-01, 6.55301154e-01, 2.08324029e-01, 9.82514199e-02,\n         1.93167685e-01, 1.00000001e+00]]),\n 'psi': array([[0.11446827],\n        [0.08413675],\n        [0.10520562],\n        [0.05592922],\n        [0.35852186],\n        [0.8618078 ],\n        [0.89866475],\n        [0.18922027],\n        [0.14710197],\n        [0.69962889],\n        [0.87265656],\n        [0.11831012],\n        [0.20023112],\n        [0.83869292],\n        [0.34439748],\n        [0.24435109],\n        [0.21758324],\n        [0.90242227],\n        [0.3266978 ],\n        [0.80865658],\n        [0.28674882],\n        [0.76990801],\n        [0.3233827 ],\n        [0.10317148],\n        [0.42944727],\n        [0.64440254],\n        [0.2279088 ],\n        [0.12954783],\n        [0.1910701 ],\n        [0.98263675]]),\n 'one': array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n 'mu': 248.98299832279912,\n 'U': array([[ 1.00000001e+00,  9.80786728e-01,  7.93025971e-03,\n          8.84849301e-01,  3.62564279e-01,  5.06095674e-02,\n          1.42381863e-01,  2.76274208e-02,  9.15837119e-01,\n          2.74022959e-01,  2.14666554e-01,  1.16060378e-02,\n          9.08910684e-01,  1.03880653e-01,  1.93676470e-01,\n          5.40608025e-02,  6.98871444e-01,  2.01979482e-01,\n          2.17941206e-01,  2.40043292e-01,  9.51950025e-02,\n          2.92357995e-02,  4.04427731e-01,  9.48721226e-01,\n          6.76679434e-03,  2.01862414e-02,  8.26402443e-01,\n          3.18879113e-01,  3.49350036e-02,  9.48858379e-02],\n        [ 0.00000000e+00,  1.95083081e-01, -1.76927915e-02,\n          2.56945939e-01, -2.10568677e-02, -7.55934579e-02,\n         -1.44346353e-01, -5.55345443e-02, -2.76252745e-01,\n         -1.93053607e-01, -1.82855716e-01, -2.38245470e-02,\n         -3.75450252e-01, -1.13677155e-01, -2.70200656e-01,\n         -9.70610286e-02, -3.13402278e-01, -1.83452526e-01,\n         -2.77297847e-01, -2.00198739e-01, -1.52675520e-01,\n         -5.10788463e-02, -3.94117975e-01, -5.60614197e-02,\n         -1.39746611e-02, -3.52084380e-02, -4.74368846e-01,\n          1.75452199e-01, -6.32628401e-02, -1.29921810e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  9.99812028e-01,\n         -3.82695003e-04,  7.09685270e-04,  1.79869830e-01,\n          6.41378674e-02,  9.05051850e-01,  2.27002325e-03,\n          1.49524175e-02,  3.67097221e-02,  8.60303630e-01,\n          1.34519347e-02,  7.89916779e-02,  4.03334238e-01,\n          7.61294790e-01,  3.16341841e-02,  4.26291023e-02,\n          3.19693013e-01,  2.62134879e-02,  5.85868730e-01,\n          2.52727435e-01,  1.58281227e-01, -1.76015746e-03,\n          3.52199530e-01,  2.59723522e-01,  2.42141971e-02,\n          1.14546236e-03,  7.28363279e-01,  1.20071677e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          3.88613389e-01, -5.07112908e-02, -1.64867947e-02,\n         -5.71942513e-02, -2.45614826e-03,  2.30647620e-01,\n          1.34425337e-02, -5.44522601e-02, -2.65383350e-03,\n         -2.22951633e-02, -5.00768009e-02, -5.83652254e-02,\n         -1.29775749e-02, -3.37070121e-01, -4.76265160e-02,\n         -8.86126912e-02, -6.64617312e-03, -3.05054590e-02,\n         -4.45025800e-03, -1.68983885e-01,  2.92567333e-01,\n         -8.07020084e-04, -6.27486681e-03,  4.33379796e-02,\n         -2.80288953e-02, -1.18766609e-02, -1.03981258e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  9.30339523e-01,  1.63819814e-01,\n          4.34144157e-01,  1.13680026e-03, -2.82213156e-03,\n          7.09819375e-01,  6.09815677e-01,  7.03488653e-04,\n          1.80233060e-03,  3.31273373e-01,  8.70288552e-03,\n          3.20959183e-03,  1.55072122e-02,  5.74764308e-01,\n          1.11715628e-02,  6.40381520e-01,  5.78169030e-03,\n          9.24191494e-02,  1.47217771e-02, -2.47375332e-03,\n          2.30325963e-02,  6.90677835e-02,  8.32823167e-04,\n          7.81053726e-01,  2.76811032e-03,  2.75949311e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  9.65537371e-01,\n          7.30438840e-01,  9.63374755e-02,  4.25651970e-04,\n          2.51427202e-01,  5.20023010e-01,  6.95400951e-02,\n          2.72547693e-02,  8.01576335e-01,  2.65433586e-01,\n          1.90725705e-01,  8.25703936e-02,  5.58766223e-01,\n          2.66780513e-01,  3.74804165e-01,  2.47499277e-01,\n          8.61730410e-01,  2.10934018e-01, -6.47542633e-03,\n          6.22513058e-01,  8.85150007e-01,  4.03482962e-02,\n         -8.42355500e-02,  1.73355081e-01,  7.92109095e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          4.79045566e-01, -2.64554871e-02, -1.14641601e-02,\n          2.34707571e-01,  4.58853725e-01, -2.83882576e-02,\n          2.71639619e-02,  4.23139590e-01,  6.26935357e-02,\n         -2.63754192e-02,  1.25964791e-01,  4.47210709e-01,\n          9.80795429e-02,  3.14830687e-01,  6.58978669e-03,\n         -2.37184157e-01,  1.51625223e-01, -1.52544695e-02,\n         -3.91924232e-01, -2.75198536e-01,  2.86845808e-02,\n         -2.14438062e-01, -3.18789562e-02,  1.49887417e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  4.08712218e-01,  1.18110729e-02,\n          7.55859676e-03,  8.67551715e-03,  2.40291068e-02,\n          4.79605351e-02, -1.31850762e-02,  5.64699565e-01,\n          4.98359513e-01,  8.66558453e-02,  1.20974252e-02,\n          4.64271321e-01,  1.46747493e-02,  5.38096276e-01,\n          3.31167724e-02,  3.20032062e-01, -5.19839661e-03,\n         -7.69007356e-02, -4.50070834e-02,  8.47762197e-02,\n          9.22034317e-03,  3.01919954e-01,  5.62966495e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  1.77325282e-01,\n          1.12459422e-01,  3.53636640e-02, -1.30158395e-02,\n          7.12294918e-02, -1.48069131e-02, -2.02295513e-02,\n         -1.83982953e-02, -2.09347824e-01,  4.40421149e-02,\n         -8.45282038e-02,  1.05987523e-01, -3.60845843e-02,\n          5.97886590e-03, -1.27736582e-01,  8.72069894e-02,\n         -1.79662129e-02, -1.69462073e-02,  1.83691798e-01,\n          2.25348386e-02, -3.56895663e-02,  7.15570863e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          5.02380713e-01,  2.19379167e-01, -1.48036217e-02,\n          5.58707629e-03, -1.19112143e-01, -3.52504982e-02,\n         -2.14744060e-02, -3.70484190e-02,  2.46512952e-01,\n         -5.93038028e-02,  4.81611111e-01, -3.94968870e-02,\n          1.09724617e-01, -5.13734277e-02, -3.52319540e-03,\n          3.07788539e-02, -3.05697198e-02,  1.18404794e-02,\n         -2.17308782e-01, -3.40767140e-02,  3.22391886e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  1.17773159e-01, -2.98795296e-02,\n          1.53017600e-02, -1.31334713e-01, -4.13981885e-02,\n         -3.45398834e-02, -3.43642569e-02,  1.22401158e-01,\n         -8.70864719e-02,  7.47855088e-02, -6.36498452e-02,\n          1.69771444e-01, -5.85428743e-02, -5.93453855e-03,\n          1.49912393e-01,  8.92804063e-03,  2.41709393e-02,\n         -4.56644611e-02, -6.80666836e-02,  1.81652185e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  5.01664599e-01,\n          7.06376872e-03,  9.33719154e-03,  2.22877660e-01,\n          2.81987771e-01,  4.29803673e-02, -2.84814122e-03,\n          2.75611016e-01, -2.77227052e-03,  3.47140941e-01,\n         -6.53351341e-02,  1.50945604e-01, -1.19266441e-03,\n         -4.18531253e-02,  3.63412166e-02,  7.64633349e-03,\n         -9.65897397e-03,  5.34875042e-01, -4.62137326e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          1.51879560e-01, -1.33467572e-04,  3.44535304e-01,\n          6.99061840e-02,  3.13009625e-01,  3.00061454e-03,\n          3.72513718e-01,  5.95851360e-03,  1.72069544e-01,\n         -8.59072303e-03,  4.80158194e-01, -5.29598101e-02,\n          5.14238114e-03,  1.50524729e-03,  2.09416963e-01,\n          8.73133556e-02,  3.68781067e-02,  8.44796427e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  6.56382219e-02, -4.31824061e-02,\n         -1.03900319e-02, -2.08535654e-02, -1.78377254e-02,\n         -2.97727756e-02, -1.02951813e-02, -1.55638768e-02,\n         -8.53806144e-02, -3.95727752e-02, -2.09088087e-03,\n          7.05722123e-02,  1.30286653e-01, -1.63524283e-04,\n         -1.21190567e-01,  1.62899661e-02, -1.55545749e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  3.95524768e-01,\n          1.63831320e-01,  1.10643351e-01,  2.14139614e-03,\n          4.60060684e-01,  1.86642379e-03,  3.21422578e-01,\n         -2.95370062e-02,  3.63272587e-01,  1.04591247e-02,\n         -3.48196170e-02, -2.11155220e-02,  2.46583329e-03,\n         -1.83423217e-02,  1.49901543e-01,  1.52408713e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          9.55441293e-02, -5.39146271e-02, -2.77183982e-03,\n         -1.57075548e-03, -5.34654017e-03,  9.28916208e-02,\n         -3.73211420e-02, -6.92939679e-02, -4.76650838e-03,\n         -3.91984375e-02, -6.25231179e-03, -7.40278190e-03,\n          1.27752622e-03,  1.04787214e-01, -4.29205699e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  3.26374158e-01, -4.44490152e-03,\n          9.38852201e-02, -3.76006050e-03,  1.28924303e-02,\n          3.65535409e-02,  1.77020183e-01, -1.17937837e-03,\n          6.46039663e-02,  3.09090939e-02, -2.14409946e-02,\n         -1.17552197e-02,  2.51382317e-02, -6.24883434e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  2.62444169e-02,\n          4.66289335e-04,  4.63920998e-02,  1.65741209e-03,\n         -3.82349790e-02, -4.60022022e-03, -5.28021219e-04,\n         -2.42351483e-01, -1.32046009e-01,  3.97800935e-03,\n          2.22026891e-01,  6.94882497e-03,  1.81238166e-01],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          1.21467411e-01, -1.55586884e-03,  4.73916183e-02,\n          1.79077504e-02,  9.31669835e-02,  1.02909076e-03,\n          2.43412880e-02, -1.92988841e-03, -1.28858956e-02,\n          1.94367320e-02,  8.63409432e-02, -7.21558063e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  2.32914637e-02,  8.05745013e-04,\n          1.08829636e-01, -3.44501599e-03, -2.50979188e-03,\n          1.24381431e-01,  3.39306137e-02,  5.89980799e-03,\n          5.13562883e-02,  6.47399069e-04,  9.63213632e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  3.07849020e-02,\n         -8.61878022e-03, -4.97097082e-02, -6.19104764e-03,\n         -3.69564442e-02, -1.86488477e-02,  2.86865515e-03,\n         -4.44072587e-03,  5.83705006e-02,  7.22971633e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.33108301e-01, -1.28298670e-03,  3.07404823e-04,\n          2.94554286e-01,  2.03340613e-02, -2.83108867e-04,\n         -2.00418333e-02,  2.64962157e-04,  9.83768146e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  2.83537440e-02,  8.87383181e-03,\n          7.81090344e-03,  1.19678001e-02, -8.35994363e-03,\n          1.84059802e-02,  1.88353316e-02, -3.75753952e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  1.25346407e-02,\n          9.62825054e-04,  1.46984691e-03, -8.98882826e-03,\n          1.35976401e-02,  2.93086794e-03, -9.26815162e-04],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          3.57393351e-01,  1.35510211e-01,  1.09880996e-03,\n          8.25625595e-02,  2.23430368e-03, -6.72379114e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  7.70476980e-02,  1.09613023e-03,\n          6.02579411e-02,  3.75920087e-03,  5.52907118e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  2.55042938e-02,\n         -4.09161744e-02,  2.21389967e-02, -1.40442055e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          2.55855390e-01, -1.47688450e-03, -3.09113272e-02],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  3.51959961e-02,  1.94439957e-03],\n        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n          0.00000000e+00,  0.00000000e+00,  5.09565862e-02]]),\n 'SigmaSqr': 29261.734711315305,\n 'Lambda': None,\n 'de_bounds': [[-3, 2], [-3, 2], [-3, 2]]}"
  },
  {
    "objectID": "07_spot_ei.html#expected-improvement",
    "href": "07_spot_ei.html#expected-improvement",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "8.1 Expected Improvement",
    "text": "8.1 Expected Improvement"
  },
  {
    "objectID": "07_spot_ei.html#example-spot-and-the-1-dim-sphere-function",
    "href": "07_spot_ei.html#example-spot-and-the-1-dim-sphere-function",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "8.2 1 Example: Spot and the 1-dim Sphere Function",
    "text": "8.2 1 Example: Spot and the 1-dim Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n8.2.1 The Objective Function: 1-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 \\]\n\n\nfun = analytical().fun_sphere\n\n\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use np.array([-1]), i.e., a one-dim function.\n\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]))\n\nspot_1.run()\n\n&lt;spotPython.spot.spot.Spot at 0x15215fd00&gt;\n\n\n\n\n8.2.2 Results\n\nspot_1.print_results()\n\nmin y: 3.696886711914087e-10\nx0: 1.922728975158508e-05\n\n\n[['x0', 1.922728975158508e-05]]\n\n\n\nspot_1.plot_progress(log_y=True)"
  },
  {
    "objectID": "07_spot_ei.html#same-but-with-ei-as-infill_criterion",
    "href": "07_spot_ei.html#same-but-with-ei-as-infill_criterion",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "8.3 2 Same, but with EI as infill_criterion",
    "text": "8.3 2 Same, but with EI as infill_criterion\n\nspot_1_ei = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   infill_criterion = \"ei\")\nspot_1_ei.run()\n\n&lt;spotPython.spot.spot.Spot at 0x15227f610&gt;\n\n\n\nspot_1_ei.plot_progress(log_y=True)\n\n\n\n\n\nspot_1_ei.print_results()\n\nmin y: 2.207887258868953e-10\nx0: 1.4858961130809088e-05\n\n\n[['x0', 1.4858961130809088e-05]]"
  },
  {
    "objectID": "07_spot_ei.html#init-build-initial-design",
    "href": "07_spot_ei.html#init-build-initial-design",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.1 1. Init: Build Initial Design",
    "text": "12.1 1. Init: Build Initial Design\n\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\ngen = spacefilling(2)\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\n\n[[ 8.97647221 13.41926847]\n [ 0.66946019  1.22344228]\n [ 5.23614115 13.78185824]\n [ 5.6149825  11.5851384 ]\n [-1.72963184  1.66516096]\n [-4.26945568  7.1325531 ]\n [ 1.26363761 10.17935555]\n [ 2.88779942  8.05508969]\n [-3.39111089  4.15213772]\n [ 7.30131231  5.22275244]]\n[128.95676449  31.73474356 172.89678121 126.71295908  64.34349975\n  70.16178611  48.71407916  31.77322887  76.91788181  30.69410529]\n\n\n\nS = Kriging(name='kriging',  seed=123)\nS.fit(X, y)\nS.plot()\n\n\n\n\n\ngen = spacefilling(2, seed=123)\nX0 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=345)\nX1 = gen.scipy_lhd(3)\nX2 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=123)\nX3 = gen.scipy_lhd(3)\nX0, X1, X2, X3\n\n(array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]),\n array([[0.78373509, 0.86811887],\n        [0.06692621, 0.6058029 ],\n        [0.41374778, 0.00525456]]),\n array([[0.121357  , 0.69043832],\n        [0.41906219, 0.32838498],\n        [0.86742658, 0.52910374]]),\n array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]))"
  },
  {
    "objectID": "07_spot_ei.html#evaluate",
    "href": "07_spot_ei.html#evaluate",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.2 2. Evaluate",
    "text": "12.2 2. Evaluate"
  },
  {
    "objectID": "07_spot_ei.html#build-surrogate",
    "href": "07_spot_ei.html#build-surrogate",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.3 3. Build Surrogate",
    "text": "12.3 3. Build Surrogate\n\n12.3.1 A Simple Predictor\nThe code below shows how to use a simple model for prediction.\n\nAssume that only two (very costly) measurements are available:\n\nf(0) = 0.5\nf(2) = 2.5\n\nWe are interested in the value at \\(x_0 = 1\\), i.e., \\(f(x_0 = 1)\\), but cannot run an additional, third experiment.\n\n\nfrom sklearn import linear_model\nX = np.array([[0], [2]])\ny = np.array([0.5, 2.5])\nS_lm = linear_model.LinearRegression()\nS_lm = S_lm.fit(X, y)\nX0 = np.array([[1]])\ny0 = S_lm.predict(X0)\nprint(y0)\n\n[1.5]\n\n\n\nCentral Idea:\n\nEvaluation of the surrogate model S_lm is much cheaper (or / and much faster) than running the real-world experiment \\(f\\).\n\n\n\n\n12.3.2 Gaussian Processes regression: basic introductory example\n\nExample from scikit-learn\nAfter fitting our model, we see that the hyperparameters of the kernel have been optimized. Now, we will use our kernel to compute the mean prediction of the full dataset and plot the 95% confidence interval.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\n\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\nrng = np.random.RandomState(1)\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\ngaussian_process = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\ngaussian_process.fit(X_train, y_train)\ngaussian_process.kernel_\n\nmean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"sk-learn Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\nrng = np.random.RandomState(1)\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\n\nS = Kriging(name='kriging',  seed=123, log_level=50, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nstd_prediction\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"spotPython Version: Gaussian process regression on noise-free dataset\")"
  },
  {
    "objectID": "07_spot_ei.html#the-surrogate-using-scikit-learn-models",
    "href": "07_spot_ei.html#the-surrogate-using-scikit-learn-models",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.4 The Surrogate: Using scikit-learn models",
    "text": "12.4 The Surrogate: Using scikit-learn models\n\nDefault is the internal kriging surrogate.\n\n\nS_0 = Kriging(name='kriging', seed=123)\n\n\nModels from scikit-learn can be selected, e.g., Gaussian Process:\n\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nand many more:\n\n\nS_Tree = DecisionTreeRegressor(random_state=0)\nS_LM = linear_model.LinearRegression()\nS_Ridge = linear_model.Ridge()\nS_RF = RandomForestRegressor(max_depth=2, random_state=0) \n\n\nThe scikit-learn GP model S_GP is selected.\n\n\nS = S_GP\n\n\nisinstance(S, GaussianProcessRegressor)\n\nTrue\n\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nfun = analytical().fun_branin\nlower = np.array([-5,-0])\nupper = np.array([10,15])\ndesign_control={\"init_size\": 5}\nsurrogate_control={\n            \"infill_criterion\": None,\n            \"n_points\": 1,\n        }\nspot_GP = spot.Spot(fun=fun, lower = lower, upper= upper, surrogate=S, \n                    fun_evals = 15, noise = False, log_level = 50,\n                    design_control=design_control,\n                    surrogate_control=surrogate_control)\n\nspot_GP.run()\n\n&lt;spotPython.spot.spot.Spot at 0x157c4dc60&gt;\n\n\n\nspot_GP.y\n\narray([ 69.32459936, 152.38491454, 107.92560483,  24.51465459,\n        76.73500031,  86.30426138,  11.00307851,  16.11742813,\n         7.28143761,  21.82315341,  10.96088904,   2.95197262,\n         3.02910062,   2.10498413,   1.94316438])\n\n\n\nspot_GP.plot_progress()\n\n\n\n\n\nspot_GP.print_results()\n\nmin y: 1.9431643796725862\nx0: 10.0\nx1: 2.9980866168483415\n\n\n[['x0', 10.0], ['x1', 2.9980866168483415]]"
  },
  {
    "objectID": "07_spot_ei.html#additional-examples",
    "href": "07_spot_ei.html#additional-examples",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.5 Additional Examples",
    "text": "12.5 Additional Examples\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\nS_K = Kriging(name='kriging',\n              seed=123,\n              log_level=50,\n              infill_criterion = \"y\",\n              n_theta=1,\n              noise=False,\n              cod_type=\"norm\")\nfun = analytical().fun_sphere\nlower = np.array([-1,-1])\nupper = np.array([1,1])\n\ndesign_control={\"init_size\": 10}\nsurrogate_control={\n            \"n_points\": 1,\n        }\nspot_S_K = spot.Spot(fun=fun,\n                     lower = lower,\n                     upper= upper,\n                     surrogate=S_K,\n                     fun_evals = 25,\n                     noise = False,\n                     log_level = 50,\n                     design_control=design_control,\n                     surrogate_control=surrogate_control)\n\nspot_S_K.run()\n\n&lt;spotPython.spot.spot.Spot at 0x15721a170&gt;\n\n\n\nspot_S_K.plot_progress(log_y=True)\n\n\n\n\n\nspot_S_K.surrogate.plot()\n\n\n\n\n\nspot_S_K.print_results()\n\nmin y: 1.7395335905335862e-06\nx0: -0.0013044072412622557\nx1: 0.0001950777780173277\n\n\n[['x0', -0.0013044072412622557], ['x1', 0.0001950777780173277]]"
  },
  {
    "objectID": "07_spot_ei.html#optimize-on-surrogate",
    "href": "07_spot_ei.html#optimize-on-surrogate",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.6 4. Optimize on Surrogate",
    "text": "12.6 4. Optimize on Surrogate"
  },
  {
    "objectID": "07_spot_ei.html#evaluate-on-real-objective",
    "href": "07_spot_ei.html#evaluate-on-real-objective",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.7 5. Evaluate on Real Objective",
    "text": "12.7 5. Evaluate on Real Objective"
  },
  {
    "objectID": "07_spot_ei.html#impute-infill-new-points",
    "href": "07_spot_ei.html#impute-infill-new-points",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "12.8 6. Impute / Infill new Points",
    "text": "12.8 6. Impute / Infill new Points"
  },
  {
    "objectID": "07_spot_ei.html#cubic-function",
    "href": "07_spot_ei.html#cubic-function",
    "title": "8  Introduction to Sequential Parameter Optimization",
    "section": "16.1 Cubic Function",
    "text": "16.1 Cubic Function\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 10,\n               \"seed\": 123}\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Cubed: Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[  -9.63480707  -72.98497325   12.7936499   895.34567477 -573.35961837\n  -41.83176425   65.27989461   46.37081417  254.1530734  -474.09587355]\n\n\n\n\n\n\nS = Kriging(name='kriging',  seed=123, log_level=0, n_theta=1, noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Cubed: Gaussian process with nugget regression on noisy dataset\")\n\n\n\n\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.25,\n               \"seed\": 123}\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[ 0.46517267 -0.03599548  1.15933822  0.05915901  0.24419145  0.21502359\n -0.10432134  0.21312309 -0.05502681 -0.06434374]\n\n\n\n\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression with nugget on noisy dataset\")"
  },
  {
    "objectID": "08_spot_noisy.html",
    "href": "08_spot_noisy.html",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "",
    "text": "10 2 Noise and Surrogates: The Nugget Effect"
  },
  {
    "objectID": "08_spot_noisy.html#noise",
    "href": "08_spot_noisy.html#noise",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "9.1 Noise",
    "text": "9.1 Noise\n\nThis notebook demonstrates how noisy functions can be handled by Spot."
  },
  {
    "objectID": "08_spot_noisy.html#example-spot-and-the-noisy-sphere-function",
    "href": "08_spot_noisy.html#example-spot-and-the-noisy-sphere-function",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "9.2 1 Example: Spot and the Noisy Sphere Function",
    "text": "9.2 1 Example: Spot and the Noisy Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n9.2.1 The Objective Function: Noisy Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function with noise, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 + \\epsilon\\]\nSince sigma is set to 0.1, noise is added to the function:\n\n\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 0.1,\n               \"seed\": 123}\n\n\nA plot illustrates the noise:\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x, fun_control=fun_control)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\n\n\nSpot is adopted as follows to cope with noisy functions:\n\nfun_repeats is set to a value larger than 1 (here: 2)\nnoise is set to true. Therefore, a nugget (Lambda) term is added to the correlation matrix\ninit size (of the design_control dictionary) is set to a value larger than 1 (here: 2)\n\n\nspot_1_noisy = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   fun_evals = 10,\n                   fun_repeats = 2,\n                   noise = True,\n                   seed=123,\n                   show_models=True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": 3,\n                                   \"repeats\": 2},\n                   surrogate_control={\"noise\": True})\n\n\nspot_1_noisy.run()\n\n\n\n\n\n\n\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16a26b370&gt;"
  },
  {
    "objectID": "08_spot_noisy.html#print-the-results",
    "href": "08_spot_noisy.html#print-the-results",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "9.3 Print the Results",
    "text": "9.3 Print the Results\n\nspot_1_noisy.print_results()\n\nmin y: -0.06415721594238855\nx0: 0.18642671238960512\nmin mean y: -0.03309048099839016\nx0: 0.18642671238960512\n\n\n[['x0', 0.18642671238960512], ['x0', 0.18642671238960512]]\n\n\n\nspot_1_noisy.plot_progress(log_y=False)"
  },
  {
    "objectID": "08_spot_noisy.html#the-noisy-sphere",
    "href": "08_spot_noisy.html#the-noisy-sphere",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "10.1 2.1 The Noisy Sphere",
    "text": "10.1 2.1 The Noisy Sphere\n\n10.1.1 The Data\n\nWe prepare some data first:\n\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 2,\n               \"seed\": 125}\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\ny = fun(X, fun_control=fun_control)\nX_train = X.reshape(-1,1)\ny_train = y\n\n\nA surrogate without nugget is fitted to these data:\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n\n\n\n\nIn comparison to the surrogate without nugget, we fit a surrogate with nugget to the data:\n\n\nS_nug = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS_nug.fit(X_train, y_train)\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S_nug.predict(X_axis, return_val=\"all\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\n\n\n\n\n\nThe value of the nugget term can be extracted from the model as follows:\n\n\nS.Lambda\n\n\nS_nug.Lambda\n\n9.088150066416743e-05\n\n\n\nWe see:\n\nthe first model S has no nugget,\nwhereas the second model has a nugget value (Lambda) larger than zero."
  },
  {
    "objectID": "08_spot_noisy.html#exercise-1",
    "href": "08_spot_noisy.html#exercise-1",
    "title": "9  Introduction to Sequential Parameter Optimization",
    "section": "11.1 Exercise 1",
    "text": "11.1 Exercise 1\n\nEach team member should choose one of the following optimization algorithms.\nPlease add your name to the section title!\n\n\n11.1.1 1. Noisy fun_cubed\n\nAnalyse the effect of noise on the fun_cubed function with the following settings:\n\n\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 10,\n               \"seed\": 123}\nlower = np.array([-10])\nupper = np.array([10])\n\n\n\n11.1.2 2. fun_runge\n\nAnalyse the effect of noise on the fun_runge function with the following settings:\n\n\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.25,\n               \"seed\": 123}\n\n\n\n11.1.3 3. fun_forrester\n\nAnalyse the effect of noise on the fun_forrester function with the following settings:\n\n\nlower = np.array([0])\nupper = np.array([1])\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 5,\n               \"seed\": 123}\n\n\n\n11.1.4 4. fun_xsin\n\nAnalyse the effect of noise on the fun_xsin function with the following settings:\n\n\nlower = np.array([-1.])\nupper = np.array([1.])\nfun = analytical().fun_xsin\nfun_control = {\"sigma\": 0.5,\n               \"seed\": 123}"
  },
  {
    "objectID": "09_spot_ocba.html",
    "href": "09_spot_ocba.html",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "",
    "text": "11 2 Noise and Surrogates: The Nugget Effect"
  },
  {
    "objectID": "09_spot_ocba.html#noise",
    "href": "09_spot_ocba.html#noise",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "10.1 Noise",
    "text": "10.1 Noise\n\nThis notebook demonstrates how noisy functions can be handled with OCBA by Spot."
  },
  {
    "objectID": "09_spot_ocba.html#example-spot-ocba-and-the-noisy-sphere-function",
    "href": "09_spot_ocba.html#example-spot-ocba-and-the-noisy-sphere-function",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "10.2 1 Example: Spot, OCBA, and the Noisy Sphere Function",
    "text": "10.2 1 Example: Spot, OCBA, and the Noisy Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n10.2.1 The Objective Function: Noisy Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function with noise, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 + \\epsilon\\]\nSince sigma is set to 0.1, noise is added to the function:\n\n\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 0.1,\n               \"seed\": 123}\n\n\nA plot illustrates the noise:\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x, fun_control=fun_control)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\n\n\nSpot is adopted as follows to cope with noisy functions:\n\nfun_repeats is set to a value larger than 1 (here: 2)\nnoise is set to true. Therefore, a nugget (Lambda) term is added to the correlation matrix\ninit size (of the design_control dictionary) is set to a value larger than 1 (here: 2)\n\n\nspot_1_noisy = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   fun_evals = 50,\n                   fun_repeats = 2,\n                   infill_criterion=\"ei\",\n                   noise = True,\n                   tolerance_x=0.0,\n                   ocba_delta = 1,\n                   seed=123,\n                   show_models=True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": 3,\n                                   \"repeats\": 2},\n                   surrogate_control={\"noise\": True})\n\n\nspot_1_noisy.run()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x29c8e99c0&gt;"
  },
  {
    "objectID": "09_spot_ocba.html#print-the-results",
    "href": "09_spot_ocba.html#print-the-results",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "10.3 Print the Results",
    "text": "10.3 Print the Results\n\nspot_1_noisy.print_results()\n\nmin y: -0.08106318979661208\nx0: 0.1335999447536301\nmin mean y: -0.06294830660588041\nx0: 0.1335999447536301\n\n\n[['x0', 0.1335999447536301], ['x0', 0.1335999447536301]]\n\n\n\nspot_1_noisy.plot_progress(log_y=False)"
  },
  {
    "objectID": "09_spot_ocba.html#the-noisy-sphere",
    "href": "09_spot_ocba.html#the-noisy-sphere",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "11.1 2.1 The Noisy Sphere",
    "text": "11.1 2.1 The Noisy Sphere\n\n11.1.1 The Data\n\nWe prepare some data first:\n\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 2,\n               \"seed\": 125}\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\ny = fun(X, fun_control=fun_control)\nX_train = X.reshape(-1,1)\ny_train = y\n\n\nA surrogate without nugget is fitted to these data:\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n\n\n\n\nIn comparison to the surrogate without nugget, we fit a surrogate with nugget to the data:\n\n\nS_nug = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS_nug.fit(X_train, y_train)\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S_nug.predict(X_axis, return_val=\"all\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\n\n\n\n\n\nThe value of the nugget term can be extracted from the model as follows:\n\n\nS.Lambda\n\n\nS_nug.Lambda\n\n9.088150066416743e-05\n\n\n\nWe see:\n\nthe first model S has no nugget,\nwhereas the second model has a nugget value (Lambda) larger than zero."
  },
  {
    "objectID": "09_spot_ocba.html#exercise-1",
    "href": "09_spot_ocba.html#exercise-1",
    "title": "10  Introduction to Sequential Parameter Optimization",
    "section": "12.1 Exercise 1",
    "text": "12.1 Exercise 1\n\nEach team member should choose one of the following optimization algorithms.\nPlease add your name to the section title!\n\n\n12.1.1 1. Noisy fun_cubed\n\nAnalyse the effect of noise on the fun_cubed function with the following settings:\n\n\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 10,\n               \"seed\": 123}\nlower = np.array([-10])\nupper = np.array([10])\n\n\n\n12.1.2 2. fun_runge\n\nAnalyse the effect of noise on the fun_runge function with the following settings:\n\n\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.25,\n               \"seed\": 123}\n\n\n\n12.1.3 3. fun_forrester\n\nAnalyse the effect of noise on the fun_forrester function with the following settings:\n\n\nlower = np.array([0])\nupper = np.array([1])\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 5,\n               \"seed\": 123}\n\n\n\n12.1.4 4. fun_xsin\n\nAnalyse the effect of noise on the fun_xsin function with the following settings:\n\n\nlower = np.array([-1.])\nupper = np.array([1.])\nfun = analytical().fun_xsin\nfun_control = {\"sigma\": 0.5,\n               \"seed\": 123}\n\n\nspot_1_noisy.mean_y.shape[0]\n\n18"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#hyperparameter-tuning-sklearn",
    "href": "10_spot_hpt_sklearn_classification.html#hyperparameter-tuning-sklearn",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.1 Hyperparameter Tuning: sklearn",
    "text": "11.1 Hyperparameter Tuning: sklearn\n\nThis notebook exemplifies hyperparameter tuning with SPOT (spotPython).\nThe hyperparameter software SPOT was developed in R (statistical programming language), see Open Access book “Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide”, available here: https://link.springer.com/book/10.1007/978-981-19-5170-1.\n\n\npip list | grep  \"spot[RiverPython]\"\n\n\n# import sys\n# !{sys.executable} -m pip install --upgrade build\n# !{sys.executable} -m pip install --upgrade --force-reinstall spotPython\n\n\nfrom tabulate import tabulate\nimport warnings\nimport numpy as np\nfrom math import inf\nimport pandas as pd\n\nfrom scipy.optimize import differential_evolution\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.preprocessing import OneHotEncoder , MinMaxScaler, StandardScaler\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.pipeline import make_pipeline , Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import HistGradientBoostingRegressor\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.datasets import fetch_openml\nfrom sklearn.metrics import mean_absolute_error, accuracy_score, roc_curve, roc_auc_score, log_loss, mean_squared_error\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.datasets import make_regression\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_moons, make_circles, make_classification\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.linear_model import ElasticNet\n\nwarnings.filterwarnings(\"ignore\")\n\nfrom spotPython.spot import spot\nfrom spotPython.hyperparameters.values import (\n    add_core_model_to_fun_control,\n    assign_values,\n    convert_keys,\n    get_bound_values,\n    get_default_hyperparameters_for_core_model,\n    get_default_values,\n    get_dict_with_levels_and_types,\n    get_values_from_dict,\n    get_var_name,\n    get_var_type,\n    iterate_dict_values,\n    modify_hyper_parameter_levels,\n    modify_hyper_parameter_bounds,\n    replace_levels_with_positions,\n    return_conf_list_from_var_dict,\n    get_one_core_model_from_X,\n    transform_hyper_parameter_values,\n    get_dict_with_levels_and_types,\n    convert_keys,\n    iterate_dict_values,\n    get_one_sklearn_model_from_X\n)\n\nfrom spotPython.utils.convert import class_for_name\nfrom spotPython.utils.eda import (\n    get_stars,\n    gen_design_table)\nfrom spotPython.utils.transform import transform_hyper_parameter_values\nfrom spotPython.utils.convert import get_Xy_from_df\nfrom spotPython.plot.validation import plot_cv_predictions, plot_roc, plot_confusion_matrix\nfrom spotPython.utils.init import fun_control_init\n\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfrom spotPython.utils.metrics import mapk, apk"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#initialization-of-the-empty-fun_control-dictionary",
    "href": "10_spot_hpt_sklearn_classification.html#initialization-of-the-empty-fun_control-dictionary",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.2 0. Initialization of the Empty fun_control Dictionary",
    "text": "11.2 0. Initialization of the Empty fun_control Dictionary\n\nfun_control = fun_control_init(task=\"classification\",\n    tensorboard_path=\"runs/10_spot_hpt_sklearn_classification\")"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#load-data-classification",
    "href": "10_spot_hpt_sklearn_classification.html#load-data-classification",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.3 1. Load Data: Classification",
    "text": "11.3 1. Load Data: Classification\n\nRandomly generate classification data.\n\n\nn_features = 2\nn_samples = 250\ntarget_column = \"y\"\nds =  make_moons(n_samples, noise=0.5, random_state=0)\nX, y = ds\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.4, random_state=42\n)\ntrain = pd.DataFrame(np.hstack((X_train, y_train.reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, y_test.reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntrain.head()\n\n\nfrom matplotlib.colors import ListedColormap\nx_min, x_max = X[:, 0].min() - 0.5, X[:, 0].max() + 0.5\ny_min, y_max = X[:, 1].min() - 0.5, X[:, 1].max() + 0.5\n\n# just plot the dataset first\ncm = plt.cm.RdBu\ncm_bright = ListedColormap([\"#FF0000\", \"#0000FF\"])\nax = plt.subplot(1, 1, 1)\nax.set_title(\"Input data\")\n# Plot the training points\nax.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap=cm_bright, edgecolors=\"k\")\n# Plot the testing points\nax.scatter(\n    X_test[:, 0], X_test[:, 1], c=y_test, cmap=cm_bright, alpha=0.6, edgecolors=\"k\"\n)\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\nax.set_xticks(())\nax.set_yticks(())\n\nplt.tight_layout()\nplt.show()\n\n\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\"data\": None, # dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#specification-of-the-preprocessing-model",
    "href": "10_spot_hpt_sklearn_classification.html#specification-of-the-preprocessing-model",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.4 2. Specification of the Preprocessing Model",
    "text": "11.4 2. Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\nprep_model = StandardScaler()\nfun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#select-algorithm-and-core_model_hyper_dict",
    "href": "10_spot_hpt_sklearn_classification.html#select-algorithm-and-core_model_hyper_dict",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.5 3. Select algorithm and core_model_hyper_dict",
    "text": "11.5 3. Select algorithm and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\n# core_model = RandomForestClassifier\ncore_model = SVC\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file:\n    \"SVC\":\n    {\n        \"C\": {\n            \"type\": \"float\",\n            \"default\": 1.0,\n            \"transform\": \"None\",\n            \"lower\": 0.1,\n            \"upper\": 10.0},\n        \"kernel\": {\n            \"levels\": [\"linear\", \"poly\", \"rbf\", \"sigmoid\"],\n            \"type\": \"factor\",\n            \"default\": \"rbf\",\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 3},\n        \"degree\": {\n            \"type\": \"int\",\n            \"default\": 3,\n            \"transform\": \"None\",\n            \"lower\": 3,\n            \"upper\": 3},\n        \"gamma\": {\n            \"levels\": [\"scale\", \"auto\"],\n            \"type\": \"factor\",\n            \"default\": \"scale\",\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"coef0\": {\n            \"type\": \"float\",\n            \"default\": 0.0,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 0.0},\n        \"shrinking\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"probability\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"tol\": {\n            \"type\": \"float\",\n            \"default\": 1e-3,\n            \"transform\": \"None\",\n            \"lower\": 1e-4,\n            \"upper\": 1e-2},\n        \"cache_size\": {\n            \"type\": \"float\",\n            \"default\": 200,\n            \"transform\": \"None\",\n            \"lower\": 100,\n            \"upper\": 400},\n        \"break_ties\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1}\n    }"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "10_spot_hpt_sklearn_classification.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "11.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n11.6.1 Modify hyperparameter of type factor\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"poly\", \"rbf\"])\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\n\n\n11.6.2 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\n\nfun_control = modify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n# fun_control = modify_hyper_parameter_bounds(fun_control, \"min_samples_split\", bounds=[3, 20])\n#fun_control = modify_hyper_parameter_bounds(fun_control, \"merit_preprune\", bounds=[0, 0])\nfun_control[\"core_model_hyper_dict\"][\"tol\"]"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#selection-of-the-objective-loss-function",
    "href": "10_spot_hpt_sklearn_classification.html#selection-of-the-objective-loss-function",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.7 5. Selection of the Objective (Loss) Function",
    "text": "11.7 5. Selection of the Objective (Loss) Function\nThere are two metrics:\n1. `metric_river` is used for the river based evaluation via `eval_oml_iter_progressive`.\n2. `metric_sklearn` is used for the sklearn based evaluation.\n\nfun = HyperSklearn(seed=123, log_level=50).fun_sklearn\n# metric_sklearn = roc_auc_score\n# weights = -1.0\nmetric_sklearn = log_loss\nweights = 1.0\n# k = None\n# custom_metric = mapk\n\nfun_control.update({\n               \"horizon\": None,\n               \"oml_grace_period\": None,\n               \"weights\": weights,\n               \"step\": None,\n               \"log_level\": 50,\n               \"weight_coeff\": None,\n               \"metric_river\": None,\n               \"metric_sklearn\": metric_sklearn,\n               # \"metric_params\": {\"k\": k},\n               })\n\n\n11.7.1 Predict Classes or Class Probabilities\nIf the key \"predict_proba\" is set to True, the class probabilities are predicted. False is the default, i.e., the classes are predicted.\n\nfun_control.update({\n               \"predict_proba\": False,\n               })"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#calling-the-spot-function",
    "href": "10_spot_hpt_sklearn_classification.html#calling-the-spot-function",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.8 6. Calling the SPOT Function",
    "text": "11.8 6. Calling the SPOT Function\n\n11.8.1 Prepare the SPOT Parameters\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nfun_control.update({\"var_type\": var_type,\n                    \"var_name\": var_name})\n\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nprint(gen_design_table(fun_control))\n\n\n\n11.8.2 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nhyper_dict=SklearnHyperDict().load()\nX_start = get_default_hyperparameters_as_array(fun_control, hyper_dict)\nX_start\n\n\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\n\n\n11.8.3 4 Results\n\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"res_ch10-friedman-hpt-0_maans03_60min_20init_1K_2023-04-14_10-11-19.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)\n\n\nShow the Progress of the hyperparameter tuning:\n\n\nspot_tuner.plot_progress(log_y=False, filename=\"../Figures.d/\" + experiment_name+\"_progress.pdf\")\n\n\nPrint the Results\n\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#show-variable-importance",
    "href": "10_spot_hpt_sklearn_classification.html#show-variable-importance",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.9 Show variable importance",
    "text": "11.9 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"../Figures.d/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#get-default-hyperparameters",
    "href": "10_spot_hpt_sklearn_classification.html#get-default-hyperparameters",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.10 Get Default Hyperparameters",
    "text": "11.10 Get Default Hyperparameters\n\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#get-spot-results",
    "href": "10_spot_hpt_sklearn_classification.html#get-spot-results",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.11 Get SPOT Results",
    "text": "11.11 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#plot-compare-predictions",
    "href": "10_spot_hpt_sklearn_classification.html#plot-compare-predictions",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.12 Plot: Compare Predictions",
    "text": "11.12 Plot: Compare Predictions\n\nplot_roc([model_default, model_spot], fun_control, model_names=[\"Default\", \"Spot\"])\n\n\nplot_confusion_matrix(model_default, fun_control, title = \"Default\")\n\n\nplot_confusion_matrix(model_spot, fun_control, title=\"SPOT\")\n\n\nmin(spot_tuner.y), max(spot_tuner.y)"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#detailed-hyperparameter-plots",
    "href": "10_spot_hpt_sklearn_classification.html#detailed-hyperparameter-plots",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.13 Detailed Hyperparameter Plots",
    "text": "11.13 Detailed Hyperparameter Plots\n\nFor productive use, you might want to select:\n\nmin_z=min(spot_tuner.y) and\nmax_z = max(spot_tuner.y)\n\nThese settings are not so colorful as visualizations that use None for the ranges, but give better insights.\n\n\nthreshold = 0.025\nimpo = spot_tuner.print_importance(threshold=threshold, print_screen=True)\nvar_plots = [i for i, x in enumerate(impo) if x[1] &gt; threshold]\nmin_z = min(spot_tuner.y)\nmax_z = max(spot_tuner.y)\nn = spot_tuner.k\nfor i in var_plots:\n    for j in var_plots:\n        if j &gt; i:\n            filename = \"../Figures.d/\" + experiment_name+\"_contour_\"+str(i)+\"_\"+str(j)+\".pdf\"\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z, filename=filename)"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#parallel-coordinates-plot",
    "href": "10_spot_hpt_sklearn_classification.html#parallel-coordinates-plot",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.14 Parallel Coordinates Plot",
    "text": "11.14 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#plot-all-combinations-of-hyperparameters",
    "href": "10_spot_hpt_sklearn_classification.html#plot-all-combinations-of-hyperparameters",
    "title": "11  Chapter 10: Sequential Parameter Optimization",
    "section": "11.15 Plot all Combinations of Hyperparameters",
    "text": "11.15 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#hyperparameter-tuning-sklearn",
    "href": "11_spot_hpt_torch_fashion_mnist.html#hyperparameter-tuning-sklearn",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.1 Hyperparameter Tuning: sklearn",
    "text": "12.1 Hyperparameter Tuning: sklearn\n\nThis notebook exemplifies hyperparameter tuning with SPOT (spotPython).\nThe hyperparameter software SPOT was developed in R (statistical programming language), see Open Access book “Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide”, available here: https://link.springer.com/book/10.1007/978-981-19-5170-1.\n\n\npip list | grep  \"spot[RiverPython]\"\n\n\n# import sys\n# !{sys.executable} -m pip install --upgrade build\n# !{sys.executable} -m pip install --upgrade --force-reinstall spotPython\n\n\nfrom tabulate import tabulate\nimport warnings\nimport numpy as np\nfrom math import inf\nimport pandas as pd\n\nfrom scipy.optimize import differential_evolution\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.preprocessing import OneHotEncoder , MinMaxScaler, StandardScaler\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.pipeline import make_pipeline , Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import HistGradientBoostingRegressor\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.datasets import fetch_openml\nfrom sklearn.metrics import mean_absolute_error, accuracy_score, roc_curve, roc_auc_score, log_loss, mean_squared_error\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.datasets import make_regression\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_moons, make_circles, make_classification\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.linear_model import ElasticNet\n\nwarnings.filterwarnings(\"ignore\")\n\nfrom spotPython.spot import spot\nfrom spotPython.hyperparameters.values import (\n    add_core_model_to_fun_control,\n    assign_values,\n    convert_keys,\n    get_bound_values,\n    get_default_hyperparameters_for_core_model,\n    get_default_values,\n    get_dict_with_levels_and_types,\n    get_values_from_dict,\n    get_var_name,\n    get_var_type,\n    iterate_dict_values,\n    modify_hyper_parameter_levels,\n    modify_hyper_parameter_bounds,\n    replace_levels_with_positions,\n    return_conf_list_from_var_dict,\n    get_one_core_model_from_X,\n    transform_hyper_parameter_values,\n    get_dict_with_levels_and_types,\n    convert_keys,\n    iterate_dict_values,\n    get_one_sklearn_model_from_X\n)\n\nfrom spotPython.utils.convert import class_for_name\nfrom spotPython.utils.eda import (\n    get_stars,\n    gen_design_table)\nfrom spotPython.utils.transform import transform_hyper_parameter_values\nfrom spotPython.utils.convert import get_Xy_from_df\nfrom spotPython.plot.validation import plot_cv_predictions, plot_roc, plot_confusion_matrix\nfrom spotPython.utils.init import fun_control_init\n\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfrom spotPython.utils.metrics import mapk, apk"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#initialization-of-the-empty-fun_control-dictionary",
    "href": "11_spot_hpt_torch_fashion_mnist.html#initialization-of-the-empty-fun_control-dictionary",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.2 0. Initialization of the Empty fun_control Dictionary",
    "text": "12.2 0. Initialization of the Empty fun_control Dictionary\n\nfun_control = fun_control_init(task=\"classification\",\n    tensorboard_path=\"runs/10_spot_hpt_sklearn_classification\")"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#load-data-classification",
    "href": "11_spot_hpt_torch_fashion_mnist.html#load-data-classification",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.3 1. Load Data: Classification",
    "text": "12.3 1. Load Data: Classification\n\nRandomly generate classification data.\n\n\nn_features = 2\nn_samples = 250\ntarget_column = \"y\"\nds =  make_moons(n_samples, noise=0.5, random_state=0)\nX, y = ds\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.4, random_state=42\n)\ntrain = pd.DataFrame(np.hstack((X_train, y_train.reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, y_test.reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntrain.head()\n\n\nfrom matplotlib.colors import ListedColormap\nx_min, x_max = X[:, 0].min() - 0.5, X[:, 0].max() + 0.5\ny_min, y_max = X[:, 1].min() - 0.5, X[:, 1].max() + 0.5\n\n# just plot the dataset first\ncm = plt.cm.RdBu\ncm_bright = ListedColormap([\"#FF0000\", \"#0000FF\"])\nax = plt.subplot(1, 1, 1)\nax.set_title(\"Input data\")\n# Plot the training points\nax.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap=cm_bright, edgecolors=\"k\")\n# Plot the testing points\nax.scatter(\n    X_test[:, 0], X_test[:, 1], c=y_test, cmap=cm_bright, alpha=0.6, edgecolors=\"k\"\n)\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\nax.set_xticks(())\nax.set_yticks(())\n\nplt.tight_layout()\nplt.show()\n\n\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\"data\": None, # dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#specification-of-the-preprocessing-model",
    "href": "11_spot_hpt_torch_fashion_mnist.html#specification-of-the-preprocessing-model",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.4 2. Specification of the Preprocessing Model",
    "text": "12.4 2. Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\nprep_model = StandardScaler()\nfun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#select-algorithm-and-core_model_hyper_dict",
    "href": "11_spot_hpt_torch_fashion_mnist.html#select-algorithm-and-core_model_hyper_dict",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.5 3. Select algorithm and core_model_hyper_dict",
    "text": "12.5 3. Select algorithm and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\n# core_model = RandomForestClassifier\ncore_model = SVC\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file:\n    \"SVC\":\n    {\n        \"C\": {\n            \"type\": \"float\",\n            \"default\": 1.0,\n            \"transform\": \"None\",\n            \"lower\": 0.1,\n            \"upper\": 10.0},\n        \"kernel\": {\n            \"levels\": [\"linear\", \"poly\", \"rbf\", \"sigmoid\"],\n            \"type\": \"factor\",\n            \"default\": \"rbf\",\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 3},\n        \"degree\": {\n            \"type\": \"int\",\n            \"default\": 3,\n            \"transform\": \"None\",\n            \"lower\": 3,\n            \"upper\": 3},\n        \"gamma\": {\n            \"levels\": [\"scale\", \"auto\"],\n            \"type\": \"factor\",\n            \"default\": \"scale\",\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"coef0\": {\n            \"type\": \"float\",\n            \"default\": 0.0,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 0.0},\n        \"shrinking\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"probability\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1},\n        \"tol\": {\n            \"type\": \"float\",\n            \"default\": 1e-3,\n            \"transform\": \"None\",\n            \"lower\": 1e-4,\n            \"upper\": 1e-2},\n        \"cache_size\": {\n            \"type\": \"float\",\n            \"default\": 200,\n            \"transform\": \"None\",\n            \"lower\": 100,\n            \"upper\": 400},\n        \"break_ties\": {\n            \"levels\": [0, 1],\n            \"type\": \"factor\",\n            \"default\": 0,\n            \"transform\": \"None\",\n            \"core_model_parameter_type\": \"bool\",\n            \"lower\": 0,\n            \"upper\": 1}\n    }"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "11_spot_hpt_torch_fashion_mnist.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "12.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n12.6.1 Modify hyperparameter of type factor\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"poly\", \"rbf\"])\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\n\n\n12.6.2 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\n\nfun_control = modify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n# fun_control = modify_hyper_parameter_bounds(fun_control, \"min_samples_split\", bounds=[3, 20])\n#fun_control = modify_hyper_parameter_bounds(fun_control, \"merit_preprune\", bounds=[0, 0])\nfun_control[\"core_model_hyper_dict\"][\"tol\"]"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#selection-of-the-objective-loss-function",
    "href": "11_spot_hpt_torch_fashion_mnist.html#selection-of-the-objective-loss-function",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.7 5. Selection of the Objective (Loss) Function",
    "text": "12.7 5. Selection of the Objective (Loss) Function\nThere are two metrics:\n1. `metric_river` is used for the river based evaluation via `eval_oml_iter_progressive`.\n2. `metric_sklearn` is used for the sklearn based evaluation.\n\nfun = HyperSklearn(seed=123, log_level=50).fun_sklearn\n# metric_sklearn = roc_auc_score\n# weights = -1.0\nmetric_sklearn = log_loss\nweights = 1.0\n# k = None\n# custom_metric = mapk\n\nfun_control.update({\n               \"horizon\": None,\n               \"oml_grace_period\": None,\n               \"weights\": weights,\n               \"step\": None,\n               \"log_level\": 50,\n               \"weight_coeff\": None,\n               \"metric_river\": None,\n               \"metric_sklearn\": metric_sklearn,\n               # \"metric_params\": {\"k\": k},\n               })\n\n\n12.7.1 Predict Classes or Class Probabilities\nIf the key \"predict_proba\" is set to True, the class probabilities are predicted. False is the default, i.e., the classes are predicted.\n\nfun_control.update({\n               \"predict_proba\": False,\n               })"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#calling-the-spot-function",
    "href": "11_spot_hpt_torch_fashion_mnist.html#calling-the-spot-function",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.8 6. Calling the SPOT Function",
    "text": "12.8 6. Calling the SPOT Function\n\n12.8.1 Prepare the SPOT Parameters\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nfun_control.update({\"var_type\": var_type,\n                    \"var_name\": var_name})\n\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nprint(gen_design_table(fun_control))\n\n\n\n12.8.2 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nhyper_dict=SklearnHyperDict().load()\nX_start = get_default_hyperparameters_as_array(fun_control, hyper_dict)\nX_start\n\n\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\n\n\n12.8.3 4 Results\n\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"res_ch10-friedman-hpt-0_maans03_60min_20init_1K_2023-04-14_10-11-19.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)\n\n\nShow the Progress of the hyperparameter tuning:\n\n\nspot_tuner.plot_progress(log_y=False, filename=\"../Figures.d/\" + experiment_name+\"_progress.pdf\")\n\n\nPrint the Results\n\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#show-variable-importance",
    "href": "11_spot_hpt_torch_fashion_mnist.html#show-variable-importance",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.9 Show variable importance",
    "text": "12.9 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"../Figures.d/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#get-default-hyperparameters",
    "href": "11_spot_hpt_torch_fashion_mnist.html#get-default-hyperparameters",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.10 Get Default Hyperparameters",
    "text": "12.10 Get Default Hyperparameters\n\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#get-spot-results",
    "href": "11_spot_hpt_torch_fashion_mnist.html#get-spot-results",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.11 Get SPOT Results",
    "text": "12.11 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#plot-compare-predictions",
    "href": "11_spot_hpt_torch_fashion_mnist.html#plot-compare-predictions",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.12 Plot: Compare Predictions",
    "text": "12.12 Plot: Compare Predictions\n\nplot_roc([model_default, model_spot], fun_control, model_names=[\"Default\", \"Spot\"])\n\n\nplot_confusion_matrix(model_default, fun_control, title = \"Default\")\n\n\nplot_confusion_matrix(model_spot, fun_control, title=\"SPOT\")\n\n\nmin(spot_tuner.y), max(spot_tuner.y)"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#detailed-hyperparameter-plots",
    "href": "11_spot_hpt_torch_fashion_mnist.html#detailed-hyperparameter-plots",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.13 Detailed Hyperparameter Plots",
    "text": "12.13 Detailed Hyperparameter Plots\n\nFor productive use, you might want to select:\n\nmin_z=min(spot_tuner.y) and\nmax_z = max(spot_tuner.y)\n\nThese settings are not so colorful as visualizations that use None for the ranges, but give better insights.\n\n\nthreshold = 0.025\nimpo = spot_tuner.print_importance(threshold=threshold, print_screen=True)\nvar_plots = [i for i, x in enumerate(impo) if x[1] &gt; threshold]\nmin_z = min(spot_tuner.y)\nmax_z = max(spot_tuner.y)\nn = spot_tuner.k\nfor i in var_plots:\n    for j in var_plots:\n        if j &gt; i:\n            filename = \"../Figures.d/\" + experiment_name+\"_contour_\"+str(i)+\"_\"+str(j)+\".pdf\"\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z, filename=filename)"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#parallel-coordinates-plot",
    "href": "11_spot_hpt_torch_fashion_mnist.html#parallel-coordinates-plot",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.14 Parallel Coordinates Plot",
    "text": "12.14 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "11_spot_hpt_torch_fashion_mnist.html#plot-all-combinations-of-hyperparameters",
    "href": "11_spot_hpt_torch_fashion_mnist.html#plot-all-combinations-of-hyperparameters",
    "title": "12  Chapter 10: Sequential Parameter Optimization",
    "section": "12.15 Plot all Combinations of Hyperparameters",
    "text": "12.15 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#hyperparameter-tuning-pytorch-wth-cifar10-data",
    "href": "12_spot_hpt_torch_cifar10.html#hyperparameter-tuning-pytorch-wth-cifar10-data",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.1 Hyperparameter Tuning: pytorch wth cifar10 Data",
    "text": "13.1 Hyperparameter Tuning: pytorch wth cifar10 Data\n\nThis notebook exemplifies hyperparameter tuning with SPOT (spotPython).\nThe hyperparameter software SPOT was developed in R (statistical programming language), see Open Access book “Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide”, available here: https://link.springer.com/book/10.1007/978-981-19-5170-1.\n\n\npip list | grep  \"spot[RiverPython]\"\n\n\n# import sys\n# !{sys.executable} -m pip install --upgrade build\n# !{sys.executable} -m pip install --upgrade --force-reinstall spotPython\n\n\nfrom tabulate import tabulate\nimport copy\nimport warnings\nimport numbers\nimport json\nimport calendar\nimport math\nimport datetime as dt\nimport numpy as np\nfrom math import inf\nimport pandas as pd\n\nfrom scipy.optimize import differential_evolution\n\nimport matplotlib.pyplot as plt\n\nfrom functools import partial\n\nimport torch\nfrom torch import nn\nfrom torch.utils.data import DataLoader\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import random_split\nfrom torchvision import datasets\nimport torchvision\nimport torchvision.transforms as transforms\nfrom torchvision.transforms import ToTensor\n\nfrom spotPython.spot import spot\nfrom spotPython.hyperparameters.values import (\n    add_core_model_to_fun_control,\n    assign_values,\n    convert_keys,\n    get_bound_values,\n    get_default_hyperparameters_for_core_model,\n    get_default_values,\n    get_dict_with_levels_and_types,\n    get_values_from_dict,\n    get_var_name,\n    get_var_type,\n    iterate_dict_values,\n    modify_hyper_parameter_levels,\n    modify_hyper_parameter_bounds,\n    replace_levels_with_positions,\n    return_conf_list_from_var_dict,\n    get_one_core_model_from_X,\n    transform_hyper_parameter_values,\n    get_dict_with_levels_and_types,\n    convert_keys,\n    iterate_dict_values,\n)\n\nfrom spotPython.torch.traintest import evaluate_cv, evaluate_hold_out\nfrom spotPython.utils.convert import class_for_name\nfrom spotPython.utils.eda import (\n    get_stars,\n    gen_design_table)\nfrom spotPython.utils.transform import transform_hyper_parameter_values\nfrom spotPython.utils.convert import get_Xy_from_df\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.plot.validation import plot_cv_predictions, plot_roc, plot_confusion_matrix\n\nfrom spotPython.data.torch_hyper_dict import TorchHyperDict\nfrom spotPython.fun.hypertorch import HyperTorch\n\nwarnings.filterwarnings(\"ignore\")\n\nfrom spotPython.torch.netcifar10 import Net_CIFAR10\n\n\nprint(torch.__version__)\n# Check that MPS is available\nif not torch.backends.mps.is_available():\n    if not torch.backends.mps.is_built():\n        print(\"MPS not available because the current PyTorch install was not \"\n              \"built with MPS enabled.\")\n    else:\n        print(\"MPS not available because the current MacOS version is not 12.3+ \"\n              \"and/or you do not have an MPS-enabled device on this machine.\")\n\nelse:\n    mps_device = torch.device(\"mps\")\n    print(\"MPS device: \", mps_device)"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#initialization-of-the-empty-fun_control-dictionary",
    "href": "12_spot_hpt_torch_cifar10.html#initialization-of-the-empty-fun_control-dictionary",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.2 0. Initialization of the Empty fun_control Dictionary",
    "text": "13.2 0. Initialization of the Empty fun_control Dictionary\n\nfun_control = fun_control_init(task=\"classification\")"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#load-data-cifar10-data",
    "href": "12_spot_hpt_torch_cifar10.html#load-data-cifar10-data",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.3 1. Load Data Cifar10 Data",
    "text": "13.3 1. Load Data Cifar10 Data\n\ndef load_data(data_dir=\"./data\"):\n    transform = transforms.Compose([\n        transforms.ToTensor(),\n        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n    ])\n\n    trainset = torchvision.datasets.CIFAR10(\n        root=data_dir, train=True, download=True, transform=transform)\n\n    testset = torchvision.datasets.CIFAR10(\n        root=data_dir, train=False, download=True, transform=transform)\n\n    return trainset, testset\n\n\ntrain, test = load_data()\ntrain.data.shape, test.data.shape\n\n\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\"data\": None, # dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": None})"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#specification-of-the-preprocessing-model",
    "href": "12_spot_hpt_torch_cifar10.html#specification-of-the-preprocessing-model",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.4 2. Specification of the Preprocessing Model",
    "text": "13.4 2. Specification of the Preprocessing Model\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#select-algorithm-and-core_model_hyper_dict",
    "href": "12_spot_hpt_torch_cifar10.html#select-algorithm-and-core_model_hyper_dict",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.5 3. Select algorithm and core_model_hyper_dict",
    "text": "13.5 3. Select algorithm and core_model_hyper_dict\nOur implementation is based on the Section “Configurable neural network” in the PyTorch tutorial Hyperparameter Tuning with Ray Tune is used here. spotPython implements a class which is similar to the class described in the PyTorch tutorial. The class is called Net_CIFAR10 and is implemented in the file netcifar10.py. The class is imported here.\nNote: In addition to the class Net from the PyTorch tutorial, the class Net_CIFAR10 has additional attributes, namely:\n\nlearning rate (lr),\nbatchsize (batch_size),\nepochs (epochs), and\nk_folds (k_folds).\n\nFurther attributes can be easily added to the class, e.g., optimizer or loss_function.\n\ncore_model = Net_CIFAR10\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=TorchHyperDict,\n                              filename=None)\n\n\n13.5.1 The hyper_dict Hyperparameters for the Selected Algorithm\nspotPython uses simple JSON files for the specification of the hyperparameters. The JSON file for the core_model is called torch_hyper_dict.json. The corresponding entries for the Net_CIFAR10 class are shown below.\n{\"Net_CIFAR10\":\n    {\n        \"l1\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"l2\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"lr\": {\n            \"type\": \"float\",\n            \"default\": 1e-03,\n            \"transform\": \"None\",\n            \"lower\": 1e-05,\n            \"upper\": 1e-02},\n        \"batch_size\": {\n            \"type\": \"int\",\n            \"default\": 4,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"epochs\": {\n                \"type\": \"int\",\n                \"default\": 3,\n                \"transform\": \"transform_power_2_int\",\n                \"lower\": 1,\n                \"upper\": 4},\n        \"k_folds\": {\n            \"type\": \"int\",\n            \"default\": 2,\n            \"transform\": \"None\",\n            \"lower\": 2,\n            \"upper\": 3}\n    }\n}\nEach entry in the JSON file represents one hyperparameter with the following structure: type, default, transform, lower, and upper.\n\n\n13.5.2 Categorical Hyperparameters\nIn contrast to Ray Tune, spotPython can handle numerical, boolean, and categorical hyperparameters. Since Ray Tune does not tune categorical hyperparameters, they are not used here. However, they can be specified in the JSON file in a similar way as the numerical hyperparameters as shown below:\n\"factor_hyperparameter\": {\n    \"levels\": [\"A\", \"B\", \"C\"],\n    \"type\": \"factor\",\n    \"default\": \"B\",\n    \"transform\": \"None\",\n    \"core_model_parameter_type\": \"str\",\n    \"lower\": 0,\n    \"upper\": 2},"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "12_spot_hpt_torch_cifar10.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "13.6 4. Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter specifying the model, the corresponding hyperparameters, their types and bounds are loaded from the JSON file torch_hyper_dict.json. After loading, the user can modify the hyperparameters, e.g., the bounds. spotPython provides a clever rule for de-activating hyperparameters. If the lower and the upper bound are set to identical values, the hyperparameter is de-activated. This is useful for the hyperparameter tuning, because it allows to specify a hyperparameter in the JSON file, but to de-activate it in the fun_control dictionary. This is done in the next step.\n\n13.6.1 Modify hyperparameter of type numeric and integer (boolean)\nSince the hyperparameter k_folds is not used in the PyTorch tutorial, it is de-activated here by setting the lower and upper bound to the same value.\n\n# fun_control = modify_hyper_parameter_bounds(fun_control, \"delta\", bounds=[1e-10, 1e-6])\n# fun_control = modify_hyper_parameter_bounds(fun_control, \"min_samples_split\", bounds=[3, 20])\n#fun_control = modify_hyper_parameter_bounds(fun_control, \"merit_preprune\", bounds=[0, 0])\n# fun_control[\"core_model_hyper_dict\"]\nfun_control = modify_hyper_parameter_bounds(fun_control, \"k_folds\", bounds=[2, 2])\n\n\n\n13.6.2 Modify hyperparameter of type factor\nIn a similar manner as for the numerical hyperparameters, the categorical hyperparameters can be modified. For example, the hyperparameter leaf_model is de-activated here by choosing only one value \"LinearRegression\".\n\n# fun_control = modify_hyper_parameter_levels(fun_control, \"leaf_model\", [\"LinearRegression\"])\n# fun_control[\"core_model_hyper_dict\"]"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#selection-of-the-objective-loss-function",
    "href": "12_spot_hpt_torch_cifar10.html#selection-of-the-objective-loss-function",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.7 5. Selection of the Objective (Loss) Function",
    "text": "13.7 5. Selection of the Objective (Loss) Function\n\nfrom torch.nn import CrossEntropyLoss\nloss_function = CrossEntropyLoss()\nfun_control.update({\"loss_function\": loss_function})\n\nIn addition to the loss functions, spotPython provides access to a large number of metrics.\n\nThe key \"metric_sklearn\" is used for metrics that follow the scikit-learn conventions.\nThe key \"river_metric\" is used for the river based evaluation (Montiel et al. 2021) via eval_oml_iter_progressive, and\nthe key \"metric_torch\" is used for the metrics from TorchMetrics.\n\nTorchMetrics is a collection of more than 90 PyTorch metrics1.\nBecause the PyTorch tutorial uses the accuracy as metric, we use the same metric here. Currently, accuracy is computed in the tutorial’s example code. We will use TorchMetrics instead, because it offers more flexibilty, e.g., it can be used for regression and classification. Furthermore, TorchMetrics offers the following advantages:\n\nA standardized interface to increase reproducibility\nReduces Boilerplate\nDistributed-training compatible\nRigorously tested\nAutomatic accumulation over batches\nAutomatic synchronization between multiple devices\n\nTherefore, we set\n\nimport torchmetrics\nmetric_torch = torchmetrics.Accuracy(task=\"multiclass\", num_classes=10)\n\nImportant:\n\nspotPython performs minimization by default.\nIf accuracy should be maximized, then the objective function has to be multiplied by -1. Therefore, weights is set to -1 in this case.\n\n\nloss_function = CrossEntropyLoss()\nweights = 1.0\nmetric_torch = torchmetrics.Accuracy(task=\"multiclass\", num_classes=10)\nshuffle = True\neval = \"train_hold_out\"\ndevice = DEVICE\nshow_batch_interval = 100_000\npath=\"torch_model.pt\"\n\nfun_control.update({\n               \"data_dir\": None,\n               \"checkpoint_dir\": None,\n               \"horizon\": None,\n               \"oml_grace_period\": None,\n               \"weights\": weights,\n               \"step\": None,\n               \"log_level\": 50,\n               \"weight_coeff\": None,\n               \"metric_torch\": metric_torch,\n               \"metric_river\": None,\n               \"metric_sklearn\": None,\n               \"loss_function\": loss_function,\n               \"shuffle\": shuffle,\n               \"eval\": eval,\n               \"device\": device,\n               \"show_batch_interval\": show_batch_interval,\n               \"path\": path,\n               })"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#calling-the-spot-function",
    "href": "12_spot_hpt_torch_cifar10.html#calling-the-spot-function",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.8 6. Calling the SPOT Function",
    "text": "13.8 6. Calling the SPOT Function\n\n13.8.1 Prepare the SPOT Parameters\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nfun_control.update({\"var_type\": var_type,\n                    \"var_name\": var_name})\n\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nprint(gen_design_table(fun_control))\n\nThe objective function fun_torch is selected next. It implements an interface from PyTorch’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypertorch import HyperTorch\nfun = HyperTorch().fun_torch\n\n\n\n13.8.2 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nhyper_dict=TorchHyperDict().load()\nX_start = get_default_hyperparameters_as_array(fun_control, hyper_dict)\nX_start\n\n\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\n\n\n13.8.3 4 Results\n\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"res_ch10-friedman-hpt-0_maans03_60min_20init_1K_2023-04-14_10-11-19.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)\n\n\nShow the Progress of the hyperparameter tuning:\n\n\nspot_tuner.y\n\n\nspot_tuner.plot_progress(log_y=False, filename=\"../Figures.d/\" + experiment_name+\"_progress.pdf\")\n\n\nPrint the Results\n\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#show-variable-importance",
    "href": "12_spot_hpt_torch_cifar10.html#show-variable-importance",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.9 Show variable importance",
    "text": "13.9 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"../Figures.d/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#get-default-hyperparameters",
    "href": "12_spot_hpt_torch_cifar10.html#get-default-hyperparameters",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.10 Get Default Hyperparameters",
    "text": "13.10 Get Default Hyperparameters\n\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n\nmodel_default = fun_control[\"core_model\"](**values_default)\nmodel_default"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#sec-get-spot-results",
    "href": "12_spot_hpt_torch_cifar10.html#sec-get-spot-results",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.11 Get SPOT Results",
    "text": "13.11 Get SPOT Results\nThe architecture of the spotPython model can be obtained by the following code:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\nmodel_spot"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "href": "12_spot_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.12 Evaluation of the Tuned Architecture",
    "text": "13.12 Evaluation of the Tuned Architecture\nThe method train_tuned takes a model architecture without trained weights and trains this model with the train data. The train data is split into train and validation data. The validation data is used for early stopping. The trained model weights are saved as a dictionary.\n\nfrom spotPython.torch.traintest import (\n    train_tuned,\n    test_tuned,\n    )\ntrain_tuned(net=model_default, train_dataset=train, shuffle=True,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        device = DEVICE, show_batch_interval=1_000_000,\n        path=None,\n        task=fun_control[\"task\"],)\n\ntest_tuned(net=model_default, test_dataset=test, \n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=False, \n        device = DEVICE,\n        task=fun_control[\"task\"],)\n\nThe following code trains the model model_spot. If path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be saved to this file. If path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be loaded from this file.\n\ntrain_tuned(net=model_spot, train_dataset=train,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=True,\n        device = DEVICE,\n        path=None,\n        task=fun_control[\"task\"],)\n#| echo: true\ntest_tuned(net=model_spot, test_dataset=test,\n            shuffle=False,\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            device = DEVICE,\n            task=fun_control[\"task\"],)"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "href": "12_spot_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.13 Detailed Hyperparameter Plots",
    "text": "13.13 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#parallel-coordinates-plot",
    "href": "12_spot_hpt_torch_cifar10.html#parallel-coordinates-plot",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.14 Parallel Coordinates Plot",
    "text": "13.14 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#plot-all-combinations-of-hyperparameters",
    "href": "12_spot_hpt_torch_cifar10.html#plot-all-combinations-of-hyperparameters",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "13.15 Plot all Combinations of Hyperparameters",
    "text": "13.15 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)\n\n\n\n\n\nMontiel, Jacob, Max Halford, Saulo Martiello Mastelini, Geoffrey Bolmier, Raphael Sourty, Robin Vaysse, Adil Zouitine, et al. 2021. “River: Machine Learning for Streaming Data in Python.”"
  },
  {
    "objectID": "12_spot_hpt_torch_cifar10.html#footnotes",
    "href": "12_spot_hpt_torch_cifar10.html#footnotes",
    "title": "13  Chapter 12: Sequential Parameter Optimization",
    "section": "",
    "text": "https://torchmetrics.readthedocs.io/en/latest/.↩︎"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html",
    "href": "14_spot_ray_hpt_torch_cifar10.html",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "",
    "text": "15 Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size and the device that is used.\nMAX_TIME = 60\nINIT_SIZE = 20\nDEVICE = \"cpu\" # \"cuda:0\"\nThe data loading process is implemented in the same manner as described in the Section “Data loaders” in PyTorch (2023a). The data loaders are wrapped into the function load_data_cifar10 which is identical to the function load_data in PyTorch (2023a). A global data directory is used, which allows sharing the data directory between different trials. The method load_data_cifar10 is part of the spotPython package and can be imported from spotPython.data.torchdata.\nIn the following step, the test and train data are added to the dictionary fun_control.\nfrom spotPython.data.torchdata import load_data_cifar10\ntrain, test = load_data_cifar10()\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\n    \"train\": train,\n    \"test\": test,\n    \"n_samples\": n_samples})\nIn Section 18.1, we first describe how to configure the search space with ray[tune] (as shown in PyTorch (2023a)) and then how to configure the search space with spotPython in Section 15.6.1.\nTable 15.1 shows some of the optimizers available in PyTorch:\n\\(a\\) denotes (0.9,0.999), \\(b\\) (0.5,1.2), and \\(c\\) (1e-6, 50), respectively. \\(R\\) denotes required, but unspecified. “m” denotes momentum, “w_d” weight_decay, “d” dampening, “n” nesterov, “r” rho, “l_s” learning rate for scaling delta, “l_d” lr_decay, “b” betas, “l” lambd, “a” alpha, “m_d” for momentum_decay, “e” etas, and “s_s” for step_sizes.\nspotPython implements an optimization handler that maps the optimizer names to the corresponding PyTorch optimizers.\nThe evaluation procedure requires the specification of the way how the data is split into a train and a test set and the loss function (and a metric). As a default, spotPython provides a standard hold-out data split and cross validation.\nThe key \"loss_function\" specifies the loss function which is used during the optimization. There are several different loss functions under PyTorch’s nn package. For example, a simple loss is MSELoss, which computes the mean-squared error between the output and the target. In this tutorial we will use CrossEntropyLoss, because it is also used in the PyTorch tutorial.\nfrom torch.nn import CrossEntropyLoss\nloss_function = CrossEntropyLoss()\nfun_control.update({\"loss_function\": loss_function})\nIn addition to the loss functions, spotPython provides access to a large number of metrics.\nTorchMetrics is a collection of more than 90 PyTorch metrics, see https://torchmetrics.readthedocs.io/en/latest/. Because the PyTorch tutorial uses the accuracy as metric, we use the same metric here. Currently, accuracy is computed in the tutorial’s example code. We will use TorchMetrics instead, because it offers more flexibilty, e.g., it can be used for regression and classification. Furthermore, TorchMetrics offers the following advantages:\nTherefore, we set\nimport torchmetrics\nmetric_torch = torchmetrics.Accuracy(task=\"multiclass\", num_classes=10)\nloss_function = CrossEntropyLoss()\nweights = 1.0\nmetric_torch = torchmetrics.Accuracy(task=\"multiclass\", num_classes=10)\nshuffle = True\neval = \"train_hold_out\"\ndevice = DEVICE\nshow_batch_interval = 100_000\npath=\"torch_model.pt\"\n\nfun_control.update({\n               \"data_dir\": None,\n               \"checkpoint_dir\": None,\n               \"horizon\": None,\n               \"oml_grace_period\": None,\n               \"weights\": weights,\n               \"step\": None,\n               \"log_level\": 50,\n               \"weight_coeff\": None,\n               \"metric_torch\": metric_torch,\n               \"metric_river\": None,\n               \"metric_sklearn\": None,\n               \"loss_function\": loss_function,\n               \"shuffle\": shuffle,\n               \"eval\": eval,\n               \"device\": device,\n               \"show_batch_interval\": show_batch_interval,\n               \"path\": path,\n               })\nThe following code passes the information about the parameter ranges and bounds to spot.\nNow, the dictionary fun_control contains all information needed for the hyperparameter tuning. Before the hyperparameter tuning is started, it is recommended to take a look at the experimental design. The method gen_design_table generates a design table as follows:\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\nThis allows to check if all information is available and if the information is correct. Table 15.3 shows the experimental design for the hyperparameter tuning. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The transformation function is used to transform the hyperparameter values from the unit hypercube to the original domain. The transformation function is applied to the hyperparameter values before the evaluation of the objective function. Hyperparameter transformations are shown in the column “transform”, e.g., the l1 default is 5, which results in the value \\(2^5 = 32\\) for the network, because the transformation transform_power_2_int was selected in the JSON file. The default value of the batch_size is set to 4, which results in a batch size of \\(2^4 = 16\\).\nThe objective function fun_torch is selected next. It implements an interface from PyTorch’s training, validation, and testing methods to spotPython.\nfrom spotPython.fun.hypertorch import HyperTorch\nfun = HyperTorch().fun_torch\nWe add the default setting to the initial design:\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nhyper_dict=TorchHyperDict().load()\nX_start = get_default_hyperparameters_as_array(fun_control, hyper_dict)\nThe spotPython hyperparameter tuning is started by calling the Spot function. Here, we will run the tuner for approximately 30 minutes (max_time). Note: the initial design is always evaluated in the spotPython run. As a consequence, the run may take longer than specified by max_time, because the evaluation time of initial design (here: init_size, 10 points) is performed independently of max_time.\nfrom spotPython.spot import spot\nfrom math import inf\nimport numpy as np\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\nDuring the run, the following output is shown:\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard.\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from Figure 15.4.\nspot_tuner.plot_progress(log_y=False, \n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\nFigure 15.4 shows a typical behaviour that can be observed in many hyperparameter studies (Bartz et al. 2022): the largest improvement is obtained during the evaluation of the initial design. The surrogate model based optimization-optimization with the surrogate refines the results. Figure 15.4 also illustrates one major difference between ray[tune] as used in PyTorch (2023a) and spotPython: the ray[tune] uses a random search and will generate results similar to the black dots, whereas spotPython uses a surrogate model based optimization and presents results represented by red dots in Figure 15.4. The surrogate model based optimization is considered to be more efficient than a random search, because the surrogate model guides the search towards promising regions in the hyperparameter space.\nIn addition to the improved (“optimized”) hyperparameter values, spotPython allows a statistical analysis, e.g., a sensitivity analysis, of the results. We can print the results of the hyperparameter tuning, see Table 15.4. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The column “tuned” shows the tuned values. The column “importance” shows the importance of the hyperparameters. The column “stars” shows the importance of the hyperparameters in stars. The importance is computed by the SPOT software.\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\nTo visualize the most important hyperparameters, spotPython provides the function plot_importance. The following code generates the importance plot from Figure 15.5.\nspot_tuner.plot_importance(threshold=0.025,\n    filename=\"./figures/\" + experiment_name+\"_importance.png\")\nThis tutorial presents the hyperparameter tuning open source software spotPython for PyTorch. To show its basic features, a comparison with the “official” PyTorch hyperparameter tuning tutorial (PyTorch 2023a) is presented. Some of the advantages of spotPython are:\nCurrently, only rudimentary parallel and distributed neural network training is possible, but these capabilities will be extended in the future. The next version of spotPython will also include a more detailed documentation and more examples."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#initialization-of-the-fun_control-dictionary",
    "href": "14_spot_ray_hpt_torch_cifar10.html#initialization-of-the-fun_control-dictionary",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "15.1 Initialization of the fun_control Dictionary",
    "text": "15.1 Initialization of the fun_control Dictionary\nspotPython uses a Python dictionary for storing the information required for the hyperparameter tuning process. This dictionary is called fun_control and is initialized with the function fun_control_init. The function fun_control_init returns a skeleton dictionary. The dictionary is filled with the required information for the hyperparameter tuning process. It stores the hyperparameter tuning settings, e.g., the deep learning network architecture that should be tuned, the classification (or regression) problem, and the data that is used for the tuning. The dictionary is used as an input for the SPOT function.\n\nfrom spotPython.utils.init import fun_control_init\nfun_control = fun_control_init(task=\"classification\",\n    tensorboard_path=\"runs/14_spot_ray_hpt_torch_cifar10\")"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "17.1 Specification of the Preprocessing Model",
    "text": "17.1 Specification of the Preprocessing Model\nAfter the training and test data are specified and added to the fun_control dictionary, spotPython allows the specification of a data preprocessing pipeline, e.g., for the scaling of the data or for the one-hot encoding of categorical variables. The preprocessing model is called prep_model (“preparation” or pre-processing) and includes steps that are not subject to the hyperparameter tuning process. The preprocessing model is specified in the fun_control dictionary. The preprocessing model can be implemented as a sklearn pipeline. The following code shows a typical preprocessing pipeline:\ncategorical_columns = [\"cities\", \"colors\"]\none_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\",\n                                    sparse_output=False)\nprep_model = ColumnTransformer(\n        transformers=[\n             (\"categorical\", one_hot_encoder, categorical_columns),\n         ],\n         remainder=StandardScaler(),\n     )\nBecause the Ray Tune (ray[tune]) hyperparameter tuning as described in PyTorch (2023a) does not use a preprocessing model, the preprocessing model is set to None here.\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "17.2 Select algorithm and core_model_hyper_dict",
    "text": "17.2 Select algorithm and core_model_hyper_dict\nThe same neural network model as implemented in the section “Configurable neural network” of the PyTorch tutorial (PyTorch 2023a) is used here. We will show the implementation from PyTorch (2023a) in Section 17.2.1 first, before the extended implementation with spotPython is shown in Section 15.5.1.\n\n17.2.1 Implementing a Configurable Neural Network With Ray Tune\nWe used the same hyperparameters that are implemented as configurable in the PyTorch tutorial. We specify the layer sizes, namely l1 and l2, of the fully connected layers:\nclass Net(nn.Module):\n    def __init__(self, l1=120, l2=84):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\nThe learning rate, i.e., lr, of the optimizer is made configurable, too:\noptimizer = optim.SGD(net.parameters(), lr=config[\"lr\"], momentum=0.9)\n\n\n17.2.2 Implementing a Configurable Neural Network With spotPython\nspotPython implements a class which is similar to the class described in the PyTorch tutorial. The class is called Net_CIFAR10 and is implemented in the file netcifar10.py.\nfrom torch import nn\nimport torch.nn.functional as F\nimport spotPython.torch.netcore as netcore\n\n\nclass Net_CIFAR10(netcore.Net_Core):\n    def __init__(self, l1, l2, lr_mult, batch_size, epochs, k_folds, patience,\n    optimizer, sgd_momentum):\n        super(Net_CIFAR10, self).__init__(\n            lr_mult=lr_mult,\n            batch_size=batch_size,\n            epochs=epochs,\n            k_folds=k_folds,\n            patience=patience,\n            optimizer=optimizer,\n            sgd_momentum=sgd_momentum,\n        )\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#the-net_core-class",
    "href": "14_spot_ray_hpt_torch_cifar10.html#the-net_core-class",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "17.3 The Net_Core class",
    "text": "17.3 The Net_Core class\nNet_CIFAR10 inherits from the class Net_Core which is implemented in the file netcore.py. It implements the additional attributes that are common to all neural network models. The Net_Core class is implemented in the file netcore.py. It implements hyperparameters as attributes, that are not used by the core_model, e.g.:\n\noptimizer (optimizer),\nlearning rate (lr),\nbatch size (batch_size),\nepochs (epochs),\nk_folds (k_folds), and\nearly stopping criterion “patience” (patience).\n\nUsers can add further attributes to the class. The class Net_Core is shown below.\nfrom torch import nn\n\n\nclass Net_Core(nn.Module):\n    def __init__(self, lr_mult, batch_size, epochs, k_folds, patience,\n        optimizer, sgd_momentum):\n        super(Net_Core, self).__init__()\n        self.lr_mult = lr_mult\n        self.batch_size = batch_size\n        self.epochs = epochs\n        self.k_folds = k_folds\n        self.patience = patience\n        self.optimizer = optimizer\n        self.sgd_momentum = sgd_momentum"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-comparison",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-comparison",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "17.4 Comparison of the Approach Described in the PyTorch Tutorial With spotPython",
    "text": "17.4 Comparison of the Approach Described in the PyTorch Tutorial With spotPython\nComparing the class Net from the PyTorch tutorial and the class Net_CIFAR10 from spotPython, we see that the class Net_CIFAR10 has additional attributes and does not inherit from nn directly. It adds an additional class, Net_core, that takes care of additional attributes that are common to all neural network models, e.g., the learning rate multiplier lr_mult or the batch size batch_size.\nspotPython’s core_model implements an instance of the Net_CIFAR10 class. In addition to the basic neural network model, the core_model can use these additional attributes. spotPython provides methods for handling these additional attributes to guarantee 100% compatibility with the PyTorch classes. The method add_core_model_to_fun_control adds the hyperparameters and additional attributes to the fun_control dictionary. The method is shown below.\n\nfrom spotPython.torch.netcifar10 import Net_CIFAR10\nfrom spotPython.data.torch_hyper_dict import TorchHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\ncore_model = Net_CIFAR10\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=TorchHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-ray-tune",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-ray-tune",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "18.1 Configuring the Search Space With Ray Tune",
    "text": "18.1 Configuring the Search Space With Ray Tune\nRay Tune’s search space can be configured as follows (PyTorch 2023a):\nconfig = {\n    \"l1\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"l2\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"lr\": tune.loguniform(1e-4, 1e-1),\n    \"batch_size\": tune.choice([2, 4, 8, 16])\n}\nThe tune.sample_from() function enables the user to define sample methods to obtain hyperparameters. In this example, the l1 and l2 parameters should be powers of 2 between 4 and 256, so either 4, 8, 16, 32, 64, 128, or 256. The lr (learning rate) should be uniformly sampled between 0.0001 and 0.1. Lastly, the batch size is a choice between 2, 4, 8, and 16.\nAt each trial, ray[tune] will randomly sample a combination of parameters from these search spaces. It will then train a number of models in parallel and find the best performing one among these. ray[tune] uses the ASHAScheduler which will terminate bad performing trials early."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-spotpython",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-spotpython",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "18.2 Configuring the Search Space With spotPython",
    "text": "18.2 Configuring the Search Space With spotPython\n\n18.2.1 The hyper_dict Hyperparameters for the Selected Algorithm\nspotPython uses JSON files for the specification of the hyperparameters. Users can specify their individual JSON files, or they can use the JSON files provided by spotPython. The JSON file for the core_model is called torch_hyper_dict.json.\nIn contrast to ray[tune], spotPython can handle numerical, boolean, and categorical hyperparameters. They can be specified in the JSON file in a similar way as the numerical hyperparameters as shown below. Each entry in the JSON file represents one hyperparameter with the following structure: type, default, transform, lower, and upper.\n\"factor_hyperparameter\": {\n    \"levels\": [\"A\", \"B\", \"C\"],\n    \"type\": \"factor\",\n    \"default\": \"B\",\n    \"transform\": \"None\",\n    \"core_model_parameter_type\": \"str\",\n    \"lower\": 0,\n    \"upper\": 2},\nThe corresponding entries for the Net_CIFAR10 class are shown below.\n{\"Net_CIFAR10\":\n    {\n        \"l1\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"l2\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"lr_mult\": {\n            \"type\": \"float\",\n            \"default\": 1.0,\n            \"transform\": \"None\",\n            \"lower\": 0.1,\n            \"upper\": 10},\n        \"batch_size\": {\n            \"type\": \"int\",\n            \"default\": 4,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"epochs\": {\n            \"type\": \"int\",\n            \"default\": 3,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"k_folds\": {\n            \"type\": \"int\",\n            \"default\": 2,\n            \"transform\": \"None\",\n            \"lower\": 2,\n            \"upper\": 3},\n        \"patience\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"None\",\n            \"lower\": 2,\n            \"upper\": 10},\n        \"optimizer\": {\n            \"levels\": [\"Adadelta\",\n                       \"Adagrad\",\n                       \"Adam\",\n                       \"AdamW\",\n                       \"SparseAdam\",\n                       \"Adamax\",\n                       \"ASGD\",\n                       \"LBFGS\",\n                       \"NAdam\",\n                       \"RAdam\",\n                       \"RMSprop\",\n                       \"Rprop\",\n                       \"SGD\"],\n            \"type\": \"factor\",\n            \"default\": \"SGD\",\n            \"transform\": \"None\",\n            \"class_name\": \"torch.optim\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 12},\n        \"sgd_momentum\": {\n            \"type\": \"float\",\n            \"default\": 0.0,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 1.0}\n    }\n}"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "18.3 Modifying the Hyperparameters",
    "text": "18.3 Modifying the Hyperparameters\nRay tune (PyTorch 2023a) does not provide a way to change the specified hyperparameters without re-compilation. However, spotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions are described in the following.\n\n18.3.1 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter specifying the model, the corresponding hyperparameters, their types and bounds are loaded from the JSON file torch_hyper_dict.json. After loading, the user can modify the hyperparameters, e.g., the bounds. spotPython provides a simple rule for de-activating hyperparameters: If the lower and the upper bound are set to identical values, the hyperparameter is de-activated. This is useful for the hyperparameter tuning, because it allows to specify a hyperparameter in the JSON file, but to de-activate it in the fun_control dictionary. This is done in the next step.\n\n\n18.3.2 Modify Hyperparameters of Type numeric and integer (boolean)\nSince the hyperparameter k_folds is not used in the PyTorch tutorial, it is de-activated here by setting the lower and upper bound to the same value. Note, k_folds is of type “integer”.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"batch_size\", bounds=[1, 5])\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"k_folds\", bounds=[0, 0])\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"patience\", bounds=[3, 3])\n\n\n\n18.3.3 Modify Hyperparameter of Type factor\nIn a similar manner as for the numerical hyperparameters, the categorical hyperparameters can be modified. New configurations can be chosen by adding or deleting levels. For example, the hyperparameter optimizer can be re-configured as follows:\nIn the following setting, two optimizers (\"SGD\" and \"Adam\") will be compared during the spotPython hyperparameter tuning. The hyperparameter optimizer is active.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nfun_control = modify_hyper_parameter_levels(fun_control,\n     \"optimizer\", [\"SGD\", \"Adam\"])\n\nThe hyperparameter optimizer can be de-activated by choosing only one value (level), here: \"SGD\".\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\", [\"SGD\"])\n\nAs discussed in Section 15.7.4, there are some issues with the LBFGS optimizer. Therefore, the usage of the LBFGS optimizer is not deactivated in spotPython by default. However, the LBFGS optimizer can be activated by adding it to the list of optimizers. Rprop was removed, because it does perform very poorly (as some pre-tests have shown). However, it can also be activated by adding it to the list of optimizers. Since SparseAdam does not support dense gradients, Adam was used instead. Therefore, there are 10 default optimizers:\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\",\n    [\"Adadelta\", \"Adagrad\", \"Adam\", \"AdamW\", \"Adamax\", \"ASGD\", \n    \"NAdam\", \"RAdam\", \"RMSprop\", \"SGD\"])"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-lbfgs",
    "href": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-lbfgs",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "19.1 A note on LBFGS",
    "text": "19.1 A note on LBFGS\nWe recommend deactivating PyTorch’s LBFGS optimizer, because it does not perform very well. The PyTorch documentation, see https://pytorch.org/docs/stable/generated/torch.optim.LBFGS.html#torch.optim.LBFGS, states:\n\nThis is a very memory intensive optimizer (it requires additional param_bytes * (history_size + 1) bytes). If it doesn’t fit in memory try reducing the history size, or use a different algorithm.\n\nFurthermore, the LBFGS optimizer is not compatible with the PyTorch tutorial. The reason is that the LBFGS optimizer requires the closure function, which is not implemented in the PyTorch tutorial. Therefore, the LBFGS optimizer is recommended here. Since there are ten optimizers in the portfolio, it is not recommended tuning the hyperparameters that effect one single optimizer only."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-the-learning-rate",
    "href": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-the-learning-rate",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "19.2 A note on the learning rate",
    "text": "19.2 A note on the learning rate\nspotPython provides a multiplier for the default learning rates, lr_mult, because optimizers use different learning rates. Using a multiplier for the learning rates might enable a simultaneous tuning of the learning rates for all optimizers. However, this is not recommended, because the learning rates are not comparable across optimizers. Therefore, we recommend fixing the learning rate for all optimizers if multiple optimizers are used. This can be done by setting the lower and upper bounds of the learning rate multiplier to the same value as shown below.\nThus, the learning rate, which affects the SGD optimizer, will be set to a fixed value. We choose the default value of 1e-3 for the learning rate, because it is used in other PyTorch examples (it is also the default value used by spotPython as defined in the optimizer_handler() method). We recommend tuning the learning rate later, when a reduced set of optimizers is fixed. Here, we will demonstrate how to select in a screening phase the optimizers that should be used for the hyperparameter tuning. For the same reason, we will fix the sgd_momentum to 0.9.\n\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"lr_mult\", bounds=[1.0, 1.0])\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"sgd_momentum\", bounds=[0.9, 0.9])"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#hold-out-data-split",
    "href": "14_spot_ray_hpt_torch_cifar10.html#hold-out-data-split",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "20.1 Hold-out Data Split",
    "text": "20.1 Hold-out Data Split\nIf a hold-out data split is used, the data will be partitioned into a training, a validation, and a test data set. The split depends on the setting of the eval parameter. If eval is set to train_hold_out, one data set, usually the original training data set, is split into a new training and a validation data set. The training data set is used for training the model. The validation data set is used for the evaluation of the hyperparameter configuration and early stopping to prevent overfitting. In this case, the original test data set is not used.\nspotPython returns the hyperparameters of the machine learning and deep learning models, e.g., number of layers, learning rate, or optimizer, but not the model weights. Therefore, after the SPOT run is finished, the corresponding model with the optimized architecture has to be trained again with the best hyperparameter configuration. The training is performed on the training data set. The test data set is used for the final evaluation of the model.\nSummarizing, the following splits are performed in the hold-out setting:\n\nRun spotPython with eval set to train_hold_out to determine the best hyperparameter configuration.\nTrain the model with the best hyperparameter configuration (“architecture”) on the training data set: train_tuned(model_spot, train, \"model_spot.pt\").\nTest the model on the test data: test_tuned(model_spot, test, \"model_spot.pt\")\n\nThese steps will be exemplified in the following sections. In addition to this hold-out setting, spotPython provides another hold-out setting, where an explicit test data is specified by the user that will be used as the validation set. To choose this option, the eval parameter is set to test_hold_out. In this case, the training data set is used for the model training. Then, the explicitly defined test data set is used for the evaluation of the hyperparameter configuration (the validation)."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#cross-validation",
    "href": "14_spot_ray_hpt_torch_cifar10.html#cross-validation",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "20.2 Cross-Validation",
    "text": "20.2 Cross-Validation\nThe cross validation setting is used by setting the eval parameter to train_cv or test_cv. In both cases, the data set is split into \\(k\\) folds. The model is trained on \\(k-1\\) folds and evaluated on the remaining fold. This is repeated \\(k\\) times, so that each fold is used exactly once for evaluation. The final evaluation is performed on the test data set. The cross validation setting is useful for small data sets, because it allows to use all data for training and evaluation. However, it is computationally expensive, because the model has to be trained \\(k\\) times.\nCombinations of the above settings are possible, e.g., cross validation can be used for training and hold-out for evaluation or vice versa. Also, cross validation can be used for training and testing. Because cross validation is not used in the PyTorch tutorial (PyTorch 2023a), it is not considered further here."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#overview-of-the-evaluation-settings",
    "href": "14_spot_ray_hpt_torch_cifar10.html#overview-of-the-evaluation-settings",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "20.3 Overview of the Evaluation Settings",
    "text": "20.3 Overview of the Evaluation Settings\n\n20.3.1 Settings for the Hyperparameter Tuning\nAn overview of the training evaluations is shown in Table 15.2. \"train_cv\" and \"test_cv\" use sklearn.model_selection.KFold() internally. More details on the data splitting are provided in Section 29.2 (in the Appendix).\n\n\nTable 20.1: Overview of the evaluation settings.\n\n\n\n\n\n\n\n\n\neval\ntrain\ntest\nfunction\ncomment\n\n\n\n\n\"train_hold_out\"\n\\(\\checkmark\\)\n\ntrain_one_epoch(), validate_one_epoch() for early stopping\nsplits the train data set internally\n\n\n\"test_hold_out\"\n\\(\\checkmark\\)\n\\(\\checkmark\\)\ntrain_one_epoch(), validate_one_epoch() for early stopping\nuse the test data set for validate_one_epoch()\n\n\n\"train_cv\"\n\\(\\checkmark\\)\n\nevaluate_cv(net, train)\nCV using the train data set\n\n\n\"test_cv\"\n\n\\(\\checkmark\\)\nevaluate_cv(net, test)\nCV using the test data set . Identical to \"train_cv\", uses only test data.\n\n\n\n\n\n\n20.3.2 Settings for the Final Evaluation of the Tuned Architecture\n\n20.3.2.1 Training of the Tuned Architecture\ntrain_tuned(model, train): train the model with the best hyperparameter configuration (or simply the default) on the training data set. It splits the traindata into new train and validation sets using create_train_val_data_loaders(), which calls torch.utils.data.random_split() internally. Currently, 60% of the data is used for training and 40% for validation. The train data is used for training the model with train_hold_out(). The validation data is used for early stopping using validate_fold_or_hold_out() on the validation data set.\n\n\n20.3.2.2 Testing of the Tuned Architecture\ntest_tuned(model, test): test the model on the test data set. No data splitting is performed. The (trained) model is evaluated using the validate_fold_or_hold_out() function. Note: During training, shuffle is set to True, whereas during testing, shuffle is set to False.\nSection 29.2.5 describes the final evaluation of the tuned architecture."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#tensorboard-start-tensorboard",
    "href": "14_spot_ray_hpt_torch_cifar10.html#tensorboard-start-tensorboard",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "26.1 Tensorboard: Start Tensorboard",
    "text": "26.1 Tensorboard: Start Tensorboard\nStart TensorBoard through the command line to visualize data you logged. Specify the root log directory as used in fun_control = fun_control_init(task=\"regression\", tensorboard_path=\"runs/24_spot_torch_regression\") as the tensorboard_path. The argument logdir points to directory where TensorBoard will look to find event files that it can display. TensorBoard will recursively walk the directory structure rooted at logdir, looking for .tfevents. files.\ntensorboard --logdir=runs\nGo to the URL it provides or to http://localhost:6006/. The following figures show some screenshots of Tensorboard.\n\n\n\nFigure 26.1: Tensorboard\n\n\n\n\n\nFigure 26.2: Tensorboard"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-saving-the-state-of-the-notebook",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-saving-the-state-of-the-notebook",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "26.2 Saving the State of the Notebook",
    "text": "26.2 Saving the State of the Notebook\nThe state of the notebook can be saved and reloaded as follows:\n\nimport pickle\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"add_the_name_of_the_result_file_here.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-get-spot-results",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-get-spot-results",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.1 Get SPOT Results",
    "text": "27.1 Get SPOT Results\nThe architecture of the spotPython model can be obtained by the following code:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\nmodel_spot\n\nFirst, the numerical representation of the hyperparameters are obtained, i.e., the numpy array X is generated. This array is then used to generate the model model_spot by the function get_one_core_model_from_X. The model model_spot has the following architecture:\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1,\n    ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=64, bias=True)\n  (fc2): Linear(in_features=64, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=10, bias=True)\n)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#get-default-hyperparameters",
    "href": "14_spot_ray_hpt_torch_cifar10.html#get-default-hyperparameters",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.2 Get Default Hyperparameters",
    "text": "27.2 Get Default Hyperparameters\nIn a similar manner as in Section 15.12, the default hyperparameters can be obtained.\n\n# fun_control was modified, we generate a new one with the original \n# default hyperparameters\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfc = fun_control\nfc.update({\"core_model_hyper_dict\":\n    hyper_dict[fun_control[\"core_model\"].__name__]})\nmodel_default = get_one_core_model_from_X(X_start, fun_control=fc)\n\nThe corresponding default model has the following architecture:\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1,\n    ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=32, bias=True)\n  (fc2): Linear(in_features=32, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=10, bias=True)\n)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-default-architecture",
    "href": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-default-architecture",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.3 Evaluation of the Default Architecture",
    "text": "27.3 Evaluation of the Default Architecture\nThe method train_tuned takes a model architecture without trained weights and trains this model with the train data. The train data is split into train and validation data. The validation data is used for early stopping. The trained model weights are saved as a dictionary.\nThis evaluation is similar to the final evaluation in PyTorch (2023a).\n\nfrom spotPython.torch.traintest import (\n    train_tuned,\n    test_tuned,\n    )\ntrain_tuned(net=model_default, train_dataset=train, shuffle=True,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        device = DEVICE, show_batch_interval=1_000_000,\n        path=None,\n        task=fun_control[\"task\"],)\n\ntest_tuned(net=model_default, test_dataset=test, \n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=False, \n        device = DEVICE,\n        task=fun_control[\"task\"],)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "href": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.4 Evaluation of the Tuned Architecture",
    "text": "27.4 Evaluation of the Tuned Architecture\nThe following code trains the model model_spot. If path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be saved to this file.\n\ntrain_tuned(net=model_spot, train_dataset=train,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=True,\n        device = DEVICE,\n        path=None,\n        task=fun_control[\"task\"],)\ntest_tuned(net=model_spot, test_dataset=test,\n            shuffle=False,\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            device = DEVICE,\n            task=fun_control[\"task\"],)\n\nThese runs will generate output similar to the following:\nLoss on hold-out set: 1.2267619131326675\nAccuracy on hold-out set: 0.58955\nEarly stopping at epoch 13"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#comparison-with-default-hyperparameters-and-ray-tune",
    "href": "14_spot_ray_hpt_torch_cifar10.html#comparison-with-default-hyperparameters-and-ray-tune",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.5 Comparison with Default Hyperparameters and Ray Tune",
    "text": "27.5 Comparison with Default Hyperparameters and Ray Tune\nTable 15.5 shows the loss and accuracy of the default model, the model with the hyperparameters from SPOT, and the model with the hyperparameters from ray[tune]. The table shows a comparison of the loss and accuracy of the default model, the model with the hyperparameters from SPOT, and the model with the hyperparameters from ray[tune]. ray[tune] only shows the validation loss, because training loss is not reported by ray[tune]\n\n\nTable 27.2: Comparison.\n\n\n\n\n\n\n\n\n\nModel\nValidation Loss\nValidation Accuracy\nLoss\nAccuracy\n\n\n\n\nDefault\n2.1221\n0.2452\n2.1182\n0.2425\n\n\nspotPython\n1.2268\n0.5896\n1.2426\n0.5957\n\n\nray[tune]\n1.1815\n0.5836\n-\n0.5806"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "href": "14_spot_ray_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "27.6 Detailed Hyperparameter Plots",
    "text": "27.6 Detailed Hyperparameter Plots\nThe contour plots in this section visualize the interactions of the three most important hyperparameters, l1, l2, and epochs, and optimizer of the surrogate model used to optimize the hyperparameters. Since some of these hyperparameters take fatorial or integer values, sometimes step-like fitness landcapes (or response surfaces) are generated. SPOT draws the interactions of the main hyperparameters by default. It is also possible to visualize all interactions. For this, again refer to the notebook (Bartz-Beielstein 2023).\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\n\n\n\nFigure 27.3: Contour plot of the loss as a function of l1 and l2, i.e., the number of neurons in the layers.\n\n\n\n\n\nFigure 27.4: Contour plot of the loss as a function of the number of epochs and the neurons in layer l1.\n\n\n\n\n\nFigure 27.5: Contour plot of the loss as a function of the optimizer and the neurons in layer l1.\n\n\n\n\n\nFigure 27.6: Contour plot of the loss as a function of the number of epochs and the neurons in layer l2.\n\n\n\n\n\nFigure 27.7: Contour plot of the loss as a function of the optimizer and the neurons in layer l2.\n\n\n\n\n\nFigure 27.8: Contour plot of the loss as a function of the optimizer and the number of epochs.\n\n\nThe figures (Figure 27.3 to Figure 27.8) show the contour plots of the loss as a function of the hyperparameters. These plots are very helpful for benchmark studies and for understanding neural networks. spotPython provides additional tools for a visual inspection of the results and give valuable insights into the hyperparameter tuning process. This is especially useful for model explainability, transparency, and trustworthiness. In addition to the contour plots, Figure 15.7 shows the parallel plot of the hyperparameters.\n\nspot_tuner.parallel_plot()\n\n\n\n\nFigure 27.9: Parallel plot"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sample-output-from-ray-tunes-run",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sample-output-from-ray-tunes-run",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "29.1 Sample Output From Ray Tune’s Run",
    "text": "29.1 Sample Output From Ray Tune’s Run\nThe output from ray[tune] could look like this (PyTorch 2023b):\nNumber of trials: 10 (10 TERMINATED)\n------+------+-------------+--------------+---------+------------+--------------------+\n|   l1 |   l2 |          lr |   batch_size |    loss |   accuracy | training_iteration |\n+------+------+-------------+--------------+---------+------------+--------------------|\n|   64 |    4 | 0.00011629  |            2 | 1.87273 |     0.244  |                  2 |\n|   32 |   64 | 0.000339763 |            8 | 1.23603 |     0.567  |                  8 |\n|    8 |   16 | 0.00276249  |           16 | 1.1815  |     0.5836 |                 10 |\n|    4 |   64 | 0.000648721 |            4 | 1.31131 |     0.5224 |                  8 |\n|   32 |   16 | 0.000340753 |            8 | 1.26454 |     0.5444 |                  8 |\n|    8 |    4 | 0.000699775 |            8 | 1.99594 |     0.1983 |                  2 |\n|  256 |    8 | 0.0839654   |           16 | 2.3119  |     0.0993 |                  1 |\n|   16 |  128 | 0.0758154   |           16 | 2.33575 |     0.1327 |                  1 |\n|   16 |    8 | 0.0763312   |           16 | 2.31129 |     0.1042 |                  4 |\n|  128 |   16 | 0.000124903 |            4 | 2.26917 |     0.1945 |                  1 |\n+-----+------+------+-------------+--------------+---------+------------+--------------------+\nBest trial config: {'l1': 8, 'l2': 16, 'lr': 0.00276249, 'batch_size': 16, 'data_dir': '...'}\nBest trial final validation loss: 1.181501\nBest trial final validation accuracy: 0.5836\nBest trial test set accuracy: 0.5806"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-detailed-data-splitting",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-detailed-data-splitting",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "29.2 Detailed Description of the Data Splitting",
    "text": "29.2 Detailed Description of the Data Splitting\n\n29.2.1 Description of the \"train_hold_out\" Setting\nThe \"train_hold_out\" setting is used by default. It uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc(), which is implemented in the file hypertorch.py, calls evaluate_hold_out() as follows:\n\ndf_eval, _ = evaluate_hold_out(\n    model,\n    train_dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    loss_function=self.fun_control[\"loss_function\"],\n    metric=self.fun_control[\"metric_torch\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    path=self.fun_control[\"path\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: Only the data set fun_control[\"train\"] is used for training and validation. It is used in evaluate_hold_out as follows:\ntrainloader, valloader = create_train_val_data_loaders(\n                dataset=train_dataset, batch_size=batch_size_instance, shuffle=shuffle\n            )\ncreate_train_val_data_loaders() splits the train_dataset into trainloader and valloader using torch.utils.data.random_split() as follows:\ndef create_train_val_data_loaders(dataset, batch_size, shuffle, num_workers=0):\n    test_abs = int(len(dataset) * 0.6)\n    train_subset, val_subset = random_split(dataset, [test_abs, len(dataset) - test_abs])\n    trainloader = torch.utils.data.DataLoader(\n        train_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    valloader = torch.utils.data.DataLoader(\n        val_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    return trainloader, valloader\nThe optimizer is set up as follows:\noptimizer_instance = net.optimizer\nlr_mult_instance = net.lr_mult\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(\n    optimizer_name=optimizer_instance,\n    params=net.parameters(),\n    lr_mult=lr_mult_instance,\n    sgd_momentum=sgd_momentum_instance,\n)\n\nevaluate_hold_out() sets the net attributes such as epochs, batch_size, optimizer, and patience. For each epoch, the methods train_one_epoch() and validate_one_epoch() are called, the former for training and the latter for validation and early stopping. The validation loss from the last epoch (not the best validation loss) is returned from evaluate_hold_out.\nThe method train_one_epoch() is implemented as follows:\n\ndef train_one_epoch(\n    net,\n    trainloader,\n    batch_size,\n    loss_function,\n    optimizer,\n    device,\n    show_batch_interval=10_000,\n    task=None,\n):\n    running_loss = 0.0\n    epoch_steps = 0\n    for batch_nr, data in enumerate(trainloader, 0):\n        input, target = data\n        input, target = input.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = net(input)\n        if task == \"regression\":\n            target = target.unsqueeze(1)\n            if target.shape == output.shape:\n                loss = loss_function(output, target)\n            else:\n                raise ValueError(f\"Shapes of target and output do not match:\n                 {target.shape} vs {output.shape}\")\n        elif task == \"classification\":\n            loss = loss_function(output, target)\n        else:\n            raise ValueError(f\"Unknown task: {task}\")\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(net.parameters(), max_norm=1.0)\n        optimizer.step()\n        running_loss += loss.item()\n        epoch_steps += 1\n        if batch_nr % show_batch_interval == (show_batch_interval - 1):  \n            print(\n                \"Batch: %5d. Batch Size: %d. Training Loss (running): %.3f\"\n                % (batch_nr + 1, int(batch_size), running_loss / epoch_steps)\n            )\n            running_loss = 0.0\n    return loss.item()\n\nThe method validate_one_epoch() is implemented as follows:\n\ndef validate_one_epoch(net, valloader, loss_function, metric, device, task):\n    val_loss = 0.0\n    val_steps = 0\n    total = 0\n    correct = 0\n    metric.reset()\n    for i, data in enumerate(valloader, 0):\n        # get batches\n        with torch.no_grad():\n            input, target = data\n            input, target = input.to(device), target.to(device)\n            output = net(input)\n            # print(f\"target: {target}\")\n            # print(f\"output: {output}\")\n            if task == \"regression\":\n                target = target.unsqueeze(1)\n                if target.shape == output.shape:\n                    loss = loss_function(output, target)\n                else:\n                    raise ValueError(f\"Shapes of target and output \n                        do not match: {target.shape} vs {output.shape}\")\n                metric_value = metric.update(output, target)\n            elif task == \"classification\":\n                loss = loss_function(output, target)\n                metric_value = metric.update(output, target)\n                _, predicted = torch.max(output.data, 1)\n                total += target.size(0)\n                correct += (predicted == target).sum().item()\n            else:\n                raise ValueError(f\"Unknown task: {task}\")\n            val_loss += loss.cpu().numpy()\n            val_steps += 1\n    loss = val_loss / val_steps\n    print(f\"Loss on hold-out set: {loss}\")\n    if task == \"classification\":\n        accuracy = correct / total\n        print(f\"Accuracy on hold-out set: {accuracy}\")\n    # metric on all batches using custom accumulation\n    metric_value = metric.compute()\n    metric_name = type(metric).__name__\n    print(f\"{metric_name} value on hold-out data: {metric_value}\")\n    return metric_value, loss\n\n\n29.2.2 Description of the \"test_hold_out\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_hold_out() similar to the \"train_hold_out\" setting with one exception: It passes an additional test data set to evaluate_hold_out() as follows:\n\ntest_dataset=fun_control[\"test\"]\nevaluate_hold_out() calls create_train_test_data_loaders instead of create_train_val_data_loaders: The two data sets are used in create_train_test_data_loaders as follows:\ndef create_train_test_data_loaders(dataset, batch_size, shuffle, test_dataset, \n        num_workers=0):\n    trainloader = torch.utils.data.DataLoader(\n        dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    testloader = torch.utils.data.DataLoader(\n        test_dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    return trainloader, testloader\n\nThe following steps are identical to the \"train_hold_out\" setting. Only a different data loader is used for testing.\n\n\n\n29.2.3 Detailed Description of the \"train_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows (Note: Only the data set fun_control[\"train\"] is used for CV.):\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\n\nIn `evaluate_cv(), the following steps are performed: The optimizer is set up as follows:\n\noptimizer_instance = net.optimizer\nlr_instance = net.lr\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(optimizer_name=optimizer_instance,\n     params=net.parameters(), lr_mult=lr_mult_instance)\nevaluate_cv() sets the net attributes such as epochs, batch_size, optimizer, and patience. CV is implemented as follows:\ndef evaluate_cv(\n    net,\n    dataset,\n    shuffle=False,\n    loss_function=None,\n    num_workers=0,\n    device=None,\n    show_batch_interval=10_000,\n    metric=None,\n    path=None,\n    task=None,\n    writer=None,\n    writerId=None,\n):\n    lr_mult_instance = net.lr_mult\n    epochs_instance = net.epochs\n    batch_size_instance = net.batch_size\n    k_folds_instance = net.k_folds\n    optimizer_instance = net.optimizer\n    patience_instance = net.patience\n    sgd_momentum_instance = net.sgd_momentum\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    metric_values = {}\n    loss_values = {}\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        optimizer = optimizer_handler(\n            optimizer_name=optimizer_instance,\n            params=net.parameters(),\n            lr_mult=lr_mult_instance,\n            sgd_momentum=sgd_momentum_instance,\n        )\n        kfold = KFold(n_splits=k_folds_instance, shuffle=shuffle)\n        for fold, (train_ids, val_ids) in enumerate(kfold.split(dataset)):\n            print(f\"Fold: {fold + 1}\")\n            train_subsampler = torch.utils.data.SubsetRandomSampler(train_ids)\n            val_subsampler = torch.utils.data.SubsetRandomSampler(val_ids)\n            trainloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=train_subsampler, num_workers=num_workers\n            )\n            valloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=val_subsampler, num_workers=num_workers\n            )\n            # each fold starts with new weights:\n            reset_weights(net)\n            # Early stopping parameters\n            best_val_loss = float(\"inf\")\n            counter = 0\n            for epoch in range(epochs_instance):\n                print(f\"Epoch: {epoch + 1}\")\n                # training loss from one epoch:\n                training_loss = train_one_epoch(\n                    net=net,\n                    trainloader=trainloader,\n                    batch_size=batch_size_instance,\n                    loss_function=loss_function,\n                    optimizer=optimizer,\n                    device=device,\n                    show_batch_interval=show_batch_interval,\n                    task=task,\n                )\n                # Early stopping check. Calculate validation loss from one epoch:\n                metric_values[fold], loss_values[fold] = validate_one_epoch(\n                    net, valloader=valloader, loss_function=loss_function, \n                    metric=metric, device=device, task=task\n                )\n                # Log the running loss averaged per batch\n                metric_name = \"Metric\"\n                if metric is None:\n                    metric_name = type(metric).__name__\n                    print(f\"{metric_name} value on hold-out data: \n                        {metric_values[fold]}\")\n                if writer is not None:\n                    writer.add_scalars(\n                        \"evaluate_cv fold:\" + str(fold + 1) + \n                        \". Train & Val Loss and Val Metric\" + writerId,\n                        {\"Train loss\": training_loss, \"Val loss\": \n                        loss_values[fold], metric_name: metric_values[fold]},\n                        epoch + 1,\n                    )\n                    writer.flush()\n                if loss_values[fold] &lt; best_val_loss:\n                    best_val_loss = loss_values[fold]\n                    counter = 0\n                    # save model:\n                    if path is not None:\n                        torch.save(net.state_dict(), path)\n                else:\n                    counter += 1\n                    if counter &gt;= patience_instance:\n                        print(f\"Early stopping at epoch {epoch}\")\n                        break\n        df_eval = sum(loss_values.values()) / len(loss_values.values())\n        df_metrics = sum(metric_values.values()) / len(metric_values.values())\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to evaluate_cv() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    if writer is not None:\n        metric_name = \"Metric\"\n        if metric is None:\n            metric_name = type(metric).__name__\n        writer.add_scalars(\n            \"CV: Val Loss and Val Metric\" + writerId,\n            {\"CV-loss\": df_eval, metric_name: df_metrics},\n            epoch + 1,\n        )\n        writer.flush()\n    return df_eval, df_preds, df_metrics\n\nThe method train_fold() is implemented as shown above.\nThe method validate_one_epoch() is implemented as shown above. In contrast to the hold-out setting, it is called for each of the \\(k\\) folds. The results are stored in a dictionaries metric_values and loss_values. The results are averaged over the \\(k\\) folds and returned as df_eval.\n\n\n\n29.2.4 Detailed Description of the \"test_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows:\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"test\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: The data set fun_control[\"test\"] is used for CV. The rest is the same as for the \"train_cv\" setting.\n\n\n29.2.5 Detailed Description of the Final Model Training and Evaluation\n\n29.2.5.1 Detailed Description of the \"train_tuned Procedure\ntrain_tuned() is just a wrapper to evaluate_hold_out using the train data set. It is implemented as follows:\ndef train_tuned(\n    net,\n    train_dataset,\n    shuffle,\n    loss_function,\n    metric,\n    device=None,\n    show_batch_interval=10_000,\n    path=None,\n    task=None,\n    writer=None,\n):\n    evaluate_hold_out(\n        net=net,\n        train_dataset=train_dataset,\n        shuffle=shuffle,\n        test_dataset=None,\n        loss_function=loss_function,\n        metric=metric,\n        device=device,\n        show_batch_interval=show_batch_interval,\n        path=path,\n        task=task,\n        writer=writer,\n    )\nThe test_tuned() procedure is implemented as follows:\ndef test_tuned(net, shuffle, test_dataset=None, loss_function=None,\n    metric=None, device=None, path=None, task=None):\n    batch_size_instance = net.batch_size\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    if path is not None:\n        net.load_state_dict(torch.load(path))\n        net.eval()\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        valloader = torch.utils.data.DataLoader(\n            test_dataset, batch_size=int(batch_size_instance),\n            shuffle=shuffle, \n            num_workers=0\n        )\n        metric_value, loss = validate_one_epoch(\n            net, valloader=valloader, loss_function=loss_function,\n            metric=metric, device=device, task=task\n        )\n        df_eval = loss\n        df_metric = metric_value\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to test_tuned() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_metric = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    print(f\"Final evaluation: Validation loss: {df_eval}\")\n    print(f\"Final evaluation: Validation metric: {df_metric}\")\n    print(\"----------------------------------------------\")\n    return df_eval, df_preds, df_metric\n\n\n\n\nBartz, Eva, Thomas Bartz-Beielstein, Martin Zaefferer, and Olaf Mersmann, eds. 2022. Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide. Springer.\n\n\nBartz-Beielstein, Thomas. 2023. “PyTorch Hyperparameter Tuning with SPOT: Comparison with Ray Tuner and Default Hyperparameters on CIFAR10.” https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb.\n\n\nBartz-Beielstein, Thomas, Carola Doerr, Jakob Bossek, Sowmya Chandrasekaran, Tome Eftimov, Andreas Fischbach, Pascal Kerschke, et al. 2020. “Benchmarking in Optimization: Best Practice and Open Issues.” arXiv. https://arxiv.org/abs/2007.03488.\n\n\nMontiel, Jacob, Max Halford, Saulo Martiello Mastelini, Geoffrey Bolmier, Raphael Sourty, Robin Vaysse, Adil Zouitine, et al. 2021. “River: Machine Learning for Streaming Data in Python.”\n\n\nPyTorch. 2023a. “Hyperparameter Tuning with Ray Tune.” https://pytorch.org/tutorials/beginner/hyperparameter_tuning_tutorial.html.\n\n\n———. 2023b. “Training a Classifier.” https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "href": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "title": "14  Hyperparameter Tuning for PyTorch With spotPython",
    "section": "",
    "text": "Alternatively, the source code can be downloaded from gitHub: https://github.com/sequential-parameter-optimization/spotPython.↩︎\nWe were not able to install Ray Tune on our system. Therefore, we used the results from the PyTorch tutorial.↩︎"
  },
  {
    "objectID": "24_spot_torch_regression.html",
    "href": "24_spot_torch_regression.html",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "",
    "text": "16 Summary and Outlook\nThis tutorial presents the hyperparameter tuning open source software spotPython for PyTorch. Some of the advantages of spotPython are:\nCurrently, only rudimentary parallel and distributed neural network training is possible, but these capabilities will be extended in the future. The next version of spotPython will also include a more detailed documentation and more examples."
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-setup",
    "href": "24_spot_torch_regression.html#sec-setup",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.1 Setup",
    "text": "15.1 Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size and the device that is used.\n\nMAX_TIME = 10\nINIT_SIZE = 20\nDEVICE = \"cpu\" # \"cuda:0\""
  },
  {
    "objectID": "24_spot_torch_regression.html#initialization-of-the-fun_control-dictionary",
    "href": "24_spot_torch_regression.html#initialization-of-the-fun_control-dictionary",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.2 Initialization of the fun_control Dictionary",
    "text": "15.2 Initialization of the fun_control Dictionary\nspotPython uses a Python dictionary for storing the information required for the hyperparameter tuning process. This dictionary is called fun_control and is initialized with the function fun_control_init. The function fun_control_init returns a skeleton dictionary. The dictionary is filled with the required information for the hyperparameter tuning process. It stores the hyperparameter tuning settings, e.g., the deep learning network architecture that should be tuned, the classification (or regression) problem, and the data that is used for the tuning. The dictionary is used as an input for the SPOT function.\n\nfrom spotPython.utils.init import fun_control_init\nfun_control = fun_control_init(task=\"regression\",\n tensorboard_path=\"runs/24_spot_torch_regression\")"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-data-loading",
    "href": "24_spot_torch_regression.html#sec-data-loading",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.3 PyTorch Data Loading",
    "text": "15.3 PyTorch Data Loading\n\n# Create dataset\nimport pandas as pd\nimport numpy as np\nfrom sklearn import datasets as sklearn_datasets\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split\nX, y = sklearn_datasets.make_regression(\n    n_samples=1000, n_features=10, noise=1, random_state=123)\ny = y.reshape(-1, 1)\n\n# Normalize the data\nX_scaler = MinMaxScaler()\nX_scaled = X_scaler.fit_transform(X)\ny_scaler = MinMaxScaler()\ny_scaled = y_scaler.fit_transform(y)\n\n# combine the features and target into a single dataframe named train_df\ntrain_df = pd.DataFrame(np.hstack((X_scaled, y_scaled)))\n\ntarget_column = \"y\"\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntrain_df.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nX_train, X_test, y_train, y_test = train_test_split(train_df.drop(target_column,\n    axis=1), \n    train_df[target_column],\n    random_state=42,\n    test_size=0.25)\ntrainset = pd.DataFrame(np.hstack((X_train, np.array(y_train).reshape(-1, 1))))\ntestset = pd.DataFrame(np.hstack((X_test, np.array(y_test).reshape(-1, 1))))\ntrainset.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntestset.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train_df.shape)\nprint(trainset.shape)\nprint(testset.shape)\n\n\nimport torch\nfrom spotPython.torch.dataframedataset import DataFrameDataset\ndtype_x = torch.float32\ndtype_y = torch.float32\ntrain_df = DataFrameDataset(train_df, target_column=target_column,\n    dtype_x=dtype_x, dtype_y=dtype_y)\ntrain = DataFrameDataset(trainset, target_column=target_column,\n    dtype_x=dtype_x, dtype_y=dtype_y)\ntest = DataFrameDataset(testset, target_column=target_column,\n    dtype_x=dtype_x, dtype_y=dtype_y)\nn_samples = len(train)\n\n\nNow we can test the data loading:\n\n\nfrom spotPython.torch.traintest import create_train_val_data_loaders\ntrainloader, testloader = create_train_val_data_loaders(train, 2, True, 0)\nfor i, data in enumerate(trainloader, 0):\n    inputs, labels = data\n    print(inputs.shape)\n    print(labels.shape)\n    print(inputs)\n    print(labels)\n    break\n\n\nSince this works fine, we can add the data loading to the fun_control dictionary:\n\n\n# add the dataset to the fun_control\nfun_control.update({\"data\": train_df, # full dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column,})"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-specification-of-preprocessing-model",
    "href": "24_spot_torch_regression.html#sec-specification-of-preprocessing-model",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.4 Specification of the Preprocessing Model",
    "text": "15.4 Specification of the Preprocessing Model\nAfter the training and test data are specified and added to the fun_control dictionary, spotPython allows the specification of a data preprocessing pipeline, e.g., for the scaling of the data or for the one-hot encoding of categorical variables. The preprocessing model is called prep_model (“preparation” or pre-processing) and includes steps that are not subject to the hyperparameter tuning process. The preprocessing model is specified in the fun_control dictionary. The preprocessing model can be implemented as a sklearn pipeline. The following code shows a typical preprocessing pipeline:\ncategorical_columns = [\"cities\", \"colors\"]\none_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\",\n                                    sparse_output=False)\nprep_model = ColumnTransformer(\n        transformers=[\n             (\"categorical\", one_hot_encoder, categorical_columns),\n         ],\n         remainder=StandardScaler(),\n     )\n\nfun_control.update({\"prep_model\": None})"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-selection-of-the-algorithm",
    "href": "24_spot_torch_regression.html#sec-selection-of-the-algorithm",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.5 Select algorithm and core_model_hyper_dict",
    "text": "15.5 Select algorithm and core_model_hyper_dict\n\n15.5.1 Implementing a Configurable Neural Network With spotPython\nspotPython includes the Net_lin_reg class which is implemented in the file netregression.py.\nfrom torch import nn\nimport spotPython.torch.netcore as netcore\n\n\nclass Net_lin_reg(netcore.Net_Core):\n    def __init__(\n        self, _L_in, _L_out, l1, dropout_prob, lr_mult,\n        batch_size, epochs, k_folds, patience, optimizer,\n        sgd_momentum\n    ):\n        super(Net_lin_reg, self).__init__(\n            lr_mult=lr_mult,\n            batch_size=batch_size,\n            epochs=epochs,\n            k_folds=k_folds,\n            patience=patience,\n            optimizer=optimizer,\n            sgd_momentum=sgd_momentum,\n        )\n        l2 = max(l1 // 2, 4)\n        self.fc1 = nn.Linear(_L_in, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, _L_out)\n        self.relu = nn.ReLU()\n        self.softmax = nn.Softmax(dim=1)\n        self.dropout1 = nn.Dropout(p=dropout_prob)\n        self.dropout2 = nn.Dropout(p=dropout_prob / 2)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.dropout1(x)\n        x = self.fc2(x)\n        x = self.relu(x)\n        x = self.dropout2(x)\n        x = self.fc3(x)\n        return x\n\n\n15.5.1.1 The Net_Core class\nNet_lin_reg inherits from the class Net_Core which is implemented in the file netcore.py. It implements the additional attributes that are common to all neural network models. The Net_Core class is implemented in the file netcore.py. It implements hyperparameters as attributes, that are not used by the core_model, e.g.:\n\noptimizer (optimizer),\nlearning rate (lr),\nbatch size (batch_size),\nepochs (epochs),\nk_folds (k_folds), and\nearly stopping criterion “patience” (patience).\n\nUsers can add further attributes to the class. The class Net_Core is shown below.\nfrom torch import nn\n\n\nclass Net_Core(nn.Module):\n    def __init__(self, lr_mult, batch_size, epochs, k_folds, patience,\n    optimizer, sgd_momentum):\n        super(Net_Core, self).__init__()\n        self.lr_mult = lr_mult\n        self.batch_size = batch_size\n        self.epochs = epochs\n        self.k_folds = k_folds\n        self.patience = patience\n        self.optimizer = optimizer\n        self.sgd_momentum = sgd_momentum\n:::{.callout-note}\nWe see that the class Net_lin_reg has additional attributes and does not inherit from nn directly. It adds an additional class, Net_core, that takes care of additional attributes that are common to all neural network models, e.g., the learning rate multiplier lr_mult or the batch size batch_size.\nspotPython’s core_model implements an instance of the Net_lin_reg class. In addition to the basic neural network model, the core_model can use these additional attributes. spotPython provides methods for handling these additional attributes to guarantee 100% compatibility with the PyTorch classes. The method add_core_model_to_fun_control adds the hyperparameters and additional attributes to the fun_control dictionary. The method is shown below.\n\nfrom spotPython.torch.netregression import Net_lin_reg\nfrom spotPython.data.torch_hyper_dict import TorchHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\ncore_model = Net_lin_reg\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=TorchHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-search-space",
    "href": "24_spot_torch_regression.html#sec-search-space",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.6 The Search Space",
    "text": "15.6 The Search Space\n\n15.6.1 Configuring the Search Space With spotPython\n\n15.6.1.1 The hyper_dict Hyperparameters for the Selected Algorithm\nspotPython uses JSON files for the specification of the hyperparameters. Users can specify their individual JSON files, or they can use the JSON files provided by spotPython. The JSON file for the core_model is called torch_hyper_dict.json.\nspotPython can handle numerical, boolean, and categorical hyperparameters. They can be specified in the JSON file in a similar way as the numerical hyperparameters as shown below. Each entry in the JSON file represents one hyperparameter with the following structure: type, default, transform, lower, and upper.\n\"factor_hyperparameter\": {\n    \"levels\": [\"A\", \"B\", \"C\"],\n    \"type\": \"factor\",\n    \"default\": \"B\",\n    \"transform\": \"None\",\n    \"core_model_parameter_type\": \"str\",\n    \"lower\": 0,\n    \"upper\": 2},\nThe corresponding entries for the Net_lin_reg class are shown below.\n    \"Net_lin_reg\":\n    {\n        \"_L_in\": {\n            \"type\": \"int\",\n            \"default\": 10,\n            \"transform\": \"None\",\n            \"lower\": 10,\n            \"upper\": 10},\n        \"_L_out\": {\n            \"type\": \"int\",\n            \"default\": 1,\n            \"transform\": \"None\",\n            \"lower\": 1,\n            \"upper\": 1},\n        \"l1\": {\n            \"type\": \"int\",\n            \"default\": 3,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 3,\n            \"upper\": 8},\n        \"dropout_prob\": {\n            \"type\": \"float\",\n            \"default\": 0.01,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 0.9},\n        \"lr_mult\": {\n            \"type\": \"float\",\n            \"default\": 1.0,\n            \"transform\": \"None\",\n            \"lower\": 0.1,\n            \"upper\": 10.0},\n        \"batch_size\": {\n            \"type\": \"int\",\n            \"default\": 4,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"epochs\": {\n            \"type\": \"int\",\n            \"default\": 4,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 4,\n            \"upper\": 9},\n        \"k_folds\": {\n            \"type\": \"int\",\n            \"default\": 1,\n            \"transform\": \"None\",\n            \"lower\": 1,\n            \"upper\": 1},\n        \"patience\": {\n            \"type\": \"int\",\n            \"default\": 2,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 5\n        },\n        \"optimizer\": {\n            \"levels\": [\"Adadelta\",\n                       \"Adagrad\",\n                       \"Adam\",\n                       \"AdamW\",\n                       \"SparseAdam\",\n                       \"Adamax\",\n                       \"ASGD\",\n                       \"NAdam\",\n                       \"RAdam\",\n                       \"RMSprop\",\n                       \"Rprop\",\n                       \"SGD\"],\n            \"type\": \"factor\",\n            \"default\": \"SGD\",\n            \"transform\": \"None\",\n            \"class_name\": \"torch.optim\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 12},\n        \"sgd_momentum\": {\n            \"type\": \"float\",\n            \"default\": 0.0,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 1.0}\n    },"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-modification-of-hyperparameters",
    "href": "24_spot_torch_regression.html#sec-modification-of-hyperparameters",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.7 Modifying the Hyperparameters",
    "text": "15.7 Modifying the Hyperparameters\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions are described in the following.\n\n15.7.1 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter specifying the model, the corresponding hyperparameters, their types and bounds are loaded from the JSON file torch_hyper_dict.json. After loading, the user can modify the hyperparameters, e.g., the bounds. spotPython provides a simple rule for de-activating hyperparameters: If the lower and the upper bound are set to identical values, the hyperparameter is de-activated. This is useful for the hyperparameter tuning, because it allows to specify a hyperparameter in the JSON file, but to de-activate it in the fun_control dictionary. This is done in the next step.\n\n\n15.7.2 Modify Hyperparameters of Type numeric and integer (boolean)\nSince the hyperparameter k_folds is not used in the PyTorch tutorial, it is de-activated here by setting the lower and upper bound to the same value. Note, k_folds is of type “integer”.\n\n# modify the hyperparameter levels\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\n\nfun_control = modify_hyper_parameter_bounds(fun_control, \"epochs\", bounds=[2, 16])\nfun_control = modify_hyper_parameter_bounds(fun_control, \"patience\", bounds=[3, 7])\n\n\n\n15.7.3 Modify Hyperparameter of Type factor\nIn a similar manner as for the numerical hyperparameters, the categorical hyperparameters can be modified. New configurations can be chosen by adding or deleting levels. For example, the hyperparameter optimizer can be re-configured as follows:\nIn the following setting, two optimizers (\"SGD\" and \"Adam\") will be compared during the spotPython hyperparameter tuning. The hyperparameter optimizer is active.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\",\n    [\"SGD\", \"Adam\"])\n\nThe hyperparameter optimizer can be de-activated by choosing only one value (level), here: \"SGD\".\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\", [\"SGD\"])\n\nAs discussed in Section 15.7.4, there are some issues with the LBFGS optimizer. Therefore, the usage of the LBFGS optimizer is not deactivated in spotPython by default. However, the LBFGS optimizer can be activated by adding it to the list of optimizers. Rprop was removed, because it does perform very poorly (as some pre-tests have shown). However, it can also be activated by adding it to the list of optimizers. Since SparseAdam does not support dense gradients, Adam was used instead. Therefore, there are 10 default optimizers:\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\",\n    [\"Adadelta\", \"Adagrad\", \"Adam\", \"AdamW\", \"Adamax\", \"ASGD\", \"NAdam\"])\n\n\nfun_control.update({\n               \"_L_in\": n_features,\n               \"_L_out\": 1,})\n\n\n\n15.7.4 Optimizers\nTable 15.1 shows some of the optimizers available in PyTorch:\n\n\nTable 15.1: Optimizers available in PyTorch (selection). “mom” denotes momentum, “weight” weight_decay, “damp” dampening, “nest” nesterov, “lr_sc” learning rate for scaling delta, “mom_dec” for momentum_decay, and “step_s” for step_sizes. The default values are shown in the table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptimizer\nlr\nmom\nweight\ndamp\nnest\nrho\nlr_sc\nlr_decay\nbetas\nlambd\nalpha\nmom_decay\netas\nstep_s\n\n\n\n\nAdadelta\n-\n-\n0.\n-\n-\n0.9\n1.0\n-\n-\n-\n-\n-\n-\n-\n\n\nAdagrad\n1e-2\n-\n0.\n-\n-\n-\n-\n0.\n-\n-\n-\n-\n-\n-\n\n\nAdam\n1e-3\n-\n0.\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n-\n-\n-\n\n\nAdamW\n1e-3\n-\n1e-2\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n-\n-\n-\n\n\nSparseAdam\n1e-3\n-\n-\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n-\n-\n-\n\n\nAdamax\n2e-3\n-\n0.\n-\n-\n-\n-\n-\n(0.9, 0.999)\n-\n-\n-\n-\n-\n\n\nASGD\n1e-2\n0.9\n0.\n-\nFalse\n-\n-\n-\n-\n1e-4\n0.75\n-\n-\n-\n\n\nLBFGS\n1.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\nNAdam\n2e-3\n-\n0.\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n0\n-\n-\n\n\nRAdam\n1e-3\n-\n0.\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n-\n-\n-\n\n\nRMSprop\n1e-2\n0.\n0.\n-\n-\n-\n-\n-\n(0.9,0.999)\n-\n-\n-\n-\n-\n\n\nRprop\n1e-2\n-\n-\n-\n-\n-\n-\n-\n-\n-\n(0.5,1.2)\n(1e-6, 50)\n-\n-\n\n\nSGD\nrequired\n0.\n0.\n0.\nFalse\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\n\n\nspotPython implements an optimization handler that maps the optimizer names to the corresponding PyTorch optimizers.\n\n\n\n\n\n\nA note on LBFGS\n\n\n\nWe recommend deactivating PyTorch’s LBFGS optimizer, because it does not perform very well. The PyTorch documentation, see https://pytorch.org/docs/stable/generated/torch.optim.LBFGS.html#torch.optim.LBFGS, states:\n\nThis is a very memory intensive optimizer (it requires additional param_bytes * (history_size + 1) bytes). If it doesn’t fit in memory try reducing the history size, or use a different algorithm.\n\nFurthermore, the LBFGS optimizer is not compatible with the PyTorch tutorial. The reason is that the LBFGS optimizer requires the closure function, which is not implemented in the PyTorch tutorial. Therefore, the LBFGS optimizer is recommended here.\n\n\nSince there are 10 optimizers in the portfolio, it is not recommended tuning the hyperparameters that effect one single optimizer only.\n\n\n\n\n\n\nA note on the learning rate\n\n\n\nspotPython provides a multiplier for the default learning rates, lr_mult, because optimizers use different learning rates. Using a multiplier for the learning rates might enable a simultaneous tuning of the learning rates for all optimizers. However, this is not recommended, because the learning rates are not comparable across optimizers. Therefore, we recommend fixing the learning rate for all optimizers if multiple optimizers are used. This can be done by setting the lower and upper bounds of the learning rate multiplier to the same value as shown below.\n\n\nThus, the learning rate, which affects the SGD optimizer, will be set to a fixed value. We choose the default value of 1e-3 for the learning rate, because it is used in other PyTorch examples (it is also the default value used by spotPython as defined in the optimizer_handler() method). We recommend tuning the learning rate later, when a reduced set of optimizers is fixed. Here, we will demonstrate how to select in a screening phase the optimizers that should be used for the hyperparameter tuning.\nFor the same reason, we will fix the sgd_momentum to 0.9.\n\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"lr_mult\", bounds=[1e-3, 1e-3])\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"sgd_momentum\", bounds=[0.9, 0.9])"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-selection-of-target-function",
    "href": "24_spot_torch_regression.html#sec-selection-of-target-function",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.8 Evaluation",
    "text": "15.8 Evaluation\nThe evaluation procedure requires the specification of two elements:\n\nthe way how the data is split into a train and a test set and\nthe loss function (and a metric).\n\n\n15.8.1 Hold-out Data Split and Cross-Validation\nAs a default, spotPython provides a standard hold-out data split and cross validation.\n\n15.8.1.1 Hold-out Data Split\nIf a hold-out data split is used, the data will be partitioned into a training, a validation, and a test data set. The split depends on the setting of the eval parameter. If eval is set to train_hold_out, one data set, usually the original training data set, is split into a new training and a validation data set. The training data set is used for training the model. The validation data set is used for the evaluation of the hyperparameter configuration and early stopping to prevent overfitting. In this case, the original test data set is not used. The following splits are performed in the hold-out setting: \\(\\{\\text{train}_0, \\text{test}\\} \\rightarrow \\{\\text{train}_1, \\text{validation}_1, \\text{test}\\}\\), where \\(\\text{train}_1 \\cup \\text{validation}_1 = \\text{train}_0\\).\n\n\n\n\n\n\nNote\n\n\n\nspotPython returns the hyperparameters of the machine learning and deep learning models, e.g., number of layers, learning rate, or optimizer, but not the model weights. Therefore, after the SPOT run is finished, the corresponding model with the optimized architecture has to be trained again with the best hyperparameter configuration. The training is performed on the training data set. The test data set is used for the final evaluation of the model.\nSummarizing, the following splits are performed in the hold-out setting:\n\nRun spotPython with eval set to train_hold_out to determine the best hyperparameter configuration.\nTrain the model with the best hyperparameter configuration (“architecture”) on the training data set:\n\ntrain_tuned(model_spot, train, \"model_spot.pt\").\n\nTest the model on the test data:\n\ntest_tuned(model_spot, test, \"model_spot.pt\")\n\n\nThese steps will be exemplified in the following sections.\n\n\nIn addition to this hold-out setting, spotPython provides another hold-out setting, where an explicit test data is specified by the user that will be used as the validation set. To choose this option, the eval parameter is set to test_hold_out. In this case, the training data set is used for the model training. Then, the explicitly defined test data set is used for the evaluation of the hyperparameter configuration (the validation).\n\n\n15.8.1.2 Cross-Validation\nThe cross validation setting is used by setting the eval parameter to train_cv or test_cv. In both cases, the data set is split into \\(k\\) folds. The model is trained on \\(k-1\\) folds and evaluated on the remaining fold. This is repeated \\(k\\) times, so that each fold is used exactly once for evaluation. The final evaluation is performed on the test data set. The cross validation setting is useful for small data sets, because it allows to use all data for training and evaluation. However, it is computationally expensive, because the model has to be trained \\(k\\) times.\n\n\n\n\n\n\nNote\n\n\n\nCombinations of the above settings are possible, e.g., cross validation can be used for training and hold-out for evaluation or vice versa. Also, cross validation can be used for training and testing. Because cross validation is not used in the PyTorch tutorial (PyTorch 2023), it is not considered further here.\n\n\n\n\n15.8.1.3 Overview of the Evaluation Settings\n\n15.8.1.3.1 Settings for the Hyperparameter Tuning\nTable 15.2 provides an overview of the training evaluations.\n\n\nTable 15.2: Overview of the evaluation settings.\n\n\n\n\n\n\n\n\n\neval\ntrain\ntest\nfunction\ncomment\n\n\n\n\n\"train_hold_out\"\n\\(\\checkmark\\)\n\ntrain_one_epoch(), validate_one_epoch() for early stopping\nsplits the train data set internally\n\n\n\"test_hold_out\"\n\\(\\checkmark\\)\n\\(\\checkmark\\)\ntrain_one_epoch(), validate_one_epoch() for early stopping\nuse the test data set for validate_one_epoch()\n\n\n\"train_cv\"\n\\(\\checkmark\\)\n\nevaluate_cv(net, train)\nCV using the train data set\n\n\n\"test_cv\"\n\n\\(\\checkmark\\)\nevaluate_cv(net, test)\nCV using the test data set . Identical to \"train_cv\", uses only test data.\n\n\n\n\n\n\"train_cv\" and \"test_cv\" use sklearn.model_selection.KFold() internally.\n\n\n\n\n15.8.1.4 Settings for the Final Evaluation of the Tuned Architecture\n\n15.8.1.4.1 Training of the Tuned Architecture\ntrain_tuned(model, train): train the model with the best hyperparameter configuration (or simply the default) on the training data set. It splits the traindata into new train and validation sets using create_train_val_data_loaders(), which calls torch.utils.data.random_split() internally. Currently, 60% of the data is used for training and 40% for validation. The train data is used for training the model with train_one_epoch(). The validation data is used for early stopping using validate_one_epoch() on the validation data set.\n\n\n15.8.1.4.2 Testing of the Tuned Architecture\ntest_tuned(model, test): test the model on the test data set. No data splitting is performed. The (trained) model is evaluated using the validate_one_epoch() function.\nNote: During training, shuffle is set to True, whereas during testing, shuffle is set to False.\n\n\n\n\n15.8.2 Loss Functions and Metrics\nThe key \"loss_function\" specifies the loss function which is used during the optimization. There are several different loss functions under PyTorch’s nn package. For example, a simple loss is MSELoss, which computes the mean-squared error between the output and the target. In this tutorial we will use CrossEntropyLoss, because it is also used in the PyTorch tutorial.\n\n15.8.2.1 Loss Function\nThe loss function is specified by the key \"loss_function\". We will use MSE loss for the regression task.\n\nfrom torch.nn import MSELoss\nloss_torch = MSELoss()\nfun_control.update({\"loss_function\": loss_torch})\n\nIn addition to the loss functions, spotPython provides access to a large number of metrics.\n\nThe key \"metric_sklearn\" is used for metrics that follow the scikit-learn conventions.\nThe key \"river_metric\" is used for the river based evaluation (Montiel et al. 2021) via eval_oml_iter_progressive, and\nthe key \"metric_torch\" is used for the metrics from TorchMetrics.\n\nTorchMetrics is a collection of more than 90 PyTorch metrics2.\n\nfrom torchmetrics import MeanAbsoluteError\nmetric_torch = MeanAbsoluteError()\nfun_control.update({\"metric_torch\": metric_torch})"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-call-the-hyperparameter-tuner",
    "href": "24_spot_torch_regression.html#sec-call-the-hyperparameter-tuner",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.9 Calling the SPOT Function",
    "text": "15.9 Calling the SPOT Function\nNow, the dictionary fun_control contains all information needed for the hyperparameter tuning. Before the hyperparameter tuning is started, it is recommended to take a look at the experimental design. The method gen_design_table generates a design table as follows:\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\nThis allows to check if all information is available and if the information is correct. Table 15.3 shows the experimental design for the hyperparameter tuning. Hyperparameter transformations are shown in the column “transform”, e.g., the l1 default is 5, which results in the value \\(2^5 = 32\\) for the network, because the transformation transform_power_2_int was selected in the JSON file. The default value of the batch_size is set to 4, which results in a batch size of \\(2^4 = 16\\).\n\n\nTable 15.3: Experimental design for the hyperparameter tuning. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The transformation function is used to transform the hyperparameter values from the unit hypercube to the original domain. The transformation function is applied to the hyperparameter values before the evaluation of the objective function.\n\n\n\n\n\n\n\n\n\n\nname\ntype\ndefault\nlower\nupper\ntransform\n\n\n\n\n_L_in\nint\n10\n10\n10\nNone\n\n\n_L_out\nint\n1\n1\n1\nNone\n\n\nl1\nint\n3\n3\n8\ntransform_power_2_int\n\n\ndropout_prob\nfloat\n0.01\n0\n0.9\nNone\n\n\nlr_mult\nfloat\n1.0\n0.001\n0.001\nNone\n\n\nbatch_size\nint\n4\n1\n4\ntransform_power_2_int\n\n\nepochs\nint\n4\n2\n16\ntransform_power_2_int\n\n\nk_folds\nint\n1\n1\n1\nNone\n\n\npatience\nint\n2\n3\n7\ntransform_power_2_int\n\n\noptimizer\nfactor\nSGD\n0\n6\nNone\n\n\nsgd_momentum\nfloat\n0.0\n0.9\n0.9\nNone\n\n\n\n\nThe objective function fun_torch is selected next. It implements an interface from PyTorch’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypertorch import HyperTorch\nfun = HyperTorch().fun_torch\n\n\nfun_control.update({\n               \"device\": \"cpu\",\n               })\n\nThe spotPython hyperparameter tuning is started by calling the Spot function. Here, we will run the tuner for approximately 30 minutes (max_time). Note: the initial design is always evaluated in the spotPython run. As a consequence, the run may take longer than specified by max_time, because the evaluation time of initial design (here: init_size, 10 points) is performed independently of max_time.\n\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\nDuring the run, the following output is shown:\nconfig: {'_L_in': 10, '_L_out': 1, 'l1': 64, 'dropout_prob': 0.4475780541539,\n    'lr_mult': 0.001, 'batch_size': 16, 'epochs': 512, 'k_folds': 1,\n    'patience': 32,'optimizer': 'Adagrad', 'sgd_momentum': 0.9}\nEpoch: 1\n...\nEpoch: 7002\nLoss on hold-out set: 1.6959798782529844e-05\nMeanAbsoluteError value on hold-out data: 0.0018855303060263395\nEpoch: 7003\nLoss on hold-out set: 1.6984027051769603e-05\nMeanAbsoluteError value on hold-out data: 0.001883985591121018\nEarly stopping at epoch 7002\nReturned to Spot: Validation loss: 1.6984027051769603e-05"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-tensorboard",
    "href": "24_spot_torch_regression.html#sec-tensorboard",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.10 Tensorboard",
    "text": "15.10 Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard.\n\n15.10.1 Tensorboard: Start Tensorboard\nStart TensorBoard through the command line to visualize data you logged. Specify the root log directory as used in fun_control = fun_control_init(task=\"regression\", tensorboard_path=\"runs/24_spot_torch_regression\") as the tensorboard_path. The argument logdir points to directory where TensorBoard will look to find event files that it can display. TensorBoard will recursively walk the directory structure rooted at logdir, looking for .tfevents. files.\ntensorboard –logdir=runs\nGo to the URL it provides OR to http://localhost:6006/.\nThe following figures show some screenshots of Tensorboard.\n\n\n\nFigure 15.1: Tensorboard\n\n\n\n\n\nFigure 15.2: Tensorboard\n\n\n\n\n\nFigure 15.3: Tensorboard"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-results-tuning",
    "href": "24_spot_torch_regression.html#sec-results-tuning",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.11 Results",
    "text": "15.11 Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from Figure 15.4.\n\nspot_tuner.plot_progress(log_y=False, filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nFigure 15.4: Progress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization (surrogate model based optimization).\n\n\nFigure 15.4 shows a typical behaviour that can be observed in many hyperparameter studies (Bartz et al. 2022): the largest improvement is obtained during the evaluation of the initial design. The surrogate model based optimization-optimization with the surrogate refines the results. Figure 15.4 also illustrates one major difference between ray[tune] as used in PyTorch (2023) and spotPython: the ray[tune] uses a random search and will generate results similar to the black dots, whereas spotPython uses a surrogate model based optimization and presents results represented by red dots in Figure 15.4. The surrogate model based optimization is considered to be more efficient than a random search, because the surrogate model guides the search towards promising regions in the hyperparameter space.\nIn addition to the improved (“optimized”) hyperparameter values, spotPython allows a statistical analysis, e.g., a sensitivity analysis, of the results. We can print the results of the hyperparameter tuning, see Table 15.4.\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n\n\nTable 15.4: Results of the hyperparameter tuning. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The column “tuned” shows the tuned values. The column “importance” shows the importance of the hyperparameters. The column “stars” shows the importance of the hyperparameters in stars. The importance is computed by the SPOT software.\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\ntype\ndefault\nlower\nupper\ntuned\ntransform\nimportance\nstars\n\n\n\n\n_L_in\nint\n10\n10.0\n10.0\n10.0\nNone\n0.00\n\n\n\n_L_out\nint\n1\n1.0\n1.0\n1.0\nNone\n0.00\n\n\n\nl1\nint\n3\n3.0\n8.0\n6.0\npower_2_int\n1.42\n*\n\n\ndrop_p\nfloat\n0.01\n0.0\n0.9\n0.0\nNone\n0.00\n\n\n\nlr_mult\nfloat\n1.0\n0.001\n0.001\n0.001\nNone\n0.00\n\n\n\nbatch_s\nint\n4\n1.0\n4.0\n1.0\npower_2_int\n0.01\n\n\n\nepochs\nint\n4\n2.0\n16.0\n13.0\npower_2_int\n100.00\n***\n\n\nk_folds\nint\n1\n1.0\n1.0\n1.0\nNone\n0.00\n\n\n\npatience\nint\n2\n3.0\n7.0\n4.0\npower_2_int\n0.00\n\n\n\noptim\nfactor\nSGD\n0.0\n6.0\n4.0\nNone\n0.00\n\n\n\nsgd_mom\nfloat\n0.0\n0.9\n0.9\n0.9\nNone\n0.00\n\n\n\n\n\nTo visualize the most important hyperparameters, spotPython provides the function plot_importance. The following code generates the importance plot from Figure 15.5.\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nFigure 15.5: Variable importance"
  },
  {
    "objectID": "24_spot_torch_regression.html#sec-get-spot-results",
    "href": "24_spot_torch_regression.html#sec-get-spot-results",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.12 Get SPOT Results",
    "text": "15.12 Get SPOT Results\nThe architecture of the spotPython model can be obtained by the following code:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\nmodel_spot\n\nFirst, the numerical representation of the hyperparameters are obtained, i.e., the numpy array X is generated. This array is then used to generate the model model_spot by the function get_one_core_model_from_X. The model model_spot has the following architecture:\nNet_lin_reg(\n  (fc1): Linear(in_features=10, out_features=64, bias=True)\n  (fc2): Linear(in_features=64, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=1, bias=True)\n  (relu): ReLU()\n  (softmax): Softmax(dim=1)\n  (dropout1): Dropout(p=0.0, inplace=False)\n  (dropout2): Dropout(p=0.0, inplace=False)\n)"
  },
  {
    "objectID": "24_spot_torch_regression.html#evaluation-of-the-tuned-architecture",
    "href": "24_spot_torch_regression.html#evaluation-of-the-tuned-architecture",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.13 Evaluation of the Tuned Architecture",
    "text": "15.13 Evaluation of the Tuned Architecture\nThe method train_tuned takes a model architecture without trained weights and trains this model with the train data. The train data is split into train and validation data. The validation data is used for early stopping. The trained model weights are saved as a dictionary.\nThe following code trains the model model_spot. If path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be saved to this file.\n\nfrom spotPython.torch.traintest import (\n    train_tuned,\n    test_tuned,\n    )\ntrain_tuned(net=model_spot, train_dataset=train,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=True,\n        device = DEVICE,\n        path=None,\n        task=fun_control[\"task\"],)\n\nEpoch: 1\nLoss on hold-out set: 0.17853929138431945\nMeanAbsoluteError value on hold-out data: 0.3907899856567383\nEpoch: 2\nLoss on hold-out set: 0.17439044278115035\nMeanAbsoluteError value on hold-out data: 0.38570401072502136\nIf path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be loaded from this file.\n\ntest_tuned(net=model_spot, test_dataset=test,\n            shuffle=False,\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            device = DEVICE,\n            task=fun_control[\"task\"],)\n\nLoss on hold-out set: 1.85966069472272e-05\nMeanAbsoluteError value on hold-out data: 0.0021022311411798\nFinal evaluation: Validation loss: 1.85966069472272e-05\nFinal evaluation: Validation metric: 0.0021022311411798\n----------------------------------------------\n(1.85966069472272e-05, nan, tensor(0.0021))"
  },
  {
    "objectID": "24_spot_torch_regression.html#cross-validated-evaluations",
    "href": "24_spot_torch_regression.html#cross-validated-evaluations",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.14 Cross-validated Evaluations",
    "text": "15.14 Cross-validated Evaluations\n\nfrom spotPython.torch.traintest import evaluate_cv\n# modify k-kolds:\nsetattr(model_spot, \"k_folds\",  10)\nevaluate_cv(net=model_spot,\n            dataset=fun_control[\"data\"],\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            task=fun_control[\"task\"],\n            writer=fun_control[\"writer\"],\n            writerId=\"model_spot_cv\", device=DEVICE)\n\nFold: 1\nEpoch: 1\nLoss on hold-out set: 0.36993918985128404\nMeanAbsoluteError value on hold-out data: 0.5827060341835022\nEpoch: 2\nLoss on hold-out set: 0.3583159705996513\n\n(0.0027241395250238156, nan, tensor(0.0147))\nTable 15.5 shows the loss and meric value (MAE) of the model with the tuned hyperparameters from SPOT.\n\n\nTable 15.5: Comparison of the loss and metric values.\n\n\nModel\nLoss\nMetric (MAE)\n\n\n\n\nValidation\n1.8597e-05\n0.0021\n\n\n10-fold CV\n0.00272\n0.0147"
  },
  {
    "objectID": "24_spot_torch_regression.html#detailed-hyperparameter-plots",
    "href": "24_spot_torch_regression.html#detailed-hyperparameter-plots",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "15.15 Detailed Hyperparameter Plots",
    "text": "15.15 Detailed Hyperparameter Plots\nThe contour plot in this section visualize the interactions of the two most important hyperparameters, l1, and epochs of the surrogate model used to optimize the hyperparameters. Since some of these hyperparameters take fatorial or integer values, sometimes step-like fitness landcapes (or response surfaces) are generated. SPOT draws the interactions of the main hyperparameters by default. It is also possible to visualize all interactions. For this, again refer to the notebook (Bartz-Beielstein 2023).\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\n\n\n\nFigure 15.6: Contour plot of the loss as a function of epochs and l1, i.e., the number of neurons in the layers.\n\n\nFigure 15.6 shows a contour plot of the loss as a function of the hyperparameters. These plots are very helpful for benchmark studies and for understanding neural networks. spotPython provides additional tools for a visual inspection of the results and give valuable insights into the hyperparameter tuning process. This is especially useful for model explainability, transparency, and trustworthiness. In addition to the contour plots, Figure 15.7 shows the parallel plot of the hyperparameters.\n\nspot_tuner.parallel_plot()\n\n\n\n\nFigure 15.7: Parallel plot"
  },
  {
    "objectID": "24_spot_torch_regression.html#footnotes",
    "href": "24_spot_torch_regression.html#footnotes",
    "title": "15  Hyperparameter Tuning for PyTorch With spotPython: Regression",
    "section": "",
    "text": "Alternatively, the source code can be downloaded from gitHub: https://github.com/sequential-parameter-optimization/spotPython.↩︎\nhttps://torchmetrics.readthedocs.io/en/latest/.↩︎"
  },
  {
    "objectID": "99_spot_doc.html#example-spot",
    "href": "99_spot_doc.html#example-spot",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.1 Example: spot",
    "text": "17.1 Example: spot\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n17.1.1 The Objective Function\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2\\]\n\n\nfun = analytical().fun_sphere\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = np.array([-10]),\n                   upper = np.array([100]),\n                   fun_evals = 7,\n                   fun_repeats = 1,\n                   max_time = inf,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type=[\"num\"],\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models=True,\n                   fun_control = {},\n                   design_control={\"init_size\": 5,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": 1,\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      })\n\n\nspot’s __init__ method sets the control parameters. There are two parameter groups:\n\n\nexternal parameters can be specified by the user\ninternal parameters, which are handled by spot.\n\n\n\n17.1.2 External Parameters\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nfun\nobject\nobjective function\n\nyes\n\n\nlower\narray\nlower bound\n\nyes\n\n\nupper\narray\nupper bound\n\nyes\n\n\nfun_evals\nint\nnumber of function evaluations\n15\nno\n\n\nfun_evals\nint\nnumber of function evaluations\n15\nno\n\n\nfun_control\ndict\nnoise etc.\n{}\nn\n\n\nmax_time\nint\nmax run time budget\ninf\nno\n\n\nnoise\nbool\nif repeated evaluations of fun results in different values, then noise should be set to True.\nFalse\nno\n\n\ntolerance_x\nfloat\ntolerance for new x solutions. Minimum distance of new solutions, generated by suggest_new_X, to already existing solutions. If zero (which is the default), every new solution is accepted.\n0\nno\n\n\nvar_type\nlist\nlist of type information, can be either \"num\" or \"factor\"\n[\"num\"]\nno\n\n\ninfill_criterion\nstring\nCan be \"y\", \"s\", \"ei\" (negative expected improvement), or \"all\"\n\"y\"\nno\n\n\nn_points\nint\nnumber of infill points\n1\nno\n\n\nseed\nint\ninitial seed. If Spot.run() is called twice, different results will be generated. To reproduce results, the seed can be used.\n123\nno\n\n\nlog_level\nint\nlog level with the following settings: NOTSET (0), DEBUG (10: Detailed information, typically of interest only when diagnosing problems.), INFO (20: Confirmation that things are working as expected.), WARNING (30: An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.), ERROR (40: Due to a more serious problem, the software has not been able to perform some function.), and CRITICAL (50: A serious error, indicating that the program itself may be unable to continue running.)\n50\nno\n\n\nshow_models\nbool\nPlot model. Currently only 1-dim functions are supported\nFalse\nno\n\n\ndesign\nobject\nexperimental design\nNone\nno\n\n\ndesign_control\ndict\ncontrol parameters\nsee below\nno\n\n\nsurrogate\n\nsurrogate model\nkriging\nno\n\n\nsurrogate_control\ndict\ncontrol parameters\nsee below\nno\n\n\noptimizer\nobject\noptimizer\nsee below\nno\n\n\noptimizer_control\ndict\ncontrol parameters\nsee below\nno\n\n\n\n\nBesides these single parameters, the following parameter dictionaries can be specified by the user:\n\nfun_control\ndesign_control\nsurrogate_control\noptimizer_control"
  },
  {
    "objectID": "99_spot_doc.html#the-fun_control-dictionary",
    "href": "99_spot_doc.html#the-fun_control-dictionary",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.2 The fun_control Dictionary",
    "text": "17.2 The fun_control Dictionary\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nsigma\nfloat\nnoise: standard deviation\n0\nyes\n\n\nseed\nint\nseed for rng\n124\nyes"
  },
  {
    "objectID": "99_spot_doc.html#the-design_control-dictionary",
    "href": "99_spot_doc.html#the-design_control-dictionary",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.3 The design_control Dictionary",
    "text": "17.3 The design_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\ninit_size\nint\ninitial sample size\n10\nyes\n\n\nrepeats\nint\nnumber of repeats of the initial sammples\n1\nyes"
  },
  {
    "objectID": "99_spot_doc.html#the-surrogate_control-dictionary",
    "href": "99_spot_doc.html#the-surrogate_control-dictionary",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.4 The surrogate_control Dictionary",
    "text": "17.4 The surrogate_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nnoise\n\n\n\n\n\n\nmodel_optimizer\nobject\noptimizer\ndifferential_evolution\nno\n\n\nmodel_fun_evals\n\n\n\n\n\n\nmin_theta\n\n\n-3.\n\n\n\nmax_theta\n\n\n3.\n\n\n\nn_theta\n\n\n1\n\n\n\nn_p\n\n\n1\n\n\n\noptim_p\n\n\nFalse\n\n\n\ncod_type\n\n\n\"norm\"\n\n\n\nvar_type\n\n\n\n\n\n\nuse_cod_y\nbool\n\nFalse"
  },
  {
    "objectID": "99_spot_doc.html#the-optimizer_control-dictionary",
    "href": "99_spot_doc.html#the-optimizer_control-dictionary",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.5 The optimizer_control Dictionary",
    "text": "17.5 The optimizer_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nmax_iter\nint\nmax number of iterations. Note: these are the cheap evaluations on the surrogate.\n1000\nno"
  },
  {
    "objectID": "99_spot_doc.html#run",
    "href": "99_spot_doc.html#run",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.6 Run",
    "text": "17.6 Run\n\nspot_1.run()"
  },
  {
    "objectID": "99_spot_doc.html#print-the-results",
    "href": "99_spot_doc.html#print-the-results",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.7 Print the Results",
    "text": "17.7 Print the Results\n\nspot_1.print_results()"
  },
  {
    "objectID": "99_spot_doc.html#show-the-progress",
    "href": "99_spot_doc.html#show-the-progress",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.8 Show the Progress",
    "text": "17.8 Show the Progress\n\nspot_1.plot_progress()"
  },
  {
    "objectID": "99_spot_doc.html#visualize-the-surrogate",
    "href": "99_spot_doc.html#visualize-the-surrogate",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.9 Visualize the Surrogate",
    "text": "17.9 Visualize the Surrogate\n\nThe plot method of the kriging surrogate is used.\nNote: the plot uses the interval defined by the ranges of the natural variables.\n\n\nspot_1.surrogate.plot()"
  },
  {
    "objectID": "99_spot_doc.html#init-build-initial-design",
    "href": "99_spot_doc.html#init-build-initial-design",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.10 1. Init: Build Initial Design",
    "text": "17.10 1. Init: Build Initial Design\n\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\ngen = spacefilling(2)\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)"
  },
  {
    "objectID": "99_spot_doc.html#replicability",
    "href": "99_spot_doc.html#replicability",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.11 Replicability",
    "text": "17.11 Replicability\n\nSeed\n\n\ngen = spacefilling(2, seed=123)\nX0 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=345)\nX1 = gen.scipy_lhd(3)\nX2 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=123)\nX3 = gen.scipy_lhd(3)\nX0, X1, X2, X3"
  },
  {
    "objectID": "99_spot_doc.html#surrogates",
    "href": "99_spot_doc.html#surrogates",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.12 Surrogates",
    "text": "17.12 Surrogates\n\n17.12.1 A Simple Predictor\nThe code below shows how to use a simple model for prediction.\n\nAssume that only two (very costly) measurements are available:\n\nf(0) = 0.5\nf(2) = 2.5\n\nWe are interested in the value at \\(x_0 = 1\\), i.e., \\(f(x_0 = 1)\\), but cannot run an additional, third experiment.\n\n\nfrom sklearn import linear_model\nX = np.array([[0], [2]])\ny = np.array([0.5, 2.5])\nS_lm = linear_model.LinearRegression()\nS_lm = S_lm.fit(X, y)\nX0 = np.array([[1]])\ny0 = S_lm.predict(X0)\nprint(y0)\n\n\nCentral Idea:\n\nEvaluation of the surrogate model S_lm is much cheaper (or / and much faster) than running the real-world experiment \\(f\\)."
  },
  {
    "objectID": "99_spot_doc.html#demotest-objective-function-fails",
    "href": "99_spot_doc.html#demotest-objective-function-fails",
    "title": "17  Documentation of the Sequential Parameter Optimization",
    "section": "17.13 Demo/Test: Objective Function Fails",
    "text": "17.13 Demo/Test: Objective Function Fails\n\nSPOT expects np.nan values from failed objective function values.\nThese are handled.\nNote: SPOT’s counter considers only successful executions of the objective function.\n\n\nimport numpy as np\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nimport numpy as np\nfrom math import inf\n# number of initial points:\nni = 20\n# number of points\nn = 30\n\nfun = analytical().fun_random_error\nlower = np.array([-1])\nupper = np.array([1])\ndesign_control={\"init_size\": ni}\n\nspot_1 = spot.Spot(fun=fun,\n            lower = lower,\n            upper= upper,\n            fun_evals = n,\n            show_progress=False,\n            design_control=design_control,)\nspot_1.run()\n# To check whether the run was successfully completed,\n# we compare the number of evaluated points to the specified\n# number of points.\nassert spot_1.y.shape[0] == n"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bartz, Eva, Thomas Bartz-Beielstein, Martin Zaefferer, and Olaf\nMersmann, eds. 2022. Hyperparameter Tuning for\nMachine and Deep Learning with R - A Practical Guide.\nSpringer.\n\n\nBartz-Beielstein, Thomas. 2023. “PyTorch\nHyperparameter Tuning with SPOT: Comparison with Ray\nTuner and Default Hyperparameters on\nCIFAR10.” https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb.\n\n\nBartz-Beielstein, Thomas, Jürgen Branke, Jörn Mehnen, and Olaf Mersmann.\n2014. “Evolutionary Algorithms.” Wiley\nInterdisciplinary Reviews: Data Mining and Knowledge Discovery 4\n(3): 178–95.\n\n\nBartz-Beielstein, Thomas, Carola Doerr, Jakob Bossek, Sowmya\nChandrasekaran, Tome Eftimov, Andreas Fischbach, Pascal Kerschke, et al.\n2020. “Benchmarking in Optimization: Best Practice and Open\nIssues.” arXiv. https://arxiv.org/abs/2007.03488.\n\n\nBartz-Beielstein, Thomas, Christian Lasarczyk, and Mike Preuss. 2005.\n“Sequential Parameter Optimization.” In\nProceedings 2005 Congress on Evolutionary\nComputation (CEC’05), Edinburgh, Scotland, edited by B McKay\net al., 773–80. Piscataway NJ: IEEE Press.\n\n\nLewis, R M, V Torczon, and M W Trosset. 2000. “Direct search methods: Then and now.”\nJournal of Computational and Applied Mathematics 124 (1–2):\n191–207.\n\n\nLi, Lisha, Kevin Jamieson, Giulia DeSalvo, Afshin Rostamizadeh, and\nAmeet Talwalkar. 2016. “Hyperband: A Novel\nBandit-Based Approach to Hyperparameter Optimization.”\narXiv e-Prints, March, arXiv:1603.06560.\n\n\nMeignan, David, Sigrid Knust, Jean-Marc Frayet, Gilles Pesant, and\nNicolas Gaud. 2015. “A Review and Taxonomy of\nInteractive Optimization Methods in Operations Research.”\nACM Transactions on Interactive Intelligent Systems, September.\n\n\nMontiel, Jacob, Max Halford, Saulo Martiello Mastelini, Geoffrey\nBolmier, Raphael Sourty, Robin Vaysse, Adil Zouitine, et al. 2021.\n“River: Machine Learning for Streaming Data in Python.”\n\n\nPyTorch. 2023a. “Hyperparameter Tuning with Ray Tune.” https://pytorch.org/tutorials/beginner/hyperparameter_tuning_tutorial.html.\n\n\n———. 2023b. “Training a Classifier.” https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html."
  }
]