[
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html",
    "href": "14_spot_ray_hpt_torch_cifar10.html",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "",
    "text": "Hyperparameter tuning is an important, but often difficult and computationally intensive task. Changing the architecture of a neural network or the learning rate of an optimizer can have a significant impact on the performance.\nThe goal of hyperparameter tuning is to optimize the hyperparameters in a way that improves the performance of the machine learning or deep learning model. The simplest, but also most computationally expensive, approach uses manual search (or trial-and-error (Meignan et al. 2015)). Commonly encountered is simple random search, i.e., random and repeated selection of hyperparameters for evaluation, and lattice search (“grid search”). In addition, methods that perform directed search and other model-free algorithms, i.e., algorithms that do not explicitly rely on a model, e.g., evolution strategies (Bartz-Beielstein et al. 2014) or pattern search (Lewis, Torczon, and Trosset 2000) play an important role. Also, “hyperband”, i.e., a multi-armed bandit strategy that dynamically allocates resources to a set of random configurations and uses successive bisections to stop configurations with poor performance (Li et al. 2016), is very common in hyperparameter tuning. The most sophisticated and efficient approaches are the Bayesian optimization and surrogate model based optimization methods, which are based on the optimization of cost functions determined by simulations or experiments.\nWe consider below a surrogate model based optimization-based hyperparameter tuning approach based on the Python version of the SPOT (“Sequential Parameter Optimization Toolbox”) (Bartz-Beielstein, Lasarczyk, and Preuss 2005), which is suitable for situations where only limited resources are available. This may be due to limited availability and cost of hardware, or due to the fact that confidential data may only be processed locally, e.g., due to legal requirements. Furthermore, in our approach, the understanding of algorithms is seen as a key tool for enabling transparency and explainability. This can be enabled, for example, by quantifying the contribution of machine learning and deep learning components (nodes, layers, split decisions, activation functions, etc.). Understanding the importance of hyperparameters and the interactions between multiple hyperparameters plays a major role in the interpretability and explainability of machine learning models. SPOT provides statistical tools for understanding hyperparameters and their interactions. Last but not least, it should be noted that the SPOT software code is available in the open source spotPython package on github1, allowing replicability of the results. This tutorial descries the Python variant of SPOT, which is called spotPython. The R implementation is described in Bartz et al. (2022). SPOT is an established open source software that has been maintained for more than 15 years (Bartz-Beielstein, Lasarczyk, and Preuss 2005) (Bartz et al. 2022).\nThis tutorial is structured as follows. The concept of the hyperparameter tuning software spotPython is described in Section 2. Section 3 describes the execution of the example from the tutorial “Hyperparameter Tuning with Ray Tune” (PyTorch 2023a). The integration of spotPython into the PyTorch training workflow is described in detail in the following sections. Section 4 describes the setup of the tuners. Section 5 describes the data loading. Section 6 describes the model to be tuned. The search space is introduced in Section 7. Optimizers are presented in Section 8. How to split the data in train, validation, and test sets is described in Section 9. The selection of the loss function and metrics is described in Section 10. @#sec-prepare-spot-call describes the preparation of the spotPython call. The objective function is described in Section 12. How to use results from previous runs and default hyperparameter configurations is described in Section 13. Starting the tuner is shown in Section 14. TensorBoard can be used to visualize the results as shown in Section 15. Results are discussed and explained in Section 16 Finally, Section 17 presents a summary and an outlook.\n\n\n\n\n\n\nNote\n\n\n\nThe corresponding .ipynb notebook (Bartz-Beielstein 2023) is updated regularly and reflects updates and changes in the spotPython package. It can be downloaded from https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#initialization-of-the-fun_control-dictionary",
    "href": "14_spot_ray_hpt_torch_cifar10.html#initialization-of-the-fun_control-dictionary",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Initialization of the fun_control Dictionary",
    "text": "Initialization of the fun_control Dictionary\nspotPython uses a Python dictionary for storing the information required for the hyperparameter tuning process. This dictionary is called fun_control and is initialized with the function fun_control_init. The function fun_control_init returns a skeleton dictionary. The dictionary is filled with the required information for the hyperparameter tuning process. It stores the hyperparameter tuning settings, e.g., the deep learning network architecture that should be tuned, the classification (or regression) problem, and the data that is used for the tuning. The dictionary is used as an input for the SPOT function.\n\nfrom spotPython.utils.init import fun_control_init\nfun_control = fun_control_init(task=\"classification\",\n    tensorboard_path=\"runs/14_spot_ray_hpt_torch_cifar10\")"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Specification of the Preprocessing Model",
    "text": "Specification of the Preprocessing Model\nAfter the training and test data are specified and added to the fun_control dictionary, spotPython allows the specification of a data preprocessing pipeline, e.g., for the scaling of the data or for the one-hot encoding of categorical variables. The preprocessing model is called prep_model (“preparation” or pre-processing) and includes steps that are not subject to the hyperparameter tuning process. The preprocessing model is specified in the fun_control dictionary. The preprocessing model can be implemented as a sklearn pipeline. The following code shows a typical preprocessing pipeline:\ncategorical_columns = [\"cities\", \"colors\"]\none_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\",\n                                    sparse_output=False)\nprep_model = ColumnTransformer(\n        transformers=[\n             (\"categorical\", one_hot_encoder, categorical_columns),\n         ],\n         remainder=StandardScaler(),\n     )\nBecause the Ray Tune (ray[tune]) hyperparameter tuning as described in PyTorch (2023a) does not use a preprocessing model, the preprocessing model is set to None here.\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Select algorithm and core_model_hyper_dict",
    "text": "Select algorithm and core_model_hyper_dict\nThe same neural network model as implemented in the section “Configurable neural network” of the PyTorch tutorial (PyTorch 2023a) is used here. We will show the implementation from PyTorch (2023a) in Section 6.2.1 first, before the extended implementation with spotPython is shown in Section 6.2.2.\n\nImplementing a Configurable Neural Network With Ray Tune\nWe used the same hyperparameters that are implemented as configurable in the PyTorch tutorial. We specify the layer sizes, namely l1 and l2, of the fully connected layers:\nclass Net(nn.Module):\n    def __init__(self, l1=120, l2=84):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\nThe learning rate, i.e., lr, of the optimizer is made configurable, too:\noptimizer = optim.SGD(net.parameters(), lr=config[\"lr\"], momentum=0.9)\n\n\nImplementing a Configurable Neural Network With spotPython\nspotPython implements a class which is similar to the class described in the PyTorch tutorial. The class is called Net_CIFAR10 and is implemented in the file netcifar10.py.\nfrom torch import nn\nimport torch.nn.functional as F\nimport spotPython.torch.netcore as netcore\n\n\nclass Net_CIFAR10(netcore.Net_Core):\n    def __init__(self, l1, l2, lr_mult, batch_size, epochs, k_folds, patience,\n    optimizer, sgd_momentum):\n        super(Net_CIFAR10, self).__init__(\n            lr_mult=lr_mult,\n            batch_size=batch_size,\n            epochs=epochs,\n            k_folds=k_folds,\n            patience=patience,\n            optimizer=optimizer,\n            sgd_momentum=sgd_momentum,\n        )\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#the-net_core-class",
    "href": "14_spot_ray_hpt_torch_cifar10.html#the-net_core-class",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "The Net_Core class",
    "text": "The Net_Core class\nNet_CIFAR10 inherits from the class Net_Core which is implemented in the file netcore.py. It implements the additional attributes that are common to all neural network models. The Net_Core class is implemented in the file netcore.py. It implements hyperparameters as attributes, that are not used by the core_model, e.g.:\n\noptimizer (optimizer),\nlearning rate (lr),\nbatch size (batch_size),\nepochs (epochs),\nk_folds (k_folds), and\nearly stopping criterion “patience” (patience).\n\nUsers can add further attributes to the class. The class Net_Core is shown below.\nfrom torch import nn\n\n\nclass Net_Core(nn.Module):\n    def __init__(self, lr_mult, batch_size, epochs, k_folds, patience,\n        optimizer, sgd_momentum):\n        super(Net_Core, self).__init__()\n        self.lr_mult = lr_mult\n        self.batch_size = batch_size\n        self.epochs = epochs\n        self.k_folds = k_folds\n        self.patience = patience\n        self.optimizer = optimizer\n        self.sgd_momentum = sgd_momentum"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-comparison",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-comparison",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Comparison of the Approach Described in the PyTorch Tutorial With spotPython",
    "text": "Comparison of the Approach Described in the PyTorch Tutorial With spotPython\nComparing the class Net from the PyTorch tutorial and the class Net_CIFAR10 from spotPython, we see that the class Net_CIFAR10 has additional attributes and does not inherit from nn directly. It adds an additional class, Net_core, that takes care of additional attributes that are common to all neural network models, e.g., the learning rate multiplier lr_mult or the batch size batch_size.\nspotPython’s core_model implements an instance of the Net_CIFAR10 class. In addition to the basic neural network model, the core_model can use these additional attributes. spotPython provides methods for handling these additional attributes to guarantee 100% compatibility with the PyTorch classes. The method add_core_model_to_fun_control adds the hyperparameters and additional attributes to the fun_control dictionary. The method is shown below.\n\nfrom spotPython.torch.netcifar10 import Net_CIFAR10\nfrom spotPython.data.torch_hyper_dict import TorchHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\ncore_model = Net_CIFAR10\nfun_control = add_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=TorchHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-ray-tune",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-ray-tune",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Configuring the Search Space With Ray Tune",
    "text": "Configuring the Search Space With Ray Tune\nRay Tune’s search space can be configured as follows (PyTorch 2023a):\nconfig = {\n    \"l1\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"l2\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"lr\": tune.loguniform(1e-4, 1e-1),\n    \"batch_size\": tune.choice([2, 4, 8, 16])\n}\nThe tune.sample_from() function enables the user to define sample methods to obtain hyperparameters. In this example, the l1 and l2 parameters should be powers of 2 between 4 and 256, so either 4, 8, 16, 32, 64, 128, or 256. The lr (learning rate) should be uniformly sampled between 0.0001 and 0.1. Lastly, the batch size is a choice between 2, 4, 8, and 16.\nAt each trial, ray[tune] will randomly sample a combination of parameters from these search spaces. It will then train a number of models in parallel and find the best performing one among these. ray[tune] uses the ASHAScheduler which will terminate bad performing trials early."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-spotpython",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-configuring-the-search-space-with-spotpython",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Configuring the Search Space With spotPython",
    "text": "Configuring the Search Space With spotPython\n\nThe hyper_dict Hyperparameters for the Selected Algorithm\nspotPython uses JSON files for the specification of the hyperparameters. Users can specify their individual JSON files, or they can use the JSON files provided by spotPython. The JSON file for the core_model is called torch_hyper_dict.json.\nIn contrast to ray[tune], spotPython can handle numerical, boolean, and categorical hyperparameters. They can be specified in the JSON file in a similar way as the numerical hyperparameters as shown below. Each entry in the JSON file represents one hyperparameter with the following structure: type, default, transform, lower, and upper.\n\"factor_hyperparameter\": {\n    \"levels\": [\"A\", \"B\", \"C\"],\n    \"type\": \"factor\",\n    \"default\": \"B\",\n    \"transform\": \"None\",\n    \"core_model_parameter_type\": \"str\",\n    \"lower\": 0,\n    \"upper\": 2},\nThe corresponding entries for the Net_CIFAR10 class are shown below.\n{\"Net_CIFAR10\":\n    {\n        \"l1\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"l2\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 2,\n            \"upper\": 9},\n        \"lr_mult\": {\n            \"type\": \"float\",\n            \"default\": 1.0,\n            \"transform\": \"None\",\n            \"lower\": 0.1,\n            \"upper\": 10},\n        \"batch_size\": {\n            \"type\": \"int\",\n            \"default\": 4,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"epochs\": {\n            \"type\": \"int\",\n            \"default\": 3,\n            \"transform\": \"transform_power_2_int\",\n            \"lower\": 1,\n            \"upper\": 4},\n        \"k_folds\": {\n            \"type\": \"int\",\n            \"default\": 2,\n            \"transform\": \"None\",\n            \"lower\": 2,\n            \"upper\": 3},\n        \"patience\": {\n            \"type\": \"int\",\n            \"default\": 5,\n            \"transform\": \"None\",\n            \"lower\": 2,\n            \"upper\": 10},\n        \"optimizer\": {\n            \"levels\": [\"Adadelta\",\n                       \"Adagrad\",\n                       \"Adam\",\n                       \"AdamW\",\n                       \"SparseAdam\",\n                       \"Adamax\",\n                       \"ASGD\",\n                       \"LBFGS\",\n                       \"NAdam\",\n                       \"RAdam\",\n                       \"RMSprop\",\n                       \"Rprop\",\n                       \"SGD\"],\n            \"type\": \"factor\",\n            \"default\": \"SGD\",\n            \"transform\": \"None\",\n            \"class_name\": \"torch.optim\",\n            \"core_model_parameter_type\": \"str\",\n            \"lower\": 0,\n            \"upper\": 12},\n        \"sgd_momentum\": {\n            \"type\": \"float\",\n            \"default\": 0.0,\n            \"transform\": \"None\",\n            \"lower\": 0.0,\n            \"upper\": 1.0}\n    }\n}"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Modifying the Hyperparameters",
    "text": "Modifying the Hyperparameters\nRay tune (PyTorch 2023a) does not provide a way to change the specified hyperparameters without re-compilation. However, spotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions are described in the following.\n\nModify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter specifying the model, the corresponding hyperparameters, their types and bounds are loaded from the JSON file torch_hyper_dict.json. After loading, the user can modify the hyperparameters, e.g., the bounds. spotPython provides a simple rule for de-activating hyperparameters: If the lower and the upper bound are set to identical values, the hyperparameter is de-activated. This is useful for the hyperparameter tuning, because it allows to specify a hyperparameter in the JSON file, but to de-activate it in the fun_control dictionary. This is done in the next step.\n\n\nModify Hyperparameters of Type numeric and integer (boolean)\nSince the hyperparameter k_folds is not used in the PyTorch tutorial, it is de-activated here by setting the lower and upper bound to the same value. Note, k_folds is of type “integer”.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"batch_size\", bounds=[1, 5])\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"k_folds\", bounds=[0, 0])\nfun_control = modify_hyper_parameter_bounds(fun_control, \n    \"patience\", bounds=[3, 3])\n\n\n\nModify Hyperparameter of Type factor\nIn a similar manner as for the numerical hyperparameters, the categorical hyperparameters can be modified. New configurations can be chosen by adding or deleting levels. For example, the hyperparameter optimizer can be re-configured as follows:\nIn the following setting, two optimizers (\"SGD\" and \"Adam\") will be compared during the spotPython hyperparameter tuning. The hyperparameter optimizer is active.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nfun_control = modify_hyper_parameter_levels(fun_control,\n     \"optimizer\", [\"SGD\", \"Adam\"])\n\nThe hyperparameter optimizer can be de-activated by choosing only one value (level), here: \"SGD\".\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\", [\"SGD\"])\n\nAs discussed in Section 8, there are some issues with the LBFGS optimizer. Therefore, the usage of the LBFGS optimizer is not deactivated in spotPython by default. However, the LBFGS optimizer can be activated by adding it to the list of optimizers. Rprop was removed, because it does perform very poorly (as some pre-tests have shown). However, it can also be activated by adding it to the list of optimizers. Since SparseAdam does not support dense gradients, Adam was used instead. Therefore, there are 10 default optimizers:\n\nfun_control = modify_hyper_parameter_levels(fun_control, \"optimizer\",\n    [\"Adadelta\", \"Adagrad\", \"Adam\", \"AdamW\", \"Adamax\", \"ASGD\", \n    \"NAdam\", \"RAdam\", \"RMSprop\", \"SGD\"])"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-lbfgs",
    "href": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-lbfgs",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "A note on LBFGS",
    "text": "A note on LBFGS\nWe recommend deactivating PyTorch’s LBFGS optimizer, because it does not perform very well. The PyTorch documentation, see https://pytorch.org/docs/stable/generated/torch.optim.LBFGS.html#torch.optim.LBFGS, states:\n\nThis is a very memory intensive optimizer (it requires additional param_bytes * (history_size + 1) bytes). If it doesn’t fit in memory try reducing the history size, or use a different algorithm.\n\nFurthermore, the LBFGS optimizer is not compatible with the PyTorch tutorial. The reason is that the LBFGS optimizer requires the closure function, which is not implemented in the PyTorch tutorial. Therefore, the LBFGS optimizer is recommended here. Since there are ten optimizers in the portfolio, it is not recommended tuning the hyperparameters that effect one single optimizer only."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-the-learning-rate",
    "href": "14_spot_ray_hpt_torch_cifar10.html#a-note-on-the-learning-rate",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "A note on the learning rate",
    "text": "A note on the learning rate\nspotPython provides a multiplier for the default learning rates, lr_mult, because optimizers use different learning rates. Using a multiplier for the learning rates might enable a simultaneous tuning of the learning rates for all optimizers. However, this is not recommended, because the learning rates are not comparable across optimizers. Therefore, we recommend fixing the learning rate for all optimizers if multiple optimizers are used. This can be done by setting the lower and upper bounds of the learning rate multiplier to the same value as shown below.\nThus, the learning rate, which affects the SGD optimizer, will be set to a fixed value. We choose the default value of 1e-3 for the learning rate, because it is used in other PyTorch examples (it is also the default value used by spotPython as defined in the optimizer_handler() method). We recommend tuning the learning rate later, when a reduced set of optimizers is fixed. Here, we will demonstrate how to select in a screening phase the optimizers that should be used for the hyperparameter tuning. For the same reason, we will fix the sgd_momentum to 0.9.\n\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"lr_mult\", bounds=[1.0, 1.0])\nfun_control = modify_hyper_parameter_bounds(fun_control,\n    \"sgd_momentum\", bounds=[0.9, 0.9])"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#hold-out-data-split",
    "href": "14_spot_ray_hpt_torch_cifar10.html#hold-out-data-split",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Hold-out Data Split",
    "text": "Hold-out Data Split\nIf a hold-out data split is used, the data will be partitioned into a training, a validation, and a test data set. The split depends on the setting of the eval parameter. If eval is set to train_hold_out, one data set, usually the original training data set, is split into a new training and a validation data set. The training data set is used for training the model. The validation data set is used for the evaluation of the hyperparameter configuration and early stopping to prevent overfitting. In this case, the original test data set is not used.\nspotPython returns the hyperparameters of the machine learning and deep learning models, e.g., number of layers, learning rate, or optimizer, but not the model weights. Therefore, after the SPOT run is finished, the corresponding model with the optimized architecture has to be trained again with the best hyperparameter configuration. The training is performed on the training data set. The test data set is used for the final evaluation of the model.\nSummarizing, the following splits are performed in the hold-out setting:\n\nRun spotPython with eval set to train_hold_out to determine the best hyperparameter configuration.\nTrain the model with the best hyperparameter configuration (“architecture”) on the training data set: train_tuned(model_spot, train, \"model_spot.pt\").\nTest the model on the test data: test_tuned(model_spot, test, \"model_spot.pt\")\n\nThese steps will be exemplified in the following sections. In addition to this hold-out setting, spotPython provides another hold-out setting, where an explicit test data is specified by the user that will be used as the validation set. To choose this option, the eval parameter is set to test_hold_out. In this case, the training data set is used for the model training. Then, the explicitly defined test data set is used for the evaluation of the hyperparameter configuration (the validation)."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#cross-validation",
    "href": "14_spot_ray_hpt_torch_cifar10.html#cross-validation",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Cross-Validation",
    "text": "Cross-Validation\nThe cross validation setting is used by setting the eval parameter to train_cv or test_cv. In both cases, the data set is split into \\(k\\) folds. The model is trained on \\(k-1\\) folds and evaluated on the remaining fold. This is repeated \\(k\\) times, so that each fold is used exactly once for evaluation. The final evaluation is performed on the test data set. The cross validation setting is useful for small data sets, because it allows to use all data for training and evaluation. However, it is computationally expensive, because the model has to be trained \\(k\\) times.\nCombinations of the above settings are possible, e.g., cross validation can be used for training and hold-out for evaluation or vice versa. Also, cross validation can be used for training and testing. Because cross validation is not used in the PyTorch tutorial (PyTorch 2023a), it is not considered further here."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#overview-of-the-evaluation-settings",
    "href": "14_spot_ray_hpt_torch_cifar10.html#overview-of-the-evaluation-settings",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Overview of the Evaluation Settings",
    "text": "Overview of the Evaluation Settings\n\nSettings for the Hyperparameter Tuning\nAn overview of the training evaluations is shown in Table 2. \"train_cv\" and \"test_cv\" use sklearn.model_selection.KFold() internally. More details on the data splitting are provided in Section 18.2 (in the Appendix).\n\n\nTable 2: Overview of the evaluation settings.\n\n\n\n\n\n\n\n\n\neval\ntrain\ntest\nfunction\ncomment\n\n\n\n\n\"train_hold_out\"\n\\(\\checkmark\\)\n\ntrain_one_epoch(), validate_one_epoch() for early stopping\nsplits the train data set internally\n\n\n\"test_hold_out\"\n\\(\\checkmark\\)\n\\(\\checkmark\\)\ntrain_one_epoch(), validate_one_epoch() for early stopping\nuse the test data set for validate_one_epoch()\n\n\n\"train_cv\"\n\\(\\checkmark\\)\n\nevaluate_cv(net, train)\nCV using the train data set\n\n\n\"test_cv\"\n\n\\(\\checkmark\\)\nevaluate_cv(net, test)\nCV using the test data set . Identical to \"train_cv\", uses only test data.\n\n\n\n\n\n\nSettings for the Final Evaluation of the Tuned Architecture\n\nTraining of the Tuned Architecture\ntrain_tuned(model, train): train the model with the best hyperparameter configuration (or simply the default) on the training data set. It splits the traindata into new train and validation sets using create_train_val_data_loaders(), which calls torch.utils.data.random_split() internally. Currently, 60% of the data is used for training and 40% for validation. The train data is used for training the model with train_hold_out(). The validation data is used for early stopping using validate_fold_or_hold_out() on the validation data set.\n\n\nTesting of the Tuned Architecture\ntest_tuned(model, test): test the model on the test data set. No data splitting is performed. The (trained) model is evaluated using the validate_fold_or_hold_out() function. Note: During training, shuffle is set to True, whereas during testing, shuffle is set to False.\nSection 18.2.5 describes the final evaluation of the tuned architecture."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#tensorboard-start-tensorboard",
    "href": "14_spot_ray_hpt_torch_cifar10.html#tensorboard-start-tensorboard",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Tensorboard: Start Tensorboard",
    "text": "Tensorboard: Start Tensorboard\nStart TensorBoard through the command line to visualize data you logged. Specify the root log directory as used in fun_control = fun_control_init(task=\"regression\", tensorboard_path=\"runs/24_spot_torch_regression\") as the tensorboard_path. The argument logdir points to directory where TensorBoard will look to find event files that it can display. TensorBoard will recursively walk the directory structure rooted at logdir, looking for .tfevents. files.\ntensorboard --logdir=runs\nGo to the URL it provides or to http://localhost:6006/. The following figures show some screenshots of Tensorboard.\n\n\n\nFigure 1: Tensorboard\n\n\n\n\n\nFigure 2: Tensorboard"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-saving-the-state-of-the-notebook",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-saving-the-state-of-the-notebook",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Saving the State of the Notebook",
    "text": "Saving the State of the Notebook\nThe state of the notebook can be saved and reloaded as follows:\n\nimport pickle\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"add_the_name_of_the_result_file_here.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-get-spot-results",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-get-spot-results",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Get SPOT Results",
    "text": "Get SPOT Results\nThe architecture of the spotPython model can be obtained by the following code:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\nmodel_spot\n\nFirst, the numerical representation of the hyperparameters are obtained, i.e., the numpy array X is generated. This array is then used to generate the model model_spot by the function get_one_core_model_from_X. The model model_spot has the following architecture:\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1,\n    ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=64, bias=True)\n  (fc2): Linear(in_features=64, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=10, bias=True)\n)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#get-default-hyperparameters",
    "href": "14_spot_ray_hpt_torch_cifar10.html#get-default-hyperparameters",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Get Default Hyperparameters",
    "text": "Get Default Hyperparameters\nIn a similar manner as in Section 16.1, the default hyperparameters can be obtained.\n\n# fun_control was modified, we generate a new one with the original \n# default hyperparameters\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfc = fun_control\nfc.update({\"core_model_hyper_dict\":\n    hyper_dict[fun_control[\"core_model\"].__name__]})\nmodel_default = get_one_core_model_from_X(X_start, fun_control=fc)\n\nThe corresponding default model has the following architecture:\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1,\n    ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=32, bias=True)\n  (fc2): Linear(in_features=32, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=10, bias=True)\n)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-default-architecture",
    "href": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-default-architecture",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Evaluation of the Default Architecture",
    "text": "Evaluation of the Default Architecture\nThe method train_tuned takes a model architecture without trained weights and trains this model with the train data. The train data is split into train and validation data. The validation data is used for early stopping. The trained model weights are saved as a dictionary.\nThis evaluation is similar to the final evaluation in PyTorch (2023a).\n\nfrom spotPython.torch.traintest import (\n    train_tuned,\n    test_tuned,\n    )\ntrain_tuned(net=model_default, train_dataset=train, shuffle=True,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        device = DEVICE, show_batch_interval=1_000_000,\n        path=None,\n        task=fun_control[\"task\"],)\n\ntest_tuned(net=model_default, test_dataset=test, \n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=False, \n        device = DEVICE,\n        task=fun_control[\"task\"],)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "href": "14_spot_ray_hpt_torch_cifar10.html#evaluation-of-the-tuned-architecture",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Evaluation of the Tuned Architecture",
    "text": "Evaluation of the Tuned Architecture\nThe following code trains the model model_spot. If path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be saved to this file.\n\ntrain_tuned(net=model_spot, train_dataset=train,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=True,\n        device = DEVICE,\n        path=None,\n        task=fun_control[\"task\"],)\ntest_tuned(net=model_spot, test_dataset=test,\n            shuffle=False,\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            device = DEVICE,\n            task=fun_control[\"task\"],)\n\nThese runs will generate output similar to the following:\nLoss on hold-out set: 1.2267619131326675\nAccuracy on hold-out set: 0.58955\nEarly stopping at epoch 13"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#comparison-with-default-hyperparameters-and-ray-tune",
    "href": "14_spot_ray_hpt_torch_cifar10.html#comparison-with-default-hyperparameters-and-ray-tune",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Comparison with Default Hyperparameters and Ray Tune",
    "text": "Comparison with Default Hyperparameters and Ray Tune\nTable 5 shows the loss and accuracy of the default model, the model with the hyperparameters from SPOT, and the model with the hyperparameters from ray[tune]. The table shows a comparison of the loss and accuracy of the default model, the model with the hyperparameters from SPOT, and the model with the hyperparameters from ray[tune]. ray[tune] only shows the validation loss, because training loss is not reported by ray[tune]\n\n\nTable 5: Comparison.\n\n\n\n\n\n\n\n\n\nModel\nValidation Loss\nValidation Accuracy\nLoss\nAccuracy\n\n\n\n\nDefault\n2.1221\n0.2452\n2.1182\n0.2425\n\n\nspotPython\n1.2268\n0.5896\n1.2426\n0.5957\n\n\nray[tune]\n1.1815\n0.5836\n-\n0.5806"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "href": "14_spot_ray_hpt_torch_cifar10.html#detailed-hyperparameter-plots",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Detailed Hyperparameter Plots",
    "text": "Detailed Hyperparameter Plots\nThe contour plots in this section visualize the interactions of the three most important hyperparameters, l1, l2, and epochs, and optimizer of the surrogate model used to optimize the hyperparameters. Since some of these hyperparameters take fatorial or integer values, sometimes step-like fitness landcapes (or response surfaces) are generated. SPOT draws the interactions of the main hyperparameters by default. It is also possible to visualize all interactions. For this, again refer to the notebook (Bartz-Beielstein 2023).\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\n\n\n\nFigure 5: Contour plot of the loss as a function of l1 and l2, i.e., the number of neurons in the layers.\n\n\n\n\n\nFigure 6: Contour plot of the loss as a function of the number of epochs and the neurons in layer l1.\n\n\n\n\n\nFigure 7: Contour plot of the loss as a function of the optimizer and the neurons in layer l1.\n\n\n\n\n\nFigure 8: Contour plot of the loss as a function of the number of epochs and the neurons in layer l2.\n\n\n\n\n\nFigure 9: Contour plot of the loss as a function of the optimizer and the neurons in layer l2.\n\n\n\n\n\nFigure 10: Contour plot of the loss as a function of the optimizer and the number of epochs.\n\n\nThe figures (Figure 5 to Figure 10) show the contour plots of the loss as a function of the hyperparameters. These plots are very helpful for benchmark studies and for understanding neural networks. spotPython provides additional tools for a visual inspection of the results and give valuable insights into the hyperparameter tuning process. This is especially useful for model explainability, transparency, and trustworthiness. In addition to the contour plots, Figure 11 shows the parallel plot of the hyperparameters.\n\nspot_tuner.parallel_plot()\n\n\n\n\nFigure 11: Parallel plot"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sample-output-from-ray-tunes-run",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sample-output-from-ray-tunes-run",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Sample Output From Ray Tune’s Run",
    "text": "Sample Output From Ray Tune’s Run\nThe output from ray[tune] could look like this (PyTorch 2023b):\nNumber of trials: 10 (10 TERMINATED)\n------+------+-------------+--------------+---------+------------+--------------------+\n|   l1 |   l2 |          lr |   batch_size |    loss |   accuracy | training_iteration |\n+------+------+-------------+--------------+---------+------------+--------------------|\n|   64 |    4 | 0.00011629  |            2 | 1.87273 |     0.244  |                  2 |\n|   32 |   64 | 0.000339763 |            8 | 1.23603 |     0.567  |                  8 |\n|    8 |   16 | 0.00276249  |           16 | 1.1815  |     0.5836 |                 10 |\n|    4 |   64 | 0.000648721 |            4 | 1.31131 |     0.5224 |                  8 |\n|   32 |   16 | 0.000340753 |            8 | 1.26454 |     0.5444 |                  8 |\n|    8 |    4 | 0.000699775 |            8 | 1.99594 |     0.1983 |                  2 |\n|  256 |    8 | 0.0839654   |           16 | 2.3119  |     0.0993 |                  1 |\n|   16 |  128 | 0.0758154   |           16 | 2.33575 |     0.1327 |                  1 |\n|   16 |    8 | 0.0763312   |           16 | 2.31129 |     0.1042 |                  4 |\n|  128 |   16 | 0.000124903 |            4 | 2.26917 |     0.1945 |                  1 |\n+-----+------+------+-------------+--------------+---------+------------+--------------------+\nBest trial config: {'l1': 8, 'l2': 16, 'lr': 0.00276249, 'batch_size': 16, 'data_dir': '...'}\nBest trial final validation loss: 1.181501\nBest trial final validation accuracy: 0.5836\nBest trial test set accuracy: 0.5806"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-detailed-data-splitting",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-detailed-data-splitting",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Detailed Description of the Data Splitting",
    "text": "Detailed Description of the Data Splitting\n\nDescription of the \"train_hold_out\" Setting\nThe \"train_hold_out\" setting is used by default. It uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc(), which is implemented in the file hypertorch.py, calls evaluate_hold_out() as follows:\n\ndf_eval, _ = evaluate_hold_out(\n    model,\n    train_dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    loss_function=self.fun_control[\"loss_function\"],\n    metric=self.fun_control[\"metric_torch\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    path=self.fun_control[\"path\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: Only the data set fun_control[\"train\"] is used for training and validation. It is used in evaluate_hold_out as follows:\ntrainloader, valloader = create_train_val_data_loaders(\n                dataset=train_dataset, batch_size=batch_size_instance, shuffle=shuffle\n            )\ncreate_train_val_data_loaders() splits the train_dataset into trainloader and valloader using torch.utils.data.random_split() as follows:\ndef create_train_val_data_loaders(dataset, batch_size, shuffle, num_workers=0):\n    test_abs = int(len(dataset) * 0.6)\n    train_subset, val_subset = random_split(dataset, [test_abs, len(dataset) - test_abs])\n    trainloader = torch.utils.data.DataLoader(\n        train_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    valloader = torch.utils.data.DataLoader(\n        val_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    return trainloader, valloader\nThe optimizer is set up as follows:\noptimizer_instance = net.optimizer\nlr_mult_instance = net.lr_mult\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(\n    optimizer_name=optimizer_instance,\n    params=net.parameters(),\n    lr_mult=lr_mult_instance,\n    sgd_momentum=sgd_momentum_instance,\n)\n\nevaluate_hold_out() sets the net attributes such as epochs, batch_size, optimizer, and patience. For each epoch, the methods train_one_epoch() and validate_one_epoch() are called, the former for training and the latter for validation and early stopping. The validation loss from the last epoch (not the best validation loss) is returned from evaluate_hold_out.\nThe method train_one_epoch() is implemented as follows:\n\ndef train_one_epoch(\n    net,\n    trainloader,\n    batch_size,\n    loss_function,\n    optimizer,\n    device,\n    show_batch_interval=10_000,\n    task=None,\n):\n    running_loss = 0.0\n    epoch_steps = 0\n    for batch_nr, data in enumerate(trainloader, 0):\n        input, target = data\n        input, target = input.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = net(input)\n        if task == \"regression\":\n            target = target.unsqueeze(1)\n            if target.shape == output.shape:\n                loss = loss_function(output, target)\n            else:\n                raise ValueError(f\"Shapes of target and output do not match:\n                 {target.shape} vs {output.shape}\")\n        elif task == \"classification\":\n            loss = loss_function(output, target)\n        else:\n            raise ValueError(f\"Unknown task: {task}\")\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(net.parameters(), max_norm=1.0)\n        optimizer.step()\n        running_loss += loss.item()\n        epoch_steps += 1\n        if batch_nr % show_batch_interval == (show_batch_interval - 1):  \n            print(\n                \"Batch: %5d. Batch Size: %d. Training Loss (running): %.3f\"\n                % (batch_nr + 1, int(batch_size), running_loss / epoch_steps)\n            )\n            running_loss = 0.0\n    return loss.item()\n\nThe method validate_one_epoch() is implemented as follows:\n\ndef validate_one_epoch(net, valloader, loss_function, metric, device, task):\n    val_loss = 0.0\n    val_steps = 0\n    total = 0\n    correct = 0\n    metric.reset()\n    for i, data in enumerate(valloader, 0):\n        # get batches\n        with torch.no_grad():\n            input, target = data\n            input, target = input.to(device), target.to(device)\n            output = net(input)\n            # print(f\"target: {target}\")\n            # print(f\"output: {output}\")\n            if task == \"regression\":\n                target = target.unsqueeze(1)\n                if target.shape == output.shape:\n                    loss = loss_function(output, target)\n                else:\n                    raise ValueError(f\"Shapes of target and output \n                        do not match: {target.shape} vs {output.shape}\")\n                metric_value = metric.update(output, target)\n            elif task == \"classification\":\n                loss = loss_function(output, target)\n                metric_value = metric.update(output, target)\n                _, predicted = torch.max(output.data, 1)\n                total += target.size(0)\n                correct += (predicted == target).sum().item()\n            else:\n                raise ValueError(f\"Unknown task: {task}\")\n            val_loss += loss.cpu().numpy()\n            val_steps += 1\n    loss = val_loss / val_steps\n    print(f\"Loss on hold-out set: {loss}\")\n    if task == \"classification\":\n        accuracy = correct / total\n        print(f\"Accuracy on hold-out set: {accuracy}\")\n    # metric on all batches using custom accumulation\n    metric_value = metric.compute()\n    metric_name = type(metric).__name__\n    print(f\"{metric_name} value on hold-out data: {metric_value}\")\n    return metric_value, loss\n\n\nDescription of the \"test_hold_out\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_hold_out() similar to the \"train_hold_out\" setting with one exception: It passes an additional test data set to evaluate_hold_out() as follows:\n\ntest_dataset=fun_control[\"test\"]\nevaluate_hold_out() calls create_train_test_data_loaders instead of create_train_val_data_loaders: The two data sets are used in create_train_test_data_loaders as follows:\ndef create_train_test_data_loaders(dataset, batch_size, shuffle, test_dataset, \n        num_workers=0):\n    trainloader = torch.utils.data.DataLoader(\n        dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    testloader = torch.utils.data.DataLoader(\n        test_dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    return trainloader, testloader\n\nThe following steps are identical to the \"train_hold_out\" setting. Only a different data loader is used for testing.\n\n\n\nDetailed Description of the \"train_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows (Note: Only the data set fun_control[\"train\"] is used for CV.):\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\n\nIn `evaluate_cv(), the following steps are performed: The optimizer is set up as follows:\n\noptimizer_instance = net.optimizer\nlr_instance = net.lr\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(optimizer_name=optimizer_instance,\n     params=net.parameters(), lr_mult=lr_mult_instance)\nevaluate_cv() sets the net attributes such as epochs, batch_size, optimizer, and patience. CV is implemented as follows:\ndef evaluate_cv(\n    net,\n    dataset,\n    shuffle=False,\n    loss_function=None,\n    num_workers=0,\n    device=None,\n    show_batch_interval=10_000,\n    metric=None,\n    path=None,\n    task=None,\n    writer=None,\n    writerId=None,\n):\n    lr_mult_instance = net.lr_mult\n    epochs_instance = net.epochs\n    batch_size_instance = net.batch_size\n    k_folds_instance = net.k_folds\n    optimizer_instance = net.optimizer\n    patience_instance = net.patience\n    sgd_momentum_instance = net.sgd_momentum\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    metric_values = {}\n    loss_values = {}\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        optimizer = optimizer_handler(\n            optimizer_name=optimizer_instance,\n            params=net.parameters(),\n            lr_mult=lr_mult_instance,\n            sgd_momentum=sgd_momentum_instance,\n        )\n        kfold = KFold(n_splits=k_folds_instance, shuffle=shuffle)\n        for fold, (train_ids, val_ids) in enumerate(kfold.split(dataset)):\n            print(f\"Fold: {fold + 1}\")\n            train_subsampler = torch.utils.data.SubsetRandomSampler(train_ids)\n            val_subsampler = torch.utils.data.SubsetRandomSampler(val_ids)\n            trainloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=train_subsampler, num_workers=num_workers\n            )\n            valloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=val_subsampler, num_workers=num_workers\n            )\n            # each fold starts with new weights:\n            reset_weights(net)\n            # Early stopping parameters\n            best_val_loss = float(\"inf\")\n            counter = 0\n            for epoch in range(epochs_instance):\n                print(f\"Epoch: {epoch + 1}\")\n                # training loss from one epoch:\n                training_loss = train_one_epoch(\n                    net=net,\n                    trainloader=trainloader,\n                    batch_size=batch_size_instance,\n                    loss_function=loss_function,\n                    optimizer=optimizer,\n                    device=device,\n                    show_batch_interval=show_batch_interval,\n                    task=task,\n                )\n                # Early stopping check. Calculate validation loss from one epoch:\n                metric_values[fold], loss_values[fold] = validate_one_epoch(\n                    net, valloader=valloader, loss_function=loss_function, \n                    metric=metric, device=device, task=task\n                )\n                # Log the running loss averaged per batch\n                metric_name = \"Metric\"\n                if metric is None:\n                    metric_name = type(metric).__name__\n                    print(f\"{metric_name} value on hold-out data: \n                        {metric_values[fold]}\")\n                if writer is not None:\n                    writer.add_scalars(\n                        \"evaluate_cv fold:\" + str(fold + 1) + \n                        \". Train & Val Loss and Val Metric\" + writerId,\n                        {\"Train loss\": training_loss, \"Val loss\": \n                        loss_values[fold], metric_name: metric_values[fold]},\n                        epoch + 1,\n                    )\n                    writer.flush()\n                if loss_values[fold] &lt; best_val_loss:\n                    best_val_loss = loss_values[fold]\n                    counter = 0\n                    # save model:\n                    if path is not None:\n                        torch.save(net.state_dict(), path)\n                else:\n                    counter += 1\n                    if counter &gt;= patience_instance:\n                        print(f\"Early stopping at epoch {epoch}\")\n                        break\n        df_eval = sum(loss_values.values()) / len(loss_values.values())\n        df_metrics = sum(metric_values.values()) / len(metric_values.values())\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to evaluate_cv() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    if writer is not None:\n        metric_name = \"Metric\"\n        if metric is None:\n            metric_name = type(metric).__name__\n        writer.add_scalars(\n            \"CV: Val Loss and Val Metric\" + writerId,\n            {\"CV-loss\": df_eval, metric_name: df_metrics},\n            epoch + 1,\n        )\n        writer.flush()\n    return df_eval, df_preds, df_metrics\n\nThe method train_fold() is implemented as shown above.\nThe method validate_one_epoch() is implemented as shown above. In contrast to the hold-out setting, it is called for each of the \\(k\\) folds. The results are stored in a dictionaries metric_values and loss_values. The results are averaged over the \\(k\\) folds and returned as df_eval.\n\n\n\nDetailed Description of the \"test_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows:\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"test\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: The data set fun_control[\"test\"] is used for CV. The rest is the same as for the \"train_cv\" setting.\n\n\nDetailed Description of the Final Model Training and Evaluation\n\nDetailed Description of the \"train_tuned Procedure\ntrain_tuned() is just a wrapper to evaluate_hold_out using the train data set. It is implemented as follows:\ndef train_tuned(\n    net,\n    train_dataset,\n    shuffle,\n    loss_function,\n    metric,\n    device=None,\n    show_batch_interval=10_000,\n    path=None,\n    task=None,\n    writer=None,\n):\n    evaluate_hold_out(\n        net=net,\n        train_dataset=train_dataset,\n        shuffle=shuffle,\n        test_dataset=None,\n        loss_function=loss_function,\n        metric=metric,\n        device=device,\n        show_batch_interval=show_batch_interval,\n        path=path,\n        task=task,\n        writer=writer,\n    )\nThe test_tuned() procedure is implemented as follows:\ndef test_tuned(net, shuffle, test_dataset=None, loss_function=None,\n    metric=None, device=None, path=None, task=None):\n    batch_size_instance = net.batch_size\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    if path is not None:\n        net.load_state_dict(torch.load(path))\n        net.eval()\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        valloader = torch.utils.data.DataLoader(\n            test_dataset, batch_size=int(batch_size_instance),\n            shuffle=shuffle, \n            num_workers=0\n        )\n        metric_value, loss = validate_one_epoch(\n            net, valloader=valloader, loss_function=loss_function,\n            metric=metric, device=device, task=task\n        )\n        df_eval = loss\n        df_metric = metric_value\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to test_tuned() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_metric = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    print(f\"Final evaluation: Validation loss: {df_eval}\")\n    print(f\"Final evaluation: Validation metric: {df_metric}\")\n    print(\"----------------------------------------------\")\n    return df_eval, df_preds, df_metric"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "href": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "title": "PyTorch Hyperparameter Tuning — A Tutorial for spotPython",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/sequential-parameter-optimization↩︎\nAlternatively, the source code can be downloaded from gitHub: https://github.com/sequential-parameter-optimization/spotPython.↩︎\nWe were not able to install Ray Tune on our system. Therefore, we used the results from the PyTorch tutorial.↩︎"
  }
]